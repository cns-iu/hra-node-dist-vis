(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));

  // node_modules/hammerjs/hammer.js
  var require_hammer = __commonJS({
    "node_modules/hammerjs/hammer.js"(exports, module) {
      (function(window3, document2, exportName, undefined2) {
        "use strict";
        var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
        var TEST_ELEMENT = document2.createElement("div");
        var TYPE_FUNCTION = "function";
        var round2 = Math.round;
        var abs = Math.abs;
        var now = Date.now;
        function setTimeoutContext(fn, timeout, context) {
          return setTimeout(bindFn(fn, context), timeout);
        }
        function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
          }
          return false;
        }
        function each(obj, iterator, context) {
          var i2;
          if (!obj) {
            return;
          }
          if (obj.forEach) {
            obj.forEach(iterator, context);
          } else if (obj.length !== undefined2) {
            i2 = 0;
            while (i2 < obj.length) {
              iterator.call(context, obj[i2], i2, obj);
              i2++;
            }
          } else {
            for (i2 in obj) {
              obj.hasOwnProperty(i2) && iterator.call(context, obj[i2], i2, obj);
            }
          }
        }
        function deprecate(method, name, message) {
          var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
          return function() {
            var e2 = new Error("get-stack-trace");
            var stack = e2 && e2.stack ? e2.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log4 = window3.console && (window3.console.warn || window3.console.log);
            if (log4) {
              log4.call(window3.console, deprecationMessage, stack);
            }
            return method.apply(this, arguments);
          };
        }
        var assign;
        if (typeof Object.assign !== "function") {
          assign = function assign2(target) {
            if (target === undefined2 || target === null) {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            var output = Object(target);
            for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];
              if (source !== undefined2 && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        } else {
          assign = Object.assign;
        }
        var extend = deprecate(function extend2(dest, src, merge2) {
          var keys = Object.keys(src);
          var i2 = 0;
          while (i2 < keys.length) {
            if (!merge2 || merge2 && dest[keys[i2]] === undefined2) {
              dest[keys[i2]] = src[keys[i2]];
            }
            i2++;
          }
          return dest;
        }, "extend", "Use `assign`.");
        var merge = deprecate(function merge2(dest, src) {
          return extend(dest, src, true);
        }, "merge", "Use `assign`.");
        function inherit(child, base, properties) {
          var baseP = base.prototype, childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;
          if (properties) {
            assign(childP, properties);
          }
        }
        function bindFn(fn, context) {
          return function boundFn() {
            return fn.apply(context, arguments);
          };
        }
        function boolOrFn(val, args) {
          if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined2 : undefined2, args);
          }
          return val;
        }
        function ifUndefined(val1, val2) {
          return val1 === undefined2 ? val2 : val1;
        }
        function addEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.addEventListener(type, handler, false);
          });
        }
        function removeEventListeners(target, types, handler) {
          each(splitStr(types), function(type) {
            target.removeEventListener(type, handler, false);
          });
        }
        function hasParent(node, parent) {
          while (node) {
            if (node == parent) {
              return true;
            }
            node = node.parentNode;
          }
          return false;
        }
        function inStr(str, find) {
          return str.indexOf(find) > -1;
        }
        function splitStr(str) {
          return str.trim().split(/\s+/g);
        }
        function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
            return src.indexOf(find);
          } else {
            var i2 = 0;
            while (i2 < src.length) {
              if (findByKey && src[i2][findByKey] == find || !findByKey && src[i2] === find) {
                return i2;
              }
              i2++;
            }
            return -1;
          }
        }
        function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
        }
        function uniqueArray(src, key, sort) {
          var results = [];
          var values = [];
          var i2 = 0;
          while (i2 < src.length) {
            var val = key ? src[i2][key] : src[i2];
            if (inArray(values, val) < 0) {
              results.push(src[i2]);
            }
            values[i2] = val;
            i2++;
          }
          if (sort) {
            if (!key) {
              results = results.sort();
            } else {
              results = results.sort(function sortUniqueArray(a2, b2) {
                return a2[key] > b2[key];
              });
            }
          }
          return results;
        }
        function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i2 = 0;
          while (i2 < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i2];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
              return prop;
            }
            i2++;
          }
          return undefined2;
        }
        var _uniqueId = 1;
        function uniqueId() {
          return _uniqueId++;
        }
        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window3;
        }
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = "ontouchstart" in window3;
        var SUPPORT_POINTER_EVENTS = prefixed(window3, "PointerEvent") !== undefined2;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = "touch";
        var INPUT_TYPE_PEN = "pen";
        var INPUT_TYPE_MOUSE = "mouse";
        var INPUT_TYPE_KINECT = "kinect";
        var COMPUTE_INTERVAL = 25;
        var INPUT_START2 = 1;
        var INPUT_MOVE2 = 2;
        var INPUT_END2 = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ["x", "y"];
        var PROPS_CLIENT_XY = ["clientX", "clientY"];
        function Input2(manager, callback) {
          var self2 = this;
          this.manager = manager;
          this.callback = callback;
          this.element = manager.element;
          this.target = manager.options.inputTarget;
          this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
              self2.handler(ev);
            }
          };
          this.init();
        }
        Input2.prototype = {
          /**
           * should handle the inputEvent data and trigger the callback
           * @virtual
           */
          handler: function() {
          },
          /**
           * bind the events
           */
          init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },
          /**
           * unbind the events
           */
          destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
        };
        function createInputInstance(manager) {
          var Type;
          var inputClass = manager.options.inputClass;
          if (inputClass) {
            Type = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput2;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type = MouseInput2;
          } else {
            Type = TouchMouseInput;
          }
          return new Type(manager, inputHandler);
        }
        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;
          if (isFirst) {
            manager.session = {};
          }
          input.eventType = eventType;
          computeInputData(manager, input);
          manager.emit("hammer.input", input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }
        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length;
          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          }
          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }
          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input);
          var target = manager.element;
          if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
          }
          input.target = target;
        }
        function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};
          if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }
          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v2 = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v2.x;
            velocityY = v2.y;
            velocity = abs(v2.x) > abs(v2.y) ? v2.x : v2.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
          }
          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }
        function simpleCloneInputData(input) {
          var pointers = [];
          var i2 = 0;
          while (i2 < input.pointers.length) {
            pointers[i2] = {
              clientX: round2(input.pointers[i2].clientX),
              clientY: round2(input.pointers[i2].clientY)
            };
            i2++;
          }
          return {
            timeStamp: now(),
            pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }
        function getCenter(pointers) {
          var pointersLength = pointers.length;
          if (pointersLength === 1) {
            return {
              x: round2(pointers[0].clientX),
              y: round2(pointers[0].clientY)
            };
          }
          var x2 = 0, y2 = 0, i2 = 0;
          while (i2 < pointersLength) {
            x2 += pointers[i2].clientX;
            y2 += pointers[i2].clientY;
            i2++;
          }
          return {
            x: round2(x2 / pointersLength),
            y: round2(y2 / pointersLength)
          };
        }
        function getVelocity(deltaTime, x2, y2) {
          return {
            x: x2 / deltaTime || 0,
            y: y2 / deltaTime || 0
          };
        }
        function getDirection(x2, y2) {
          if (x2 === y2) {
            return DIRECTION_NONE;
          }
          if (abs(x2) >= abs(y2)) {
            return x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y2 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        function getDistance(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x2 = p2[props[0]] - p1[props[0]], y2 = p2[props[1]] - p1[props[1]];
          return Math.sqrt(x2 * x2 + y2 * y2);
        }
        function getAngle(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x2 = p2[props[0]] - p1[props[0]], y2 = p2[props[1]] - p1[props[1]];
          return Math.atan2(y2, x2) * 180 / Math.PI;
        }
        function getRotation(start, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
        }
        function getScale(start, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
        }
        var MOUSE_INPUT_MAP2 = {
          mousedown: INPUT_START2,
          mousemove: INPUT_MOVE2,
          mouseup: INPUT_END2
        };
        var MOUSE_ELEMENT_EVENTS = "mousedown";
        var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
        function MouseInput2() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;
          this.pressed = false;
          Input2.apply(this, arguments);
        }
        inherit(MouseInput2, Input2, {
          /**
           * handle mouse events
           * @param {Object} ev
           */
          handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP2[ev.type];
            if (eventType & INPUT_START2 && ev.button === 0) {
              this.pressed = true;
            }
            if (eventType & INPUT_MOVE2 && ev.which !== 1) {
              eventType = INPUT_END2;
            }
            if (!this.pressed) {
              return;
            }
            if (eventType & INPUT_END2) {
              this.pressed = false;
            }
            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          }
        });
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START2,
          pointermove: INPUT_MOVE2,
          pointerup: INPUT_END2,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        };
        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT
          // see https://twitter.com/jacobrossi/status/480596438489890816
        };
        var POINTER_ELEMENT_EVENTS = "pointerdown";
        var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
        if (window3.MSPointerEvent && !window3.PointerEvent) {
          POINTER_ELEMENT_EVENTS = "MSPointerDown";
          POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
        }
        function PointerEventInput2() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;
          Input2.apply(this, arguments);
          this.store = this.manager.session.pointerEvents = [];
        }
        inherit(PointerEventInput2, Input2, {
          /**
           * handle mouse events
           * @param {Object} ev
           */
          handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
              }
            } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
              removePointer = true;
            }
            if (storeIndex < 0) {
              return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType,
              srcEvent: ev
            });
            if (removePointer) {
              store.splice(storeIndex, 1);
            }
          }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
        var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
        function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;
          Input2.apply(this, arguments);
        }
        inherit(SingleTouchInput, Input2, {
          handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START2) {
              this.started = true;
            }
            if (!this.started) {
              return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), "identifier", true);
          }
          return [all, changed];
        }
        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
        function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};
          Input2.apply(this, arguments);
        }
        inherit(TouchInput, Input2, {
          handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
              return;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds;
          if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }
          var i2, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
          targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target);
          });
          if (type === INPUT_START2) {
            i2 = 0;
            while (i2 < targetTouches.length) {
              targetIds[targetTouches[i2].identifier] = true;
              i2++;
            }
          }
          i2 = 0;
          while (i2 < changedTouches.length) {
            if (targetIds[changedTouches[i2].identifier]) {
              changedTargetTouches.push(changedTouches[i2]);
            }
            if (type & (INPUT_END2 | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i2].identifier];
            }
            i2++;
          }
          if (!changedTargetTouches.length) {
            return;
          }
          return [
            // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
          ];
        }
        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function TouchMouseInput() {
          Input2.apply(this, arguments);
          var handler = bindFn(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput2(this.manager, handler);
          this.primaryTouch = null;
          this.lastTouches = [];
        }
        inherit(TouchMouseInput, Input2, {
          /**
           * handle mouse and touch events
           * @param {Hammer} manager
           * @param {String} inputEvent
           * @param {Object} inputData
           */
          handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            }
            if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
            }
            this.callback(manager, inputEvent, inputData);
          },
          /**
           * remove the event listeners
           */
          destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
          }
        });
        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START2) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }
        function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];
          if (touch.identifier === this.primaryTouch) {
            var lastTouch = { x: touch.clientX, y: touch.clientY };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
              var i2 = lts.indexOf(lastTouch);
              if (i2 > -1) {
                lts.splice(i2, 1);
              }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }
        function isSyntheticEvent(eventData) {
          var x2 = eventData.srcEvent.clientX, y2 = eventData.srcEvent.clientY;
          for (var i2 = 0; i2 < this.lastTouches.length; i2++) {
            var t2 = this.lastTouches[i2];
            var dx = Math.abs(x2 - t2.x), dy = Math.abs(y2 - t2.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }
          return false;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
        var TOUCH_ACTION_COMPUTE = "compute";
        var TOUCH_ACTION_AUTO = "auto";
        var TOUCH_ACTION_MANIPULATION = "manipulation";
        var TOUCH_ACTION_NONE = "none";
        var TOUCH_ACTION_PAN_X = "pan-x";
        var TOUCH_ACTION_PAN_Y = "pan-y";
        var TOUCH_ACTION_MAP = getTouchActionProps();
        function TouchAction(manager, value) {
          this.manager = manager;
          this.set(value);
        }
        TouchAction.prototype = {
          /**
           * set the touchAction value on the element or enable the polyfill
           * @param {String} value
           */
          set: function(value) {
            if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }
            this.actions = value.toLowerCase().trim();
          },
          /**
           * just re-set the touchAction value
           */
          update: function() {
            this.set(this.manager.options.touchAction);
          },
          /**
           * compute the value for the touchAction property based on the recognizer's settings
           * @returns {String} value
           */
          compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(" "));
          },
          /**
           * this method is called on each input cycle and provides the preventing of the browser behavior
           * @param {Object} input
           */
          preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;
              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }
            if (hasPanX && hasPanY) {
              return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          },
          /**
           * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
           * @param {Object} srcEvent
           */
          preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          }
        };
        function cleanTouchActions(actions) {
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          }
          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          }
          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }
          return TOUCH_ACTION_AUTO;
        }
        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }
          var touchMap = {};
          var cssSupports = window3.CSS && window3.CSS.supports;
          ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
            touchMap[val] = cssSupports ? window3.CSS.supports("touch-action", val) : true;
          });
          return touchMap;
        }
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        function Recognizer(options) {
          this.options = assign({}, this.defaults, options || {});
          this.id = uniqueId();
          this.manager = null;
          this.options.enable = ifUndefined(this.options.enable, true);
          this.state = STATE_POSSIBLE;
          this.simultaneous = {};
          this.requireFail = [];
        }
        Recognizer.prototype = {
          /**
           * @virtual
           * @type {Object}
           */
          defaults: {},
          /**
           * set options
           * @param {Object} options
           * @return {Recognizer}
           */
          set: function(options) {
            assign(this.options, options);
            this.manager && this.manager.touchAction.update();
            return this;
          },
          /**
           * recognize simultaneous with an other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
              return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }
            return this;
          },
          /**
           * drop the simultaneous link. it doesnt remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          },
          /**
           * recognizer can only run when an other is failing
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
              return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }
            return this;
          },
          /**
           * drop the requireFailure link. it does not remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);
            if (index > -1) {
              this.requireFail.splice(index, 1);
            }
            return this;
          },
          /**
           * has require failures boolean
           * @returns {boolean}
           */
          hasRequireFailures: function() {
            return this.requireFail.length > 0;
          },
          /**
           * if the recognizer can recognize simultaneous with an other recognizer
           * @param {Recognizer} otherRecognizer
           * @returns {Boolean}
           */
          canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          },
          /**
           * You should use `tryEmit` instead of `emit` directly to check
           * that all the needed recognizers has failed before emitting.
           * @param {Object} input
           */
          emit: function(input) {
            var self2 = this;
            var state = this.state;
            function emit(event) {
              self2.manager.emit(event, input);
            }
            if (state < STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
            emit(self2.options.event);
            if (input.additionalEvent) {
              emit(input.additionalEvent);
            }
            if (state >= STATE_ENDED) {
              emit(self2.options.event + stateStr(state));
            }
          },
          /**
           * Check that all the require failure recognizers has failed,
           * if true, it emits a gesture event,
           * otherwise, setup the state to FAILED.
           * @param {Object} input
           */
          tryEmit: function(input) {
            if (this.canEmit()) {
              return this.emit(input);
            }
            this.state = STATE_FAILED;
          },
          /**
           * can we emit?
           * @returns {boolean}
           */
          canEmit: function() {
            var i2 = 0;
            while (i2 < this.requireFail.length) {
              if (!(this.requireFail[i2].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }
              i2++;
            }
            return true;
          },
          /**
           * update the recognizer
           * @param {Object} inputData
           */
          recognize: function(inputData) {
            var inputDataClone = assign({}, inputData);
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          },
          /**
           * return the state of the recognizer
           * the actual recognizing happens in this method
           * @virtual
           * @param {Object} inputData
           * @returns {Const} STATE
           */
          process: function(inputData) {
          },
          // jshint ignore:line
          /**
           * return the preferred touch-action
           * @virtual
           * @returns {Array}
           */
          getTouchAction: function() {
          },
          /**
           * called when the gesture isn't allowed to recognize
           * like when another is being recognized or it is disabled
           * @virtual
           */
          reset: function() {
          }
        };
        function stateStr(state) {
          if (state & STATE_CANCELLED) {
            return "cancel";
          } else if (state & STATE_ENDED) {
            return "end";
          } else if (state & STATE_CHANGED) {
            return "move";
          } else if (state & STATE_BEGAN) {
            return "start";
          }
          return "";
        }
        function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
            return "down";
          } else if (direction == DIRECTION_UP) {
            return "up";
          } else if (direction == DIRECTION_LEFT) {
            return "left";
          } else if (direction == DIRECTION_RIGHT) {
            return "right";
          }
          return "";
        }
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
            return manager.get(otherRecognizer);
          }
          return otherRecognizer;
        }
        function AttrRecognizer() {
          Recognizer.apply(this, arguments);
        }
        inherit(AttrRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof AttrRecognizer
           */
          defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
          },
          /**
           * Used to check if it the recognizer receives valid input, like input.distance > 10.
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {Boolean} recognized
           */
          attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          },
          /**
           * Process the input and return the state for the recognizer
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {*} State
           */
          process: function(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
              if (eventType & INPUT_END2) {
                return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
              }
              return state | STATE_CHANGED;
            }
            return STATE_FAILED;
          }
        });
        function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);
          this.pX = null;
          this.pY = null;
        }
        inherit(PanRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof PanRecognizer
           */
          defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
          },
          getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
          },
          directionTest: function(input) {
            var options = this.options;
            var hasMoved = true;
            var distance2 = input.distance;
            var direction = input.direction;
            var x2 = input.deltaX;
            var y2 = input.deltaY;
            if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                direction = x2 === 0 ? DIRECTION_NONE : x2 < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x2 != this.pX;
                distance2 = Math.abs(input.deltaX);
              } else {
                direction = y2 === 0 ? DIRECTION_NONE : y2 < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y2 != this.pY;
                distance2 = Math.abs(input.deltaY);
              }
            }
            input.direction = direction;
            return hasMoved && distance2 > options.threshold && direction & options.direction;
          },
          attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },
          emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
          }
        });
        function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(PinchRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof PinchRecognizer
           */
          defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },
          emit: function(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? "in" : "out";
              input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
          }
        });
        function PressRecognizer() {
          Recognizer.apply(this, arguments);
          this._timer = null;
          this._input = null;
        }
        inherit(PressRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof PressRecognizer
           */
          defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            // minimal time of the pointer to be pressed
            threshold: 9
            // a minimal movement is ok, but keep it low
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START2) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.time, this);
            } else if (input.eventType & INPUT_END2) {
              return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }
            if (input && input.eventType & INPUT_END2) {
              this.manager.emit(this.options.event + "up", input);
            } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(RotateRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof RotateRecognizer
           */
          defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
        });
        function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(SwipeRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof SwipeRecognizer
           */
          defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
          },
          getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          },
          attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
          },
          emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
          }
        });
        function TapRecognizer() {
          Recognizer.apply(this, arguments);
          this.pTime = false;
          this.pCenter = false;
          this._timer = null;
          this._input = null;
          this.count = 0;
        }
        inherit(TapRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof PinchRecognizer
           */
          defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            // max time between the multi-tap taps
            time: 250,
            // max time of the pointer to be down (like finger on the screen)
            threshold: 9,
            // a minimal movement is ok, but keep it low
            posThreshold: 10
            // a multi-tap can be a bit off the initial position
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
          },
          process: function(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if (input.eventType & INPUT_START2 && this.count === 0) {
              return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END2) {
                return this.failTimeout();
              }
              var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;
              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }
              this._input = input;
              var tapCount = this.count % options.taps;
              if (tapCount === 0) {
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                  }, options.interval, this);
                  return STATE_BEGAN;
                }
              }
            }
            return STATE_FAILED;
          },
          failTimeout: function() {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function() {
            if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function Hammer(element, options) {
          options = options || {};
          options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
          return new Manager3(element, options);
        }
        Hammer.VERSION = "2.0.7";
        Hammer.defaults = {
          /**
           * set if DOM events are being triggered.
           * But this is slower and unused by simple implementations, so disabled by default.
           * @type {Boolean}
           * @default false
           */
          domEvents: false,
          /**
           * The value for the touchAction property/fallback.
           * When set to `compute` it will magically set the correct value based on the added recognizers.
           * @type {String}
           * @default compute
           */
          touchAction: TOUCH_ACTION_COMPUTE,
          /**
           * @type {Boolean}
           * @default true
           */
          enable: true,
          /**
           * EXPERIMENTAL FEATURE -- can be removed/changed
           * Change the parent input target element.
           * If Null, then it is being set the to main element.
           * @type {Null|EventTarget}
           * @default null
           */
          inputTarget: null,
          /**
           * force an input class
           * @type {Null|Function}
           * @default null
           */
          inputClass: null,
          /**
           * Default recognizer setup when calling `Hammer()`
           * When creating a new Manager these will be skipped.
           * @type {Array}
           */
          preset: [
            // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
            [RotateRecognizer, { enable: false }],
            [PinchRecognizer, { enable: false }, ["rotate"]],
            [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
            [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
            [TapRecognizer],
            [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
            [PressRecognizer]
          ],
          /**
           * Some CSS properties can be used to improve the working of Hammer.
           * Add them to this method and they will be set when creating a new Manager.
           * @namespace
           */
          cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: "none",
            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: "none",
            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: "none",
            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: "none",
            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: "none",
            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: "rgba(0,0,0,0)"
          }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        function Manager3(element, options) {
          this.options = assign({}, Hammer.defaults, options || {});
          this.options.inputTarget = this.options.inputTarget || element;
          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};
          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);
          toggleCssProps(this, true);
          each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
          }, this);
        }
        Manager3.prototype = {
          /**
           * set options
           * @param {Object} options
           * @returns {Manager}
           */
          set: function(options) {
            assign(this.options, options);
            if (options.touchAction) {
              this.touchAction.update();
            }
            if (options.inputTarget) {
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
            }
            return this;
          },
          /**
           * stop recognizing for this session.
           * This session will be discarded, when a new [input]start event is fired.
           * When forced, the recognizer cycle is stopped immediately.
           * @param {Boolean} [force]
           */
          stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          },
          /**
           * run the recognizers!
           * called by the inputHandler function on every movement of the pointers (touches)
           * it walks through all the recognizers and tries to detect the gesture that is being made
           * @param {Object} inputData
           */
          recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
              return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              curRecognizer = session.curRecognizer = null;
            }
            var i2 = 0;
            while (i2 < recognizers.length) {
              recognizer = recognizers[i2];
              if (session.stopped !== FORCED_STOP && // 1
              (!curRecognizer || recognizer == curRecognizer || // 2
              recognizer.canRecognizeWith(curRecognizer))) {
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              }
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
              }
              i2++;
            }
          },
          /**
           * get a recognizer by its event name.
           * @param {Recognizer|String} recognizer
           * @returns {Recognizer|Null}
           */
          get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i2 = 0; i2 < recognizers.length; i2++) {
              if (recognizers[i2].options.event == recognizer) {
                return recognizers[i2];
              }
            }
            return null;
          },
          /**
           * add a recognizer to the manager
           * existing recognizers with the same event name will be removed
           * @param {Recognizer} recognizer
           * @returns {Recognizer|Manager}
           */
          add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
              return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
              this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          },
          /**
           * remove a recognizer by name or instance
           * @param {Recognizer|String} recognizer
           * @returns {Manager}
           */
          remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
              return this;
            }
            recognizer = this.get(recognizer);
            if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);
              if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
              }
            }
            return this;
          },
          /**
           * bind event
           * @param {String} events
           * @param {Function} handler
           * @returns {EventEmitter} this
           */
          on: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            if (handler === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          },
          /**
           * unbind event, leave emit blank to remove all handlers
           * @param {String} events
           * @param {Function} [handler]
           * @returns {EventEmitter} this
           */
          off: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          },
          /**
           * emit event to the listeners
           * @param {String} event
           * @param {Object} data
           */
          emit: function(event, data) {
            if (this.options.domEvents) {
              triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
              return;
            }
            data.type = event;
            data.preventDefault = function() {
              data.srcEvent.preventDefault();
            };
            var i2 = 0;
            while (i2 < handlers.length) {
              handlers[i2](data);
              i2++;
            }
          },
          /**
           * destroy the manager and unbinds all events
           * it doesn't unbind dom events, that is the user own responsibility
           */
          destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          }
        };
        function toggleCssProps(manager, add3) {
          var element = manager.element;
          if (!element.style) {
            return;
          }
          var prop;
          each(manager.options.cssProps, function(value, name) {
            prop = prefixed(element.style, name);
            if (add3) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || "";
            }
          });
          if (!add3) {
            manager.oldCssProps = {};
          }
        }
        function triggerDomEvent(event, data) {
          var gestureEvent = document2.createEvent("Event");
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
        }
        assign(Hammer, {
          INPUT_START: INPUT_START2,
          INPUT_MOVE: INPUT_MOVE2,
          INPUT_END: INPUT_END2,
          INPUT_CANCEL,
          STATE_POSSIBLE,
          STATE_BEGAN,
          STATE_CHANGED,
          STATE_ENDED,
          STATE_RECOGNIZED,
          STATE_CANCELLED,
          STATE_FAILED,
          DIRECTION_NONE,
          DIRECTION_LEFT,
          DIRECTION_RIGHT,
          DIRECTION_UP,
          DIRECTION_DOWN,
          DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL,
          DIRECTION_ALL,
          Manager: Manager3,
          Input: Input2,
          TouchAction,
          TouchInput,
          MouseInput: MouseInput2,
          PointerEventInput: PointerEventInput2,
          TouchMouseInput,
          SingleTouchInput,
          Recognizer,
          AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,
          on: addEventListeners,
          off: removeEventListeners,
          each,
          merge,
          extend,
          assign,
          inherit,
          bindFn,
          prefixed
        });
        var freeGlobal = typeof window3 !== "undefined" ? window3 : typeof self !== "undefined" ? self : {};
        freeGlobal.Hammer = Hammer;
        if (typeof define === "function" && define.amd) {
          define(function() {
            return Hammer;
          });
        } else if (typeof module != "undefined" && module.exports) {
          module.exports = Hammer;
        } else {
          window3[exportName] = Hammer;
        }
      })(window, document, "Hammer");
    }
  });

  // node_modules/colorbrewer/colorbrewer.js
  var require_colorbrewer = __commonJS({
    "node_modules/colorbrewer/colorbrewer.js"(exports, module) {
      !function() {
        var colorbrewer = { YlGn: {
          3: ["#f7fcb9", "#addd8e", "#31a354"],
          4: ["#ffffcc", "#c2e699", "#78c679", "#238443"],
          5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
          6: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
          7: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
          8: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
          9: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"]
        }, YlGnBu: {
          3: ["#edf8b1", "#7fcdbb", "#2c7fb8"],
          4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
          5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
          6: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
          7: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
          8: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
          9: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]
        }, GnBu: {
          3: ["#e0f3db", "#a8ddb5", "#43a2ca"],
          4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
          5: ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
          6: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"],
          7: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
          8: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
          9: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]
        }, BuGn: {
          3: ["#e5f5f9", "#99d8c9", "#2ca25f"],
          4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
          5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
          6: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"],
          7: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
          8: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
          9: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"]
        }, PuBuGn: {
          3: ["#ece2f0", "#a6bddb", "#1c9099"],
          4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
          5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
          6: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"],
          7: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
          8: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
          9: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"]
        }, PuBu: {
          3: ["#ece7f2", "#a6bddb", "#2b8cbe"],
          4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
          5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
          6: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"],
          7: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
          8: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
          9: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"]
        }, BuPu: {
          3: ["#e0ecf4", "#9ebcda", "#8856a7"],
          4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
          5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
          6: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"],
          7: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
          8: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
          9: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"]
        }, RdPu: {
          3: ["#fde0dd", "#fa9fb5", "#c51b8a"],
          4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
          5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
          6: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
          7: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
          8: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
          9: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"]
        }, PuRd: {
          3: ["#e7e1ef", "#c994c7", "#dd1c77"],
          4: ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"],
          5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
          6: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"],
          7: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
          8: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
          9: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"]
        }, OrRd: {
          3: ["#fee8c8", "#fdbb84", "#e34a33"],
          4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
          5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
          6: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"],
          7: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
          8: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
          9: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]
        }, YlOrRd: {
          3: ["#ffeda0", "#feb24c", "#f03b20"],
          4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
          5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
          6: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
          7: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
          8: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
          9: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"]
        }, YlOrBr: {
          3: ["#fff7bc", "#fec44f", "#d95f0e"],
          4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
          5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
          6: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
          7: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
          8: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
          9: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"]
        }, Purples: {
          3: ["#efedf5", "#bcbddc", "#756bb1"],
          4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
          5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
          6: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
          7: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
          8: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
          9: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"]
        }, Blues: {
          3: ["#deebf7", "#9ecae1", "#3182bd"],
          4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
          5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
          6: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
          7: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
          8: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
          9: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"]
        }, Greens: {
          3: ["#e5f5e0", "#a1d99b", "#31a354"],
          4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
          5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
          6: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
          7: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
          8: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
          9: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"]
        }, Oranges: {
          3: ["#fee6ce", "#fdae6b", "#e6550d"],
          4: ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"],
          5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
          6: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
          7: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
          8: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
          9: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"]
        }, Reds: {
          3: ["#fee0d2", "#fc9272", "#de2d26"],
          4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
          5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
          6: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
          7: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
          8: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
          9: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"]
        }, Greys: {
          3: ["#f0f0f0", "#bdbdbd", "#636363"],
          4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
          5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
          6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
          7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
          8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
          9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]
        }, PuOr: {
          3: ["#f1a340", "#f7f7f7", "#998ec3"],
          4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
          5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
          6: ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"],
          7: ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"],
          8: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
          9: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
          10: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
          11: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"]
        }, BrBG: {
          3: ["#d8b365", "#f5f5f5", "#5ab4ac"],
          4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
          5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
          6: ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"],
          7: ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"],
          8: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
          9: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
          10: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
          11: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"]
        }, PRGn: {
          3: ["#af8dc3", "#f7f7f7", "#7fbf7b"],
          4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
          5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
          6: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"],
          7: ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"],
          8: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
          9: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
          10: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
          11: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"]
        }, PiYG: {
          3: ["#e9a3c9", "#f7f7f7", "#a1d76a"],
          4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
          5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
          6: ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"],
          7: ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"],
          8: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
          9: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
          10: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
          11: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"]
        }, RdBu: {
          3: ["#ef8a62", "#f7f7f7", "#67a9cf"],
          4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
          5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
          6: ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"],
          7: ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"],
          8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
          9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
          10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
          11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"]
        }, RdGy: {
          3: ["#ef8a62", "#ffffff", "#999999"],
          4: ["#ca0020", "#f4a582", "#bababa", "#404040"],
          5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
          6: ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"],
          7: ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"],
          8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
          9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
          10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
          11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"]
        }, RdYlBu: {
          3: ["#fc8d59", "#ffffbf", "#91bfdb"],
          4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
          5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
          6: ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"],
          7: ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"],
          8: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
          9: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
          10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
          11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"]
        }, Spectral: {
          3: ["#fc8d59", "#ffffbf", "#99d594"],
          4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
          5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
          6: ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
          7: ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"],
          8: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
          9: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
          10: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
          11: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"]
        }, RdYlGn: {
          3: ["#fc8d59", "#ffffbf", "#91cf60"],
          4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
          5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
          6: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"],
          7: ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"],
          8: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
          9: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
          10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
          11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]
        }, Accent: {
          3: ["#7fc97f", "#beaed4", "#fdc086"],
          4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
          5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
          6: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"],
          7: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"],
          8: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"]
        }, Dark2: {
          3: ["#1b9e77", "#d95f02", "#7570b3"],
          4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
          5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
          6: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"],
          7: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"],
          8: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"]
        }, Paired: {
          3: ["#a6cee3", "#1f78b4", "#b2df8a"],
          4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
          5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
          6: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"],
          7: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"],
          8: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"],
          9: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"],
          10: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"],
          11: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"],
          12: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"]
        }, Pastel1: {
          3: ["#fbb4ae", "#b3cde3", "#ccebc5"],
          4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
          5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
          6: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"],
          7: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"],
          8: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"],
          9: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
        }, Pastel2: {
          3: ["#b3e2cd", "#fdcdac", "#cbd5e8"],
          4: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"],
          5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
          6: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"],
          7: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"],
          8: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"]
        }, Set1: {
          3: ["#e41a1c", "#377eb8", "#4daf4a"],
          4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
          5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
          6: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"],
          7: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"],
          8: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"],
          9: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]
        }, Set2: {
          3: ["#66c2a5", "#fc8d62", "#8da0cb"],
          4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
          5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
          6: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"],
          7: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"],
          8: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]
        }, Set3: {
          3: ["#8dd3c7", "#ffffb3", "#bebada"],
          4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
          5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
          6: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"],
          7: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"],
          8: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"],
          9: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"],
          10: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"],
          11: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"],
          12: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]
        } };
        if (typeof define === "function" && define.amd) {
          define(colorbrewer);
        } else if (typeof module === "object" && module.exports) {
          module.exports = colorbrewer;
        } else {
          this.colorbrewer = colorbrewer;
        }
      }();
    }
  });

  // node_modules/colorbrewer/index.js
  var require_colorbrewer2 = __commonJS({
    "node_modules/colorbrewer/index.js"(exports, module) {
      module.exports = require_colorbrewer();
    }
  });

  // node_modules/cartocolor/cartocolor.js
  var require_cartocolor = __commonJS({
    "node_modules/cartocolor/cartocolor.js"(exports, module) {
      !function() {
        var cartocolor2 = {
          "Burg": {
            "2": [
              "#ffc6c4",
              "#672044"
            ],
            "3": [
              "#ffc6c4",
              "#cc607d",
              "#672044"
            ],
            "4": [
              "#ffc6c4",
              "#e38191",
              "#ad466c",
              "#672044"
            ],
            "5": [
              "#ffc6c4",
              "#ee919b",
              "#cc607d",
              "#9e3963",
              "#672044"
            ],
            "6": [
              "#ffc6c4",
              "#f29ca3",
              "#da7489",
              "#b95073",
              "#93345d",
              "#672044"
            ],
            "7": [
              "#ffc6c4",
              "#f4a3a8",
              "#e38191",
              "#cc607d",
              "#ad466c",
              "#8b3058",
              "#672044"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "BurgYl": {
            "2": [
              "#fbe6c5",
              "#70284a"
            ],
            "3": [
              "#fbe6c5",
              "#dc7176",
              "#70284a"
            ],
            "4": [
              "#fbe6c5",
              "#ee8a82",
              "#c8586c",
              "#70284a"
            ],
            "5": [
              "#fbe6c5",
              "#f2a28a",
              "#dc7176",
              "#b24b65",
              "#70284a"
            ],
            "6": [
              "#fbe6c5",
              "#f4b191",
              "#e7807d",
              "#d06270",
              "#a44360",
              "#70284a"
            ],
            "7": [
              "#fbe6c5",
              "#f5ba98",
              "#ee8a82",
              "#dc7176",
              "#c8586c",
              "#9c3f5d",
              "#70284a"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "RedOr": {
            "2": [
              "#f6d2a9",
              "#b13f64"
            ],
            "3": [
              "#f6d2a9",
              "#ea8171",
              "#b13f64"
            ],
            "4": [
              "#f6d2a9",
              "#f19c7c",
              "#dd686c",
              "#b13f64"
            ],
            "5": [
              "#f6d2a9",
              "#f3aa84",
              "#ea8171",
              "#d55d6a",
              "#b13f64"
            ],
            "6": [
              "#f6d2a9",
              "#f4b28a",
              "#ef9177",
              "#e3726d",
              "#cf5669",
              "#b13f64"
            ],
            "7": [
              "#f6d2a9",
              "#f5b78e",
              "#f19c7c",
              "#ea8171",
              "#dd686c",
              "#ca5268",
              "#b13f64"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "OrYel": {
            "2": [
              "#ecda9a",
              "#ee4d5a"
            ],
            "3": [
              "#ecda9a",
              "#f7945d",
              "#ee4d5a"
            ],
            "4": [
              "#ecda9a",
              "#f3ad6a",
              "#f97b57",
              "#ee4d5a"
            ],
            "5": [
              "#ecda9a",
              "#f1b973",
              "#f7945d",
              "#f86f56",
              "#ee4d5a"
            ],
            "6": [
              "#ecda9a",
              "#f0c079",
              "#f5a363",
              "#f98558",
              "#f76856",
              "#ee4d5a"
            ],
            "7": [
              "#ecda9a",
              "#efc47e",
              "#f3ad6a",
              "#f7945d",
              "#f97b57",
              "#f66356",
              "#ee4d5a"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "Peach": {
            "2": [
              "#fde0c5",
              "#eb4a40"
            ],
            "3": [
              "#fde0c5",
              "#f59e72",
              "#eb4a40"
            ],
            "4": [
              "#fde0c5",
              "#f8b58b",
              "#f2855d",
              "#eb4a40"
            ],
            "5": [
              "#fde0c5",
              "#f9c098",
              "#f59e72",
              "#f17854",
              "#eb4a40"
            ],
            "6": [
              "#fde0c5",
              "#fac7a1",
              "#f7ac80",
              "#f38f65",
              "#f0704f",
              "#eb4a40"
            ],
            "7": [
              "#fde0c5",
              "#facba6",
              "#f8b58b",
              "#f59e72",
              "#f2855d",
              "#ef6a4c",
              "#eb4a40"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "PinkYl": {
            "2": [
              "#fef6b5",
              "#e15383"
            ],
            "3": [
              "#fef6b5",
              "#ffa679",
              "#e15383"
            ],
            "4": [
              "#fef6b5",
              "#ffc285",
              "#fa8a76",
              "#e15383"
            ],
            "5": [
              "#fef6b5",
              "#ffd08e",
              "#ffa679",
              "#f67b77",
              "#e15383"
            ],
            "6": [
              "#fef6b5",
              "#ffd795",
              "#ffb77f",
              "#fd9576",
              "#f37378",
              "#e15383"
            ],
            "7": [
              "#fef6b5",
              "#ffdd9a",
              "#ffc285",
              "#ffa679",
              "#fa8a76",
              "#f16d7a",
              "#e15383"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "Mint": {
            "2": [
              "#e4f1e1",
              "#0d585f"
            ],
            "3": [
              "#e4f1e1",
              "#63a6a0",
              "#0d585f"
            ],
            "4": [
              "#e4f1e1",
              "#89c0b6",
              "#448c8a",
              "#0d585f"
            ],
            "5": [
              "#E4F1E1",
              "#9CCDC1",
              "#63A6A0",
              "#337F7F",
              "#0D585F"
            ],
            "6": [
              "#e4f1e1",
              "#abd4c7",
              "#7ab5ad",
              "#509693",
              "#2c7778",
              "#0d585f"
            ],
            "7": [
              "#e4f1e1",
              "#b4d9cc",
              "#89c0b6",
              "#63a6a0",
              "#448c8a",
              "#287274",
              "#0d585f"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "BluGrn": {
            "2": [
              "#c4e6c3",
              "#1d4f60"
            ],
            "3": [
              "#c4e6c3",
              "#4da284",
              "#1d4f60"
            ],
            "4": [
              "#c4e6c3",
              "#6dbc90",
              "#36877a",
              "#1d4f60"
            ],
            "5": [
              "#c4e6c3",
              "#80c799",
              "#4da284",
              "#2d7974",
              "#1d4f60"
            ],
            "6": [
              "#c4e6c3",
              "#8dce9f",
              "#5fb28b",
              "#3e927e",
              "#297071",
              "#1d4f60"
            ],
            "7": [
              "#c4e6c3",
              "#96d2a4",
              "#6dbc90",
              "#4da284",
              "#36877a",
              "#266b6e",
              "#1d4f60"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "DarkMint": {
            "2": [
              "#d2fbd4",
              "#123f5a"
            ],
            "3": [
              "#d2fbd4",
              "#559c9e",
              "#123f5a"
            ],
            "4": [
              "#d2fbd4",
              "#7bbcb0",
              "#3a7c89",
              "#123f5a"
            ],
            "5": [
              "#d2fbd4",
              "#8eccb9",
              "#559c9e",
              "#2b6c7f",
              "#123f5a"
            ],
            "6": [
              "#d2fbd4",
              "#9cd5be",
              "#6cafa9",
              "#458892",
              "#266377",
              "#123f5a"
            ],
            "7": [
              "#d2fbd4",
              "#a5dbc2",
              "#7bbcb0",
              "#559c9e",
              "#3a7c89",
              "#235d72",
              "#123f5a"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "Emrld": {
            "2": [
              "#d3f2a3",
              "#074050"
            ],
            "3": [
              "#d3f2a3",
              "#4c9b82",
              "#074050"
            ],
            "4": [
              "#d3f2a3",
              "#6cc08b",
              "#217a79",
              "#074050"
            ],
            "5": [
              "#d3f2a3",
              "#82d091",
              "#4c9b82",
              "#19696f",
              "#074050"
            ],
            "6": [
              "#d3f2a3",
              "#8fda94",
              "#60b187",
              "#35877d",
              "#145f69",
              "#074050"
            ],
            "7": [
              "#d3f2a3",
              "#97e196",
              "#6cc08b",
              "#4c9b82",
              "#217a79",
              "#105965",
              "#074050"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "ag_GrnYl": {
            "2": [
              "#245668",
              "#EDEF5D"
            ],
            "3": [
              "#245668",
              "#39AB7E",
              "#EDEF5D"
            ],
            "4": [
              "#245668",
              "#0D8F81",
              "#6EC574",
              "#EDEF5D"
            ],
            "5": [
              "#245668",
              "#04817E",
              "#39AB7E",
              "#8BD16D",
              "#EDEF5D"
            ],
            "6": [
              "#245668",
              "#09787C",
              "#1D9A81",
              "#58BB79",
              "#9DD869",
              "#EDEF5D"
            ],
            "7": [
              "#245668",
              "#0F7279",
              "#0D8F81",
              "#39AB7E",
              "#6EC574",
              "#A9DC67",
              "#EDEF5D"
            ],
            "tags": [
              "aggregation"
            ]
          },
          "BluYl": {
            "2": [
              "#f7feae",
              "#045275"
            ],
            "3": [
              "#f7feae",
              "#46aea0",
              "#045275"
            ],
            "4": [
              "#f7feae",
              "#7ccba2",
              "#089099",
              "#045275"
            ],
            "5": [
              "#f7feae",
              "#9bd8a4",
              "#46aea0",
              "#058092",
              "#045275"
            ],
            "6": [
              "#f7feae",
              "#ace1a4",
              "#68bfa1",
              "#2a9c9c",
              "#02778e",
              "#045275"
            ],
            "7": [
              "#f7feae",
              "#b7e6a5",
              "#7ccba2",
              "#46aea0",
              "#089099",
              "#00718b",
              "#045275"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "Teal": {
            "2": [
              "#d1eeea",
              "#2a5674"
            ],
            "3": [
              "#d1eeea",
              "#68abb8",
              "#2a5674"
            ],
            "4": [
              "#d1eeea",
              "#85c4c9",
              "#4f90a6",
              "#2a5674"
            ],
            "5": [
              "#d1eeea",
              "#96d0d1",
              "#68abb8",
              "#45829b",
              "#2a5674"
            ],
            "6": [
              "#d1eeea",
              "#a1d7d6",
              "#79bbc3",
              "#599bae",
              "#3f7994",
              "#2a5674"
            ],
            "7": [
              "#d1eeea",
              "#a8dbd9",
              "#85c4c9",
              "#68abb8",
              "#4f90a6",
              "#3b738f",
              "#2a5674"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "TealGrn": {
            "2": [
              "#b0f2bc",
              "#257d98"
            ],
            "3": [
              "#b0f2bc",
              "#4cc8a3",
              "#257d98"
            ],
            "4": [
              "#b0f2bc",
              "#67dba5",
              "#38b2a3",
              "#257d98"
            ],
            "5": [
              "#b0f2bc",
              "#77e2a8",
              "#4cc8a3",
              "#31a6a2",
              "#257d98"
            ],
            "6": [
              "#b0f2bc",
              "#82e6aa",
              "#5bd4a4",
              "#3fbba3",
              "#2e9ea1",
              "#257d98"
            ],
            "7": [
              "#b0f2bc",
              "#89e8ac",
              "#67dba5",
              "#4cc8a3",
              "#38b2a3",
              "#2c98a0",
              "#257d98"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "Purp": {
            "2": [
              "#f3e0f7",
              "#63589f"
            ],
            "3": [
              "#f3e0f7",
              "#b998dd",
              "#63589f"
            ],
            "4": [
              "#f3e0f7",
              "#d1afe8",
              "#9f82ce",
              "#63589f"
            ],
            "5": [
              "#f3e0f7",
              "#dbbaed",
              "#b998dd",
              "#9178c4",
              "#63589f"
            ],
            "6": [
              "#f3e0f7",
              "#e0c2ef",
              "#c8a5e4",
              "#aa8bd4",
              "#8871be",
              "#63589f"
            ],
            "7": [
              "#f3e0f7",
              "#e4c7f1",
              "#d1afe8",
              "#b998dd",
              "#9f82ce",
              "#826dba",
              "#63589f"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "PurpOr": {
            "2": [
              "#f9ddda",
              "#573b88"
            ],
            "3": [
              "#f9ddda",
              "#ce78b3",
              "#573b88"
            ],
            "4": [
              "#f9ddda",
              "#e597b9",
              "#ad5fad",
              "#573b88"
            ],
            "5": [
              "#f9ddda",
              "#eda8bd",
              "#ce78b3",
              "#9955a8",
              "#573b88"
            ],
            "6": [
              "#f9ddda",
              "#f0b2c1",
              "#dd8ab6",
              "#bb69b0",
              "#8c4fa4",
              "#573b88"
            ],
            "7": [
              "#f9ddda",
              "#f2b9c4",
              "#e597b9",
              "#ce78b3",
              "#ad5fad",
              "#834ba0",
              "#573b88"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "Sunset": {
            "2": [
              "#f3e79b",
              "#5c53a5"
            ],
            "3": [
              "#f3e79b",
              "#eb7f86",
              "#5c53a5"
            ],
            "4": [
              "#f3e79b",
              "#f8a07e",
              "#ce6693",
              "#5c53a5"
            ],
            "5": [
              "#f3e79b",
              "#fab27f",
              "#eb7f86",
              "#b95e9a",
              "#5c53a5"
            ],
            "6": [
              "#f3e79b",
              "#fabc82",
              "#f59280",
              "#dc6f8e",
              "#ab5b9e",
              "#5c53a5"
            ],
            "7": [
              "#f3e79b",
              "#fac484",
              "#f8a07e",
              "#eb7f86",
              "#ce6693",
              "#a059a0",
              "#5c53a5"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "Magenta": {
            "2": [
              "#f3cbd3",
              "#6c2167"
            ],
            "3": [
              "#f3cbd3",
              "#ca699d",
              "#6c2167"
            ],
            "4": [
              "#f3cbd3",
              "#dd88ac",
              "#b14d8e",
              "#6c2167"
            ],
            "5": [
              "#f3cbd3",
              "#e498b4",
              "#ca699d",
              "#a24186",
              "#6c2167"
            ],
            "6": [
              "#f3cbd3",
              "#e7a2b9",
              "#d67ba5",
              "#bc5894",
              "#983a81",
              "#6c2167"
            ],
            "7": [
              "#f3cbd3",
              "#eaa9bd",
              "#dd88ac",
              "#ca699d",
              "#b14d8e",
              "#91357d",
              "#6c2167"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "SunsetDark": {
            "2": [
              "#fcde9c",
              "#7c1d6f"
            ],
            "3": [
              "#fcde9c",
              "#e34f6f",
              "#7c1d6f"
            ],
            "4": [
              "#fcde9c",
              "#f0746e",
              "#dc3977",
              "#7c1d6f"
            ],
            "5": [
              "#fcde9c",
              "#f58670",
              "#e34f6f",
              "#d72d7c",
              "#7c1d6f"
            ],
            "6": [
              "#fcde9c",
              "#f89872",
              "#ec666d",
              "#df4273",
              "#c5287b",
              "#7c1d6f"
            ],
            "7": [
              "#fcde9c",
              "#faa476",
              "#f0746e",
              "#e34f6f",
              "#dc3977",
              "#b9257a",
              "#7c1d6f"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "ag_Sunset": {
            "2": [
              "#4b2991",
              "#edd9a3"
            ],
            "3": [
              "#4b2991",
              "#ea4f88",
              "#edd9a3"
            ],
            "4": [
              "#4b2991",
              "#c0369d",
              "#fa7876",
              "#edd9a3"
            ],
            "5": [
              "#4b2991",
              "#a52fa2",
              "#ea4f88",
              "#fa9074",
              "#edd9a3"
            ],
            "6": [
              "#4b2991",
              "#932da3",
              "#d43f96",
              "#f7667c",
              "#f89f77",
              "#edd9a3"
            ],
            "7": [
              "#4b2991",
              "#872ca2",
              "#c0369d",
              "#ea4f88",
              "#fa7876",
              "#f6a97a",
              "#edd9a3"
            ],
            "tags": [
              "aggregation"
            ]
          },
          "BrwnYl": {
            "2": [
              "#ede5cf",
              "#541f3f"
            ],
            "3": [
              "#ede5cf",
              "#c1766f",
              "#541f3f"
            ],
            "4": [
              "#ede5cf",
              "#d39c83",
              "#a65461",
              "#541f3f"
            ],
            "5": [
              "#ede5cf",
              "#daaf91",
              "#c1766f",
              "#95455a",
              "#541f3f"
            ],
            "6": [
              "#ede5cf",
              "#ddba9b",
              "#cd8c7a",
              "#b26166",
              "#8a3c56",
              "#541f3f"
            ],
            "7": [
              "#ede5cf",
              "#e0c2a2",
              "#d39c83",
              "#c1766f",
              "#a65461",
              "#813753",
              "#541f3f"
            ],
            "tags": [
              "quantitative"
            ]
          },
          "ArmyRose": {
            "2": [
              "#929b4f",
              "#db8195"
            ],
            "3": [
              "#a3ad62",
              "#fdfbe4",
              "#df91a3"
            ],
            "4": [
              "#929b4f",
              "#d9dbaf",
              "#f3d1ca",
              "#db8195"
            ],
            "5": [
              "#879043",
              "#c1c68c",
              "#fdfbe4",
              "#ebb4b8",
              "#d8758b"
            ],
            "6": [
              "#7f883b",
              "#b0b874",
              "#e3e4be",
              "#f6ddd1",
              "#e4a0ac",
              "#d66d85"
            ],
            "7": [
              "#798234",
              "#a3ad62",
              "#d0d3a2",
              "#fdfbe4",
              "#f0c6c3",
              "#df91a3",
              "#d46780"
            ],
            "tags": [
              "diverging"
            ]
          },
          "Fall": {
            "2": [
              "#3d5941",
              "#ca562c"
            ],
            "3": [
              "#3d5941",
              "#f6edbd",
              "#ca562c"
            ],
            "4": [
              "#3d5941",
              "#b5b991",
              "#edbb8a",
              "#ca562c"
            ],
            "5": [
              "#3d5941",
              "#96a07c",
              "#f6edbd",
              "#e6a272",
              "#ca562c"
            ],
            "6": [
              "#3d5941",
              "#839170",
              "#cecea2",
              "#f1cf9e",
              "#e19464",
              "#ca562c"
            ],
            "7": [
              "#3d5941",
              "#778868",
              "#b5b991",
              "#f6edbd",
              "#edbb8a",
              "#de8a5a",
              "#ca562c"
            ],
            "tags": [
              "diverging"
            ]
          },
          "Geyser": {
            "2": [
              "#008080",
              "#ca562c"
            ],
            "3": [
              "#008080",
              "#f6edbd",
              "#ca562c"
            ],
            "4": [
              "#008080",
              "#b4c8a8",
              "#edbb8a",
              "#ca562c"
            ],
            "5": [
              "#008080",
              "#92b69e",
              "#f6edbd",
              "#e6a272",
              "#ca562c"
            ],
            "6": [
              "#008080",
              "#7eab98",
              "#ced7b1",
              "#f1cf9e",
              "#e19464",
              "#ca562c"
            ],
            "7": [
              "#008080",
              "#70a494",
              "#b4c8a8",
              "#f6edbd",
              "#edbb8a",
              "#de8a5a",
              "#ca562c"
            ],
            "tags": [
              "diverging"
            ]
          },
          "Temps": {
            "2": [
              "#009392",
              "#cf597e"
            ],
            "3": [
              "#009392",
              "#e9e29c",
              "#cf597e"
            ],
            "4": [
              "#009392",
              "#9ccb86",
              "#eeb479",
              "#cf597e"
            ],
            "5": [
              "#009392",
              "#71be83",
              "#e9e29c",
              "#ed9c72",
              "#cf597e"
            ],
            "6": [
              "#009392",
              "#52b684",
              "#bcd48c",
              "#edc783",
              "#eb8d71",
              "#cf597e"
            ],
            "7": [
              "#009392",
              "#39b185",
              "#9ccb86",
              "#e9e29c",
              "#eeb479",
              "#e88471",
              "#cf597e"
            ],
            "tags": [
              "diverging"
            ]
          },
          "TealRose": {
            "2": [
              "#009392",
              "#d0587e"
            ],
            "3": [
              "#009392",
              "#f1eac8",
              "#d0587e"
            ],
            "4": [
              "#009392",
              "#91b8aa",
              "#f1eac8",
              "#dfa0a0",
              "#d0587e"
            ],
            "5": [
              "#009392",
              "#91b8aa",
              "#f1eac8",
              "#dfa0a0",
              "#d0587e"
            ],
            "6": [
              "#009392",
              "#72aaa1",
              "#b1c7b3",
              "#e5b9ad",
              "#d98994",
              "#d0587e"
            ],
            "7": [
              "#009392",
              "#72aaa1",
              "#b1c7b3",
              "#f1eac8",
              "#e5b9ad",
              "#d98994",
              "#d0587e"
            ],
            "tags": [
              "diverging"
            ]
          },
          "Tropic": {
            "2": [
              "#009B9E",
              "#C75DAB"
            ],
            "3": [
              "#009B9E",
              "#F1F1F1",
              "#C75DAB"
            ],
            "4": [
              "#009B9E",
              "#A7D3D4",
              "#E4C1D9",
              "#C75DAB"
            ],
            "5": [
              "#009B9E",
              "#7CC5C6",
              "#F1F1F1",
              "#DDA9CD",
              "#C75DAB"
            ],
            "6": [
              "#009B9E",
              "#5DBCBE",
              "#C6DFDF",
              "#E9D4E2",
              "#D99BC6",
              "#C75DAB"
            ],
            "7": [
              "#009B9E",
              "#42B7B9",
              "#A7D3D4",
              "#F1F1F1",
              "#E4C1D9",
              "#D691C1",
              "#C75DAB"
            ],
            "tags": [
              "diverging"
            ]
          },
          "Earth": {
            "2": [
              "#A16928",
              "#2887a1"
            ],
            "3": [
              "#A16928",
              "#edeac2",
              "#2887a1"
            ],
            "4": [
              "#A16928",
              "#d6bd8d",
              "#b5c8b8",
              "#2887a1"
            ],
            "5": [
              "#A16928",
              "#caa873",
              "#edeac2",
              "#98b7b2",
              "#2887a1"
            ],
            "6": [
              "#A16928",
              "#c29b64",
              "#e0cfa2",
              "#cbd5bc",
              "#85adaf",
              "#2887a1"
            ],
            "7": [
              "#A16928",
              "#bd925a",
              "#d6bd8d",
              "#edeac2",
              "#b5c8b8",
              "#79a7ac",
              "#2887a1"
            ],
            "tags": [
              "diverging"
            ]
          },
          "Antique": {
            "2": [
              "#855C75",
              "#D9AF6B",
              "#7C7C7C"
            ],
            "3": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#7C7C7C"
            ],
            "4": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#736F4C",
              "#7C7C7C"
            ],
            "5": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#736F4C",
              "#526A83",
              "#7C7C7C"
            ],
            "6": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#736F4C",
              "#526A83",
              "#625377",
              "#7C7C7C"
            ],
            "7": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#736F4C",
              "#526A83",
              "#625377",
              "#68855C",
              "#7C7C7C"
            ],
            "8": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#736F4C",
              "#526A83",
              "#625377",
              "#68855C",
              "#9C9C5E",
              "#7C7C7C"
            ],
            "9": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#736F4C",
              "#526A83",
              "#625377",
              "#68855C",
              "#9C9C5E",
              "#A06177",
              "#7C7C7C"
            ],
            "10": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#736F4C",
              "#526A83",
              "#625377",
              "#68855C",
              "#9C9C5E",
              "#A06177",
              "#8C785D",
              "#7C7C7C"
            ],
            "11": [
              "#855C75",
              "#D9AF6B",
              "#AF6458",
              "#736F4C",
              "#526A83",
              "#625377",
              "#68855C",
              "#9C9C5E",
              "#A06177",
              "#8C785D",
              "#467378",
              "#7C7C7C"
            ],
            "tags": [
              "qualitative"
            ]
          },
          "Bold": {
            "2": [
              "#7F3C8D",
              "#11A579",
              "#A5AA99"
            ],
            "3": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#A5AA99"
            ],
            "4": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#F2B701",
              "#A5AA99"
            ],
            "5": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#F2B701",
              "#E73F74",
              "#A5AA99"
            ],
            "6": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#F2B701",
              "#E73F74",
              "#80BA5A",
              "#A5AA99"
            ],
            "7": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#F2B701",
              "#E73F74",
              "#80BA5A",
              "#E68310",
              "#A5AA99"
            ],
            "8": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#F2B701",
              "#E73F74",
              "#80BA5A",
              "#E68310",
              "#008695",
              "#A5AA99"
            ],
            "9": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#F2B701",
              "#E73F74",
              "#80BA5A",
              "#E68310",
              "#008695",
              "#CF1C90",
              "#A5AA99"
            ],
            "10": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#F2B701",
              "#E73F74",
              "#80BA5A",
              "#E68310",
              "#008695",
              "#CF1C90",
              "#f97b72",
              "#A5AA99"
            ],
            "11": [
              "#7F3C8D",
              "#11A579",
              "#3969AC",
              "#F2B701",
              "#E73F74",
              "#80BA5A",
              "#E68310",
              "#008695",
              "#CF1C90",
              "#f97b72",
              "#4b4b8f",
              "#A5AA99"
            ],
            "tags": [
              "qualitative"
            ]
          },
          "Pastel": {
            "2": [
              "#66C5CC",
              "#F6CF71",
              "#B3B3B3"
            ],
            "3": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#B3B3B3"
            ],
            "4": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#DCB0F2",
              "#B3B3B3"
            ],
            "5": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#DCB0F2",
              "#87C55F",
              "#B3B3B3"
            ],
            "6": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#DCB0F2",
              "#87C55F",
              "#9EB9F3",
              "#B3B3B3"
            ],
            "7": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#DCB0F2",
              "#87C55F",
              "#9EB9F3",
              "#FE88B1",
              "#B3B3B3"
            ],
            "8": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#DCB0F2",
              "#87C55F",
              "#9EB9F3",
              "#FE88B1",
              "#C9DB74",
              "#B3B3B3"
            ],
            "9": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#DCB0F2",
              "#87C55F",
              "#9EB9F3",
              "#FE88B1",
              "#C9DB74",
              "#8BE0A4",
              "#B3B3B3"
            ],
            "10": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#DCB0F2",
              "#87C55F",
              "#9EB9F3",
              "#FE88B1",
              "#C9DB74",
              "#8BE0A4",
              "#B497E7",
              "#B3B3B3"
            ],
            "11": [
              "#66C5CC",
              "#F6CF71",
              "#F89C74",
              "#DCB0F2",
              "#87C55F",
              "#9EB9F3",
              "#FE88B1",
              "#C9DB74",
              "#8BE0A4",
              "#B497E7",
              "#D3B484",
              "#B3B3B3"
            ],
            "tags": [
              "qualitative"
            ]
          },
          "Prism": {
            "2": [
              "#5F4690",
              "#1D6996",
              "#666666"
            ],
            "3": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#666666"
            ],
            "4": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#0F8554",
              "#666666"
            ],
            "5": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#0F8554",
              "#73AF48",
              "#666666"
            ],
            "6": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#0F8554",
              "#73AF48",
              "#EDAD08",
              "#666666"
            ],
            "7": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#0F8554",
              "#73AF48",
              "#EDAD08",
              "#E17C05",
              "#666666"
            ],
            "8": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#0F8554",
              "#73AF48",
              "#EDAD08",
              "#E17C05",
              "#CC503E",
              "#666666"
            ],
            "9": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#0F8554",
              "#73AF48",
              "#EDAD08",
              "#E17C05",
              "#CC503E",
              "#94346E",
              "#666666"
            ],
            "10": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#0F8554",
              "#73AF48",
              "#EDAD08",
              "#E17C05",
              "#CC503E",
              "#94346E",
              "#6F4070",
              "#666666"
            ],
            "11": [
              "#5F4690",
              "#1D6996",
              "#38A6A5",
              "#0F8554",
              "#73AF48",
              "#EDAD08",
              "#E17C05",
              "#CC503E",
              "#94346E",
              "#6F4070",
              "#994E95",
              "#666666"
            ],
            "tags": [
              "qualitative"
            ]
          },
          "Safe": {
            "2": [
              "#88CCEE",
              "#CC6677",
              "#888888"
            ],
            "3": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#888888"
            ],
            "4": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#117733",
              "#888888"
            ],
            "5": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#117733",
              "#332288",
              "#888888"
            ],
            "6": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#117733",
              "#332288",
              "#AA4499",
              "#888888"
            ],
            "7": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#117733",
              "#332288",
              "#AA4499",
              "#44AA99",
              "#888888"
            ],
            "8": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#117733",
              "#332288",
              "#AA4499",
              "#44AA99",
              "#999933",
              "#888888"
            ],
            "9": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#117733",
              "#332288",
              "#AA4499",
              "#44AA99",
              "#999933",
              "#882255",
              "#888888"
            ],
            "10": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#117733",
              "#332288",
              "#AA4499",
              "#44AA99",
              "#999933",
              "#882255",
              "#661100",
              "#888888"
            ],
            "11": [
              "#88CCEE",
              "#CC6677",
              "#DDCC77",
              "#117733",
              "#332288",
              "#AA4499",
              "#44AA99",
              "#999933",
              "#882255",
              "#661100",
              "#6699CC",
              "#888888"
            ],
            "tags": [
              "qualitative",
              "colorblind"
            ]
          },
          "Vivid": {
            "2": [
              "#E58606",
              "#5D69B1",
              "#A5AA99"
            ],
            "3": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#A5AA99"
            ],
            "4": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#99C945",
              "#A5AA99"
            ],
            "5": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#99C945",
              "#CC61B0",
              "#A5AA99"
            ],
            "6": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#99C945",
              "#CC61B0",
              "#24796C",
              "#A5AA99"
            ],
            "7": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#99C945",
              "#CC61B0",
              "#24796C",
              "#DAA51B",
              "#A5AA99"
            ],
            "8": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#99C945",
              "#CC61B0",
              "#24796C",
              "#DAA51B",
              "#2F8AC4",
              "#A5AA99"
            ],
            "9": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#99C945",
              "#CC61B0",
              "#24796C",
              "#DAA51B",
              "#2F8AC4",
              "#764E9F",
              "#A5AA99"
            ],
            "10": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#99C945",
              "#CC61B0",
              "#24796C",
              "#DAA51B",
              "#2F8AC4",
              "#764E9F",
              "#ED645A",
              "#A5AA99"
            ],
            "11": [
              "#E58606",
              "#5D69B1",
              "#52BCA3",
              "#99C945",
              "#CC61B0",
              "#24796C",
              "#DAA51B",
              "#2F8AC4",
              "#764E9F",
              "#ED645A",
              "#CC3A8E",
              "#A5AA99"
            ],
            "tags": [
              "qualitative"
            ]
          }
        };
        var colorbrewer_tags = {
          "Blues": { "tags": ["quantitative"] },
          "BrBG": { "tags": ["diverging"] },
          "Greys": { "tags": ["quantitative"] },
          "PiYG": { "tags": ["diverging"] },
          "PRGn": { "tags": ["diverging"] },
          "Purples": { "tags": ["quantitative"] },
          "RdYlGn": { "tags": ["diverging"] },
          "Spectral": { "tags": ["diverging"] },
          "YlOrBr": { "tags": ["quantitative"] },
          "YlGn": { "tags": ["quantitative"] },
          "YlGnBu": { "tags": ["quantitative"] },
          "YlOrRd": { "tags": ["quantitative"] }
        };
        var colorbrewer = require_colorbrewer2();
        for (var r2 in colorbrewer) {
          var ramps = colorbrewer[r2];
          var augmentedRamps = {};
          for (var i2 in ramps) {
            augmentedRamps[i2] = ramps[i2];
          }
          if (r2 in colorbrewer_tags) {
            augmentedRamps.tags = colorbrewer_tags[r2].tags;
          }
          cartocolor2["cb_" + r2] = augmentedRamps;
        }
        if (typeof define === "function" && define.amd) {
          define(cartocolor2);
        } else if (typeof module === "object" && module.exports) {
          module.exports = cartocolor2;
        } else {
          this.colorbrewer = cartocolor2;
        }
      }();
    }
  });

  // node_modules/cartocolor/index.js
  var require_cartocolor2 = __commonJS({
    "node_modules/cartocolor/index.js"(exports, module) {
      module.exports = require_cartocolor();
    }
  });

  // node_modules/papaparse/papaparse.min.js
  var require_papaparse_min = __commonJS({
    "node_modules/papaparse/papaparse.min.js"(exports, module) {
      !function(e2, t2) {
        "function" == typeof define && define.amd ? define([], t2) : "object" == typeof module && "undefined" != typeof exports ? module.exports = t2() : e2.Papa = t2();
      }(exports, function s() {
        "use strict";
        var f2 = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f2 ? f2 : {};
        var n2 = !f2.document && !!f2.postMessage, o2 = f2.IS_PAPA_WORKER || false, a2 = {}, u2 = 0, b2 = { parse: function(e2, t2) {
          var r3 = (t2 = t2 || {}).dynamicTyping || false;
          J(r3) && (t2.dynamicTypingFunction = r3, r3 = {});
          if (t2.dynamicTyping = r3, t2.transform = !!J(t2.transform) && t2.transform, t2.worker && b2.WORKERS_SUPPORTED) {
            var i2 = function() {
              if (!b2.WORKERS_SUPPORTED)
                return false;
              var e3 = (r4 = f2.URL || f2.webkitURL || null, i3 = s.toString(), b2.BLOB_URL || (b2.BLOB_URL = r4.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i3, ")();"], { type: "text/javascript" })))), t3 = new f2.Worker(e3);
              var r4, i3;
              return t3.onmessage = _2, t3.id = u2++, a2[t3.id] = t3;
            }();
            return i2.userStep = t2.step, i2.userChunk = t2.chunk, i2.userComplete = t2.complete, i2.userError = t2.error, t2.step = J(t2.step), t2.chunk = J(t2.chunk), t2.complete = J(t2.complete), t2.error = J(t2.error), delete t2.worker, void i2.postMessage({ input: e2, config: t2, workerId: i2.id });
          }
          var n3 = null;
          b2.NODE_STREAM_INPUT, "string" == typeof e2 ? (e2 = function(e3) {
            if (65279 === e3.charCodeAt(0))
              return e3.slice(1);
            return e3;
          }(e2), n3 = t2.download ? new l2(t2) : new p2(t2)) : true === e2.readable && J(e2.read) && J(e2.on) ? n3 = new g2(t2) : (f2.File && e2 instanceof File || e2 instanceof Object) && (n3 = new c2(t2));
          return n3.stream(e2);
        }, unparse: function(e2, t2) {
          var n3 = false, _3 = true, m2 = ",", y3 = "\r\n", s2 = '"', a3 = s2 + s2, r3 = false, i2 = null, o3 = false;
          !function() {
            if ("object" != typeof t2)
              return;
            "string" != typeof t2.delimiter || b2.BAD_DELIMITERS.filter(function(e3) {
              return -1 !== t2.delimiter.indexOf(e3);
            }).length || (m2 = t2.delimiter);
            ("boolean" == typeof t2.quotes || "function" == typeof t2.quotes || Array.isArray(t2.quotes)) && (n3 = t2.quotes);
            "boolean" != typeof t2.skipEmptyLines && "string" != typeof t2.skipEmptyLines || (r3 = t2.skipEmptyLines);
            "string" == typeof t2.newline && (y3 = t2.newline);
            "string" == typeof t2.quoteChar && (s2 = t2.quoteChar);
            "boolean" == typeof t2.header && (_3 = t2.header);
            if (Array.isArray(t2.columns)) {
              if (0 === t2.columns.length)
                throw new Error("Option columns is empty");
              i2 = t2.columns;
            }
            void 0 !== t2.escapeChar && (a3 = t2.escapeChar + s2);
            ("boolean" == typeof t2.escapeFormulae || t2.escapeFormulae instanceof RegExp) && (o3 = t2.escapeFormulae instanceof RegExp ? t2.escapeFormulae : /^[=+\-@\t\r].*$/);
          }();
          var u3 = new RegExp(Q(s2), "g");
          "string" == typeof e2 && (e2 = JSON.parse(e2));
          if (Array.isArray(e2)) {
            if (!e2.length || Array.isArray(e2[0]))
              return h2(null, e2, r3);
            if ("object" == typeof e2[0])
              return h2(i2 || Object.keys(e2[0]), e2, r3);
          } else if ("object" == typeof e2)
            return "string" == typeof e2.data && (e2.data = JSON.parse(e2.data)), Array.isArray(e2.data) && (e2.fields || (e2.fields = e2.meta && e2.meta.fields || i2), e2.fields || (e2.fields = Array.isArray(e2.data[0]) ? e2.fields : "object" == typeof e2.data[0] ? Object.keys(e2.data[0]) : []), Array.isArray(e2.data[0]) || "object" == typeof e2.data[0] || (e2.data = [e2.data])), h2(e2.fields || [], e2.data || [], r3);
          throw new Error("Unable to serialize unrecognized input");
          function h2(e3, t3, r4) {
            var i3 = "";
            "string" == typeof e3 && (e3 = JSON.parse(e3)), "string" == typeof t3 && (t3 = JSON.parse(t3));
            var n4 = Array.isArray(e3) && 0 < e3.length, s3 = !Array.isArray(t3[0]);
            if (n4 && _3) {
              for (var a4 = 0; a4 < e3.length; a4++)
                0 < a4 && (i3 += m2), i3 += v3(e3[a4], a4);
              0 < t3.length && (i3 += y3);
            }
            for (var o4 = 0; o4 < t3.length; o4++) {
              var u4 = n4 ? e3.length : t3[o4].length, h3 = false, f3 = n4 ? 0 === Object.keys(t3[o4]).length : 0 === t3[o4].length;
              if (r4 && !n4 && (h3 = "greedy" === r4 ? "" === t3[o4].join("").trim() : 1 === t3[o4].length && 0 === t3[o4][0].length), "greedy" === r4 && n4) {
                for (var d3 = [], l3 = 0; l3 < u4; l3++) {
                  var c3 = s3 ? e3[l3] : l3;
                  d3.push(t3[o4][c3]);
                }
                h3 = "" === d3.join("").trim();
              }
              if (!h3) {
                for (var p3 = 0; p3 < u4; p3++) {
                  0 < p3 && !f3 && (i3 += m2);
                  var g3 = n4 && s3 ? e3[p3] : p3;
                  i3 += v3(t3[o4][g3], p3);
                }
                o4 < t3.length - 1 && (!r4 || 0 < u4 && !f3) && (i3 += y3);
              }
            }
            return i3;
          }
          function v3(e3, t3) {
            if (null == e3)
              return "";
            if (e3.constructor === Date)
              return JSON.stringify(e3).slice(1, 25);
            var r4 = false;
            o3 && "string" == typeof e3 && o3.test(e3) && (e3 = "'" + e3, r4 = true);
            var i3 = e3.toString().replace(u3, a3);
            return (r4 = r4 || true === n3 || "function" == typeof n3 && n3(e3, t3) || Array.isArray(n3) && n3[t3] || function(e4, t4) {
              for (var r5 = 0; r5 < t4.length; r5++)
                if (-1 < e4.indexOf(t4[r5]))
                  return true;
              return false;
            }(i3, b2.BAD_DELIMITERS) || -1 < i3.indexOf(m2) || " " === i3.charAt(0) || " " === i3.charAt(i3.length - 1)) ? s2 + i3 + s2 : i3;
          }
        } };
        if (b2.RECORD_SEP = String.fromCharCode(30), b2.UNIT_SEP = String.fromCharCode(31), b2.BYTE_ORDER_MARK = "\uFEFF", b2.BAD_DELIMITERS = ["\r", "\n", '"', b2.BYTE_ORDER_MARK], b2.WORKERS_SUPPORTED = !n2 && !!f2.Worker, b2.NODE_STREAM_INPUT = 1, b2.LocalChunkSize = 10485760, b2.RemoteChunkSize = 5242880, b2.DefaultDelimiter = ",", b2.Parser = E2, b2.ParserHandle = r2, b2.NetworkStreamer = l2, b2.FileStreamer = c2, b2.StringStreamer = p2, b2.ReadableStreamStreamer = g2, f2.jQuery) {
          var d2 = f2.jQuery;
          d2.fn.parse = function(o3) {
            var r3 = o3.config || {}, u3 = [];
            return this.each(function(e3) {
              if (!("INPUT" === d2(this).prop("tagName").toUpperCase() && "file" === d2(this).attr("type").toLowerCase() && f2.FileReader) || !this.files || 0 === this.files.length)
                return true;
              for (var t2 = 0; t2 < this.files.length; t2++)
                u3.push({ file: this.files[t2], inputElem: this, instanceConfig: d2.extend({}, r3) });
            }), e2(), this;
            function e2() {
              if (0 !== u3.length) {
                var e3, t2, r4, i2, n3 = u3[0];
                if (J(o3.before)) {
                  var s2 = o3.before(n3.file, n3.inputElem);
                  if ("object" == typeof s2) {
                    if ("abort" === s2.action)
                      return e3 = "AbortError", t2 = n3.file, r4 = n3.inputElem, i2 = s2.reason, void (J(o3.error) && o3.error({ name: e3 }, t2, r4, i2));
                    if ("skip" === s2.action)
                      return void h2();
                    "object" == typeof s2.config && (n3.instanceConfig = d2.extend(n3.instanceConfig, s2.config));
                  } else if ("skip" === s2)
                    return void h2();
                }
                var a3 = n3.instanceConfig.complete;
                n3.instanceConfig.complete = function(e4) {
                  J(a3) && a3(e4, n3.file, n3.inputElem), h2();
                }, b2.parse(n3.file, n3.instanceConfig);
              } else
                J(o3.complete) && o3.complete();
            }
            function h2() {
              u3.splice(0, 1), e2();
            }
          };
        }
        function h(e2) {
          this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, function(e3) {
            var t2 = w2(e3);
            t2.chunkSize = parseInt(t2.chunkSize), e3.step || e3.chunk || (t2.chunkSize = null);
            this._handle = new r2(t2), (this._handle.streamer = this)._config = t2;
          }.call(this, e2), this.parseChunk = function(e3, t2) {
            if (this.isFirstChunk && J(this._config.beforeFirstChunk)) {
              var r3 = this._config.beforeFirstChunk(e3);
              void 0 !== r3 && (e3 = r3);
            }
            this.isFirstChunk = false, this._halted = false;
            var i2 = this._partialLine + e3;
            this._partialLine = "";
            var n3 = this._handle.parse(i2, this._baseIndex, !this._finished);
            if (!this._handle.paused() && !this._handle.aborted()) {
              var s2 = n3.meta.cursor;
              this._finished || (this._partialLine = i2.substring(s2 - this._baseIndex), this._baseIndex = s2), n3 && n3.data && (this._rowCount += n3.data.length);
              var a3 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
              if (o2)
                f2.postMessage({ results: n3, workerId: b2.WORKER_ID, finished: a3 });
              else if (J(this._config.chunk) && !t2) {
                if (this._config.chunk(n3, this._handle), this._handle.paused() || this._handle.aborted())
                  return void (this._halted = true);
                n3 = void 0, this._completeResults = void 0;
              }
              return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n3.data), this._completeResults.errors = this._completeResults.errors.concat(n3.errors), this._completeResults.meta = n3.meta), this._completed || !a3 || !J(this._config.complete) || n3 && n3.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a3 || n3 && n3.meta.paused || this._nextChunk(), n3;
            }
            this._halted = true;
          }, this._sendError = function(e3) {
            J(this._config.error) ? this._config.error(e3) : o2 && this._config.error && f2.postMessage({ workerId: b2.WORKER_ID, error: e3, finished: false });
          };
        }
        function l2(e2) {
          var i2;
          (e2 = e2 || {}).chunkSize || (e2.chunkSize = b2.RemoteChunkSize), h.call(this, e2), this._nextChunk = n2 ? function() {
            this._readChunk(), this._chunkLoaded();
          } : function() {
            this._readChunk();
          }, this.stream = function(e3) {
            this._input = e3, this._nextChunk();
          }, this._readChunk = function() {
            if (this._finished)
              this._chunkLoaded();
            else {
              if (i2 = new XMLHttpRequest(), this._config.withCredentials && (i2.withCredentials = this._config.withCredentials), n2 || (i2.onload = v2(this._chunkLoaded, this), i2.onerror = v2(this._chunkError, this)), i2.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n2), this._config.downloadRequestHeaders) {
                var e3 = this._config.downloadRequestHeaders;
                for (var t2 in e3)
                  i2.setRequestHeader(t2, e3[t2]);
              }
              if (this._config.chunkSize) {
                var r3 = this._start + this._config.chunkSize - 1;
                i2.setRequestHeader("Range", "bytes=" + this._start + "-" + r3);
              }
              try {
                i2.send(this._config.downloadRequestBody);
              } catch (e4) {
                this._chunkError(e4.message);
              }
              n2 && 0 === i2.status && this._chunkError();
            }
          }, this._chunkLoaded = function() {
            4 === i2.readyState && (i2.status < 200 || 400 <= i2.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i2.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e3) {
              var t2 = e3.getResponseHeader("Content-Range");
              if (null === t2)
                return -1;
              return parseInt(t2.substring(t2.lastIndexOf("/") + 1));
            }(i2), this.parseChunk(i2.responseText)));
          }, this._chunkError = function(e3) {
            var t2 = i2.statusText || e3;
            this._sendError(new Error(t2));
          };
        }
        function c2(e2) {
          var i2, n3;
          (e2 = e2 || {}).chunkSize || (e2.chunkSize = b2.LocalChunkSize), h.call(this, e2);
          var s2 = "undefined" != typeof FileReader;
          this.stream = function(e3) {
            this._input = e3, n3 = e3.slice || e3.webkitSlice || e3.mozSlice, s2 ? ((i2 = new FileReader()).onload = v2(this._chunkLoaded, this), i2.onerror = v2(this._chunkError, this)) : i2 = new FileReaderSync(), this._nextChunk();
          }, this._nextChunk = function() {
            this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
          }, this._readChunk = function() {
            var e3 = this._input;
            if (this._config.chunkSize) {
              var t2 = Math.min(this._start + this._config.chunkSize, this._input.size);
              e3 = n3.call(e3, this._start, t2);
            }
            var r3 = i2.readAsText(e3, this._config.encoding);
            s2 || this._chunkLoaded({ target: { result: r3 } });
          }, this._chunkLoaded = function(e3) {
            this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e3.target.result);
          }, this._chunkError = function() {
            this._sendError(i2.error);
          };
        }
        function p2(e2) {
          var r3;
          h.call(this, e2 = e2 || {}), this.stream = function(e3) {
            return r3 = e3, this._nextChunk();
          }, this._nextChunk = function() {
            if (!this._finished) {
              var e3, t2 = this._config.chunkSize;
              return t2 ? (e3 = r3.substring(0, t2), r3 = r3.substring(t2)) : (e3 = r3, r3 = ""), this._finished = !r3, this.parseChunk(e3);
            }
          };
        }
        function g2(e2) {
          h.call(this, e2 = e2 || {});
          var t2 = [], r3 = true, i2 = false;
          this.pause = function() {
            h.prototype.pause.apply(this, arguments), this._input.pause();
          }, this.resume = function() {
            h.prototype.resume.apply(this, arguments), this._input.resume();
          }, this.stream = function(e3) {
            this._input = e3, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
          }, this._checkIsFinished = function() {
            i2 && 1 === t2.length && (this._finished = true);
          }, this._nextChunk = function() {
            this._checkIsFinished(), t2.length ? this.parseChunk(t2.shift()) : r3 = true;
          }, this._streamData = v2(function(e3) {
            try {
              t2.push("string" == typeof e3 ? e3 : e3.toString(this._config.encoding)), r3 && (r3 = false, this._checkIsFinished(), this.parseChunk(t2.shift()));
            } catch (e4) {
              this._streamError(e4);
            }
          }, this), this._streamError = v2(function(e3) {
            this._streamCleanUp(), this._sendError(e3);
          }, this), this._streamEnd = v2(function() {
            this._streamCleanUp(), i2 = true, this._streamData("");
          }, this), this._streamCleanUp = v2(function() {
            this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
          }, this);
        }
        function r2(m2) {
          var a3, o3, u3, i2 = Math.pow(2, 53), n3 = -i2, s2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, h2 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, t2 = this, r3 = 0, f3 = 0, d3 = false, e2 = false, l3 = [], c3 = { data: [], errors: [], meta: {} };
          if (J(m2.step)) {
            var p3 = m2.step;
            m2.step = function(e3) {
              if (c3 = e3, _3())
                g3();
              else {
                if (g3(), 0 === c3.data.length)
                  return;
                r3 += e3.data.length, m2.preview && r3 > m2.preview ? o3.abort() : (c3.data = c3.data[0], p3(c3, t2));
              }
            };
          }
          function y3(e3) {
            return "greedy" === m2.skipEmptyLines ? "" === e3.join("").trim() : 1 === e3.length && 0 === e3[0].length;
          }
          function g3() {
            return c3 && u3 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b2.DefaultDelimiter + "'"), u3 = false), m2.skipEmptyLines && (c3.data = c3.data.filter(function(e3) {
              return !y3(e3);
            })), _3() && function() {
              if (!c3)
                return;
              function e3(e4, t4) {
                J(m2.transformHeader) && (e4 = m2.transformHeader(e4, t4)), l3.push(e4);
              }
              if (Array.isArray(c3.data[0])) {
                for (var t3 = 0; _3() && t3 < c3.data.length; t3++)
                  c3.data[t3].forEach(e3);
                c3.data.splice(0, 1);
              } else
                c3.data.forEach(e3);
            }(), function() {
              if (!c3 || !m2.header && !m2.dynamicTyping && !m2.transform)
                return c3;
              function e3(e4, t4) {
                var r4, i3 = m2.header ? {} : [];
                for (r4 = 0; r4 < e4.length; r4++) {
                  var n4 = r4, s3 = e4[r4];
                  m2.header && (n4 = r4 >= l3.length ? "__parsed_extra" : l3[r4]), m2.transform && (s3 = m2.transform(s3, n4)), s3 = v3(n4, s3), "__parsed_extra" === n4 ? (i3[n4] = i3[n4] || [], i3[n4].push(s3)) : i3[n4] = s3;
                }
                return m2.header && (r4 > l3.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l3.length + " fields but parsed " + r4, f3 + t4) : r4 < l3.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l3.length + " fields but parsed " + r4, f3 + t4)), i3;
              }
              var t3 = 1;
              !c3.data.length || Array.isArray(c3.data[0]) ? (c3.data = c3.data.map(e3), t3 = c3.data.length) : c3.data = e3(c3.data, 0);
              m2.header && c3.meta && (c3.meta.fields = l3);
              return f3 += t3, c3;
            }();
          }
          function _3() {
            return m2.header && 0 === l3.length;
          }
          function v3(e3, t3) {
            return r4 = e3, m2.dynamicTypingFunction && void 0 === m2.dynamicTyping[r4] && (m2.dynamicTyping[r4] = m2.dynamicTypingFunction(r4)), true === (m2.dynamicTyping[r4] || m2.dynamicTyping) ? "true" === t3 || "TRUE" === t3 || "false" !== t3 && "FALSE" !== t3 && (function(e4) {
              if (s2.test(e4)) {
                var t4 = parseFloat(e4);
                if (n3 < t4 && t4 < i2)
                  return true;
              }
              return false;
            }(t3) ? parseFloat(t3) : h2.test(t3) ? new Date(t3) : "" === t3 ? null : t3) : t3;
            var r4;
          }
          function k(e3, t3, r4, i3) {
            var n4 = { type: e3, code: t3, message: r4 };
            void 0 !== i3 && (n4.row = i3), c3.errors.push(n4);
          }
          this.parse = function(e3, t3, r4) {
            var i3 = m2.quoteChar || '"';
            if (m2.newline || (m2.newline = function(e4, t4) {
              e4 = e4.substring(0, 1048576);
              var r5 = new RegExp(Q(t4) + "([^]*?)" + Q(t4), "gm"), i4 = (e4 = e4.replace(r5, "")).split("\r"), n5 = e4.split("\n"), s4 = 1 < n5.length && n5[0].length < i4[0].length;
              if (1 === i4.length || s4)
                return "\n";
              for (var a4 = 0, o4 = 0; o4 < i4.length; o4++)
                "\n" === i4[o4][0] && a4++;
              return a4 >= i4.length / 2 ? "\r\n" : "\r";
            }(e3, i3)), u3 = false, m2.delimiter)
              J(m2.delimiter) && (m2.delimiter = m2.delimiter(e3), c3.meta.delimiter = m2.delimiter);
            else {
              var n4 = function(e4, t4, r5, i4, n5) {
                var s4, a4, o4, u4;
                n5 = n5 || [",", "	", "|", ";", b2.RECORD_SEP, b2.UNIT_SEP];
                for (var h3 = 0; h3 < n5.length; h3++) {
                  var f4 = n5[h3], d4 = 0, l4 = 0, c4 = 0;
                  o4 = void 0;
                  for (var p4 = new E2({ comments: i4, delimiter: f4, newline: t4, preview: 10 }).parse(e4), g4 = 0; g4 < p4.data.length; g4++)
                    if (r5 && y3(p4.data[g4]))
                      c4++;
                    else {
                      var _4 = p4.data[g4].length;
                      l4 += _4, void 0 !== o4 ? 0 < _4 && (d4 += Math.abs(_4 - o4), o4 = _4) : o4 = _4;
                    }
                  0 < p4.data.length && (l4 /= p4.data.length - c4), (void 0 === a4 || d4 <= a4) && (void 0 === u4 || u4 < l4) && 1.99 < l4 && (a4 = d4, s4 = f4, u4 = l4);
                }
                return { successful: !!(m2.delimiter = s4), bestDelimiter: s4 };
              }(e3, m2.newline, m2.skipEmptyLines, m2.comments, m2.delimitersToGuess);
              n4.successful ? m2.delimiter = n4.bestDelimiter : (u3 = true, m2.delimiter = b2.DefaultDelimiter), c3.meta.delimiter = m2.delimiter;
            }
            var s3 = w2(m2);
            return m2.preview && m2.header && s3.preview++, a3 = e3, o3 = new E2(s3), c3 = o3.parse(a3, t3, r4), g3(), d3 ? { meta: { paused: true } } : c3 || { meta: { paused: false } };
          }, this.paused = function() {
            return d3;
          }, this.pause = function() {
            d3 = true, o3.abort(), a3 = J(m2.chunk) ? "" : a3.substring(o3.getCharIndex());
          }, this.resume = function() {
            t2.streamer._halted ? (d3 = false, t2.streamer.parseChunk(a3, true)) : setTimeout(t2.resume, 3);
          }, this.aborted = function() {
            return e2;
          }, this.abort = function() {
            e2 = true, o3.abort(), c3.meta.aborted = true, J(m2.complete) && m2.complete(c3), a3 = "";
          };
        }
        function Q(e2) {
          return e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function E2(j) {
          var z, M = (j = j || {}).delimiter, P = j.newline, U = j.comments, q = j.step, N = j.preview, B = j.fastMode, K = z = void 0 === j.quoteChar || null === j.quoteChar ? '"' : j.quoteChar;
          if (void 0 !== j.escapeChar && (K = j.escapeChar), ("string" != typeof M || -1 < b2.BAD_DELIMITERS.indexOf(M)) && (M = ","), U === M)
            throw new Error("Comment character same as delimiter");
          true === U ? U = "#" : ("string" != typeof U || -1 < b2.BAD_DELIMITERS.indexOf(U)) && (U = false), "\n" !== P && "\r" !== P && "\r\n" !== P && (P = "\n");
          var W = 0, H = false;
          this.parse = function(i2, t2, r3) {
            if ("string" != typeof i2)
              throw new Error("Input must be a string");
            var n3 = i2.length, e2 = M.length, s2 = P.length, a3 = U.length, o3 = J(q), u3 = [], h2 = [], f3 = [], d3 = W = 0;
            if (!i2)
              return L();
            if (j.header && !t2) {
              var l3 = i2.split(P)[0].split(M), c3 = [], p3 = {}, g3 = false;
              for (var _3 in l3) {
                var m2 = l3[_3];
                J(j.transformHeader) && (m2 = j.transformHeader(m2, _3));
                var y3 = m2, v3 = p3[m2] || 0;
                for (0 < v3 && (g3 = true, y3 = m2 + "_" + v3), p3[m2] = v3 + 1; c3.includes(y3); )
                  y3 = y3 + "_" + v3;
                c3.push(y3);
              }
              if (g3) {
                var k = i2.split(P);
                k[0] = c3.join(M), i2 = k.join(P);
              }
            }
            if (B || false !== B && -1 === i2.indexOf(z)) {
              for (var b3 = i2.split(P), E3 = 0; E3 < b3.length; E3++) {
                if (f3 = b3[E3], W += f3.length, E3 !== b3.length - 1)
                  W += P.length;
                else if (r3)
                  return L();
                if (!U || f3.substring(0, a3) !== U) {
                  if (o3) {
                    if (u3 = [], I(f3.split(M)), F(), H)
                      return L();
                  } else
                    I(f3.split(M));
                  if (N && N <= E3)
                    return u3 = u3.slice(0, N), L(true);
                }
              }
              return L();
            }
            for (var w3 = i2.indexOf(M, W), R = i2.indexOf(P, W), C = new RegExp(Q(K) + Q(z), "g"), S = i2.indexOf(z, W); ; )
              if (i2[W] !== z)
                if (U && 0 === f3.length && i2.substring(W, W + a3) === U) {
                  if (-1 === R)
                    return L();
                  W = R + s2, R = i2.indexOf(P, W), w3 = i2.indexOf(M, W);
                } else if (-1 !== w3 && (w3 < R || -1 === R))
                  f3.push(i2.substring(W, w3)), W = w3 + e2, w3 = i2.indexOf(M, W);
                else {
                  if (-1 === R)
                    break;
                  if (f3.push(i2.substring(W, R)), D(R + s2), o3 && (F(), H))
                    return L();
                  if (N && u3.length >= N)
                    return L(true);
                }
              else
                for (S = W, W++; ; ) {
                  if (-1 === (S = i2.indexOf(z, S + 1)))
                    return r3 || h2.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: u3.length, index: W }), T();
                  if (S === n3 - 1)
                    return T(i2.substring(W, S).replace(C, z));
                  if (z !== K || i2[S + 1] !== K) {
                    if (z === K || 0 === S || i2[S - 1] !== K) {
                      -1 !== w3 && w3 < S + 1 && (w3 = i2.indexOf(M, S + 1)), -1 !== R && R < S + 1 && (R = i2.indexOf(P, S + 1));
                      var O2 = A(-1 === R ? w3 : Math.min(w3, R));
                      if (i2.substr(S + 1 + O2, e2) === M) {
                        f3.push(i2.substring(W, S).replace(C, z)), i2[W = S + 1 + O2 + e2] !== z && (S = i2.indexOf(z, W)), w3 = i2.indexOf(M, W), R = i2.indexOf(P, W);
                        break;
                      }
                      var x2 = A(R);
                      if (i2.substring(S + 1 + x2, S + 1 + x2 + s2) === P) {
                        if (f3.push(i2.substring(W, S).replace(C, z)), D(S + 1 + x2 + s2), w3 = i2.indexOf(M, W), S = i2.indexOf(z, W), o3 && (F(), H))
                          return L();
                        if (N && u3.length >= N)
                          return L(true);
                        break;
                      }
                      h2.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: u3.length, index: W }), S++;
                    }
                  } else
                    S++;
                }
            return T();
            function I(e3) {
              u3.push(e3), d3 = W;
            }
            function A(e3) {
              var t3 = 0;
              if (-1 !== e3) {
                var r4 = i2.substring(S + 1, e3);
                r4 && "" === r4.trim() && (t3 = r4.length);
              }
              return t3;
            }
            function T(e3) {
              return r3 || (void 0 === e3 && (e3 = i2.substring(W)), f3.push(e3), W = n3, I(f3), o3 && F()), L();
            }
            function D(e3) {
              W = e3, I(f3), f3 = [], R = i2.indexOf(P, W);
            }
            function L(e3) {
              return { data: u3, errors: h2, meta: { delimiter: M, linebreak: P, aborted: H, truncated: !!e3, cursor: d3 + (t2 || 0) } };
            }
            function F() {
              q(L()), u3 = [], h2 = [];
            }
          }, this.abort = function() {
            H = true;
          }, this.getCharIndex = function() {
            return W;
          };
        }
        function _2(e2) {
          var t2 = e2.data, r3 = a2[t2.workerId], i2 = false;
          if (t2.error)
            r3.userError(t2.error, t2.file);
          else if (t2.results && t2.results.data) {
            var n3 = { abort: function() {
              i2 = true, m(t2.workerId, { data: [], errors: [], meta: { aborted: true } });
            }, pause: y2, resume: y2 };
            if (J(r3.userStep)) {
              for (var s2 = 0; s2 < t2.results.data.length && (r3.userStep({ data: t2.results.data[s2], errors: t2.results.errors, meta: t2.results.meta }, n3), !i2); s2++)
                ;
              delete t2.results;
            } else
              J(r3.userChunk) && (r3.userChunk(t2.results, n3, t2.file), delete t2.results);
          }
          t2.finished && !i2 && m(t2.workerId, t2.results);
        }
        function m(e2, t2) {
          var r3 = a2[e2];
          J(r3.userComplete) && r3.userComplete(t2), r3.terminate(), delete a2[e2];
        }
        function y2() {
          throw new Error("Not implemented.");
        }
        function w2(e2) {
          if ("object" != typeof e2 || null === e2)
            return e2;
          var t2 = Array.isArray(e2) ? [] : {};
          for (var r3 in e2)
            t2[r3] = w2(e2[r3]);
          return t2;
        }
        function v2(e2, t2) {
          return function() {
            e2.apply(t2, arguments);
          };
        }
        function J(e2) {
          return "function" == typeof e2;
        }
        return o2 && (f2.onmessage = function(e2) {
          var t2 = e2.data;
          void 0 === b2.WORKER_ID && t2 && (b2.WORKER_ID = t2.workerId);
          if ("string" == typeof t2.input)
            f2.postMessage({ workerId: b2.WORKER_ID, results: b2.parse(t2.input, t2.config), finished: true });
          else if (f2.File && t2.input instanceof File || t2.input instanceof Object) {
            var r3 = b2.parse(t2.input, t2.config);
            r3 && f2.postMessage({ workerId: b2.WORKER_ID, results: r3, finished: true });
          }
        }), (l2.prototype = Object.create(h.prototype)).constructor = l2, (c2.prototype = Object.create(h.prototype)).constructor = c2, (p2.prototype = Object.create(p2.prototype)).constructor = p2, (g2.prototype = Object.create(h.prototype)).constructor = g2, b2;
      });
    }
  });

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function toPrimitive(t2, r2) {
    if ("object" != _typeof(t2) || !t2)
      return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2 || "default");
      if ("object" != _typeof(i2))
        return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function toPropertyKey(t2) {
    var i2 = toPrimitive(t2, "string");
    return "symbol" == _typeof(i2) ? i2 : String(i2);
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "loader assertion failed.");
    }
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global || {};
  var window_ = globals.window || globals.self || globals.global || {};
  var global_ = globals.global || globals.self || globals.window || {};
  var document_ = globals.document || {};
  var isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js
  var VERSION = true ? "3.4.14" : DEFAULT_VERSION;
  if (false) {
    console.error("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js
  function assert2(condition, message) {
    if (!condition) {
      throw new Error(message || "loaders.gl assertion failed.");
    }
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js
  var globals2 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_2 = globals2.self || globals2.window || globals2.global || {};
  var window_2 = globals2.window || globals2.self || globals2.global || {};
  var global_2 = globals2.global || globals2.self || globals2.window || {};
  var document_2 = globals2.document || {};
  var isBrowser2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
  var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
  var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js
  var WorkerJob = class {
    constructor(jobName, workerThread) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "workerThread", void 0);
      _defineProperty(this, "isRunning", true);
      _defineProperty(this, "result", void 0);
      _defineProperty(this, "_resolve", () => {
      });
      _defineProperty(this, "_reject", () => {
      });
      this.name = jobName;
      this.workerThread = workerThread;
      this.result = new Promise((resolve2, reject) => {
        this._resolve = resolve2;
        this._reject = reject;
      });
    }
    postMessage(type, payload) {
      this.workerThread.postMessage({
        source: "loaders.gl",
        type,
        payload
      });
    }
    done(value) {
      assert2(this.isRunning);
      this.isRunning = false;
      this._resolve(value);
    }
    error(error2) {
      assert2(this.isRunning);
      this.isRunning = false;
      this._reject(error2);
    }
  };

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js
  var Worker2 = class {
    terminate() {
    }
  };

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js
  var workerURLCache = /* @__PURE__ */ new Map();
  function getLoadableWorkerURL(props) {
    assert2(props.source && !props.url || !props.source && props.url);
    let workerURL = workerURLCache.get(props.source || props.url);
    if (!workerURL) {
      if (props.url) {
        workerURL = getLoadableWorkerURLFromURL(props.url);
        workerURLCache.set(props.url, workerURL);
      }
      if (props.source) {
        workerURL = getLoadableWorkerURLFromSource(props.source);
        workerURLCache.set(props.source, workerURL);
      }
    }
    assert2(workerURL);
    return workerURL;
  }
  function getLoadableWorkerURLFromURL(url) {
    if (!url.startsWith("http")) {
      return url;
    }
    const workerSource = buildScriptSource(url);
    return getLoadableWorkerURLFromSource(workerSource);
  }
  function getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([workerSource], {
      type: "application/javascript"
    });
    return URL.createObjectURL(blob);
  }
  function buildScriptSource(workerUrl) {
    return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js
  function getTransferList(object) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let transfers = arguments.length > 2 ? arguments[2] : void 0;
    const transfersSet = transfers || /* @__PURE__ */ new Set();
    if (!object) {
    } else if (isTransferable(object)) {
      transfersSet.add(object);
    } else if (isTransferable(object.buffer)) {
      transfersSet.add(object.buffer);
    } else if (ArrayBuffer.isView(object)) {
    } else if (recursive && typeof object === "object") {
      for (const key in object) {
        getTransferList(object[key], recursive, transfersSet);
      }
    }
    return transfers === void 0 ? Array.from(transfersSet) : [];
  }
  function isTransferable(object) {
    if (!object) {
      return false;
    }
    if (object instanceof ArrayBuffer) {
      return true;
    }
    if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
      return true;
    }
    if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
      return true;
    }
    if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
      return true;
    }
    return false;
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js
  var NOOP = () => {
  };
  var WorkerThread = class {
    static isSupported() {
      return typeof Worker !== "undefined" && isBrowser2 || typeof Worker2 !== "undefined" && !isBrowser2;
    }
    constructor(props) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "source", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "terminated", false);
      _defineProperty(this, "worker", void 0);
      _defineProperty(this, "onMessage", void 0);
      _defineProperty(this, "onError", void 0);
      _defineProperty(this, "_loadableURL", "");
      const {
        name,
        source,
        url
      } = props;
      assert2(source || url);
      this.name = name;
      this.source = source;
      this.url = url;
      this.onMessage = NOOP;
      this.onError = (error2) => console.log(error2);
      this.worker = isBrowser2 ? this._createBrowserWorker() : this._createNodeWorker();
    }
    destroy() {
      this.onMessage = NOOP;
      this.onError = NOOP;
      this.worker.terminate();
      this.terminated = true;
    }
    get isRunning() {
      return Boolean(this.onMessage);
    }
    postMessage(data, transferList) {
      transferList = transferList || getTransferList(data);
      this.worker.postMessage(data, transferList);
    }
    _getErrorFromErrorEvent(event) {
      let message = "Failed to load ";
      message += "worker ".concat(this.name, " from ").concat(this.url, ". ");
      if (event.message) {
        message += "".concat(event.message, " in ");
      }
      if (event.lineno) {
        message += ":".concat(event.lineno, ":").concat(event.colno);
      }
      return new Error(message);
    }
    _createBrowserWorker() {
      this._loadableURL = getLoadableWorkerURL({
        source: this.source,
        url: this.url
      });
      const worker = new Worker(this._loadableURL, {
        name: this.name
      });
      worker.onmessage = (event) => {
        if (!event.data) {
          this.onError(new Error("No data received"));
        } else {
          this.onMessage(event.data);
        }
      };
      worker.onerror = (error2) => {
        this.onError(this._getErrorFromErrorEvent(error2));
        this.terminated = true;
      };
      worker.onmessageerror = (event) => console.error(event);
      return worker;
    }
    _createNodeWorker() {
      let worker;
      if (this.url) {
        const absolute = this.url.includes(":/") || this.url.startsWith("/");
        const url = absolute ? this.url : "./".concat(this.url);
        worker = new Worker2(url, {
          eval: false
        });
      } else if (this.source) {
        worker = new Worker2(this.source, {
          eval: true
        });
      } else {
        throw new Error("no worker");
      }
      worker.on("message", (data) => {
        this.onMessage(data);
      });
      worker.on("error", (error2) => {
        this.onError(error2);
      });
      worker.on("exit", (code) => {
      });
      return worker;
    }
  };

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js
  var WorkerPool = class {
    static isSupported() {
      return WorkerThread.isSupported();
    }
    constructor(props) {
      _defineProperty(this, "name", "unnamed");
      _defineProperty(this, "source", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "maxConcurrency", 1);
      _defineProperty(this, "maxMobileConcurrency", 1);
      _defineProperty(this, "onDebug", () => {
      });
      _defineProperty(this, "reuseWorkers", true);
      _defineProperty(this, "props", {});
      _defineProperty(this, "jobQueue", []);
      _defineProperty(this, "idleQueue", []);
      _defineProperty(this, "count", 0);
      _defineProperty(this, "isDestroyed", false);
      this.source = props.source;
      this.url = props.url;
      this.setProps(props);
    }
    destroy() {
      this.idleQueue.forEach((worker) => worker.destroy());
      this.isDestroyed = true;
    }
    setProps(props) {
      this.props = {
        ...this.props,
        ...props
      };
      if (props.name !== void 0) {
        this.name = props.name;
      }
      if (props.maxConcurrency !== void 0) {
        this.maxConcurrency = props.maxConcurrency;
      }
      if (props.maxMobileConcurrency !== void 0) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }
      if (props.reuseWorkers !== void 0) {
        this.reuseWorkers = props.reuseWorkers;
      }
      if (props.onDebug !== void 0) {
        this.onDebug = props.onDebug;
      }
    }
    async startJob(name) {
      let onMessage2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (job, type, data) => job.done(data);
      let onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (job, error2) => job.error(error2);
      const startPromise = new Promise((onStart) => {
        this.jobQueue.push({
          name,
          onMessage: onMessage2,
          onError,
          onStart
        });
        return this;
      });
      this._startQueuedJob();
      return await startPromise;
    }
    async _startQueuedJob() {
      if (!this.jobQueue.length) {
        return;
      }
      const workerThread = this._getAvailableWorker();
      if (!workerThread) {
        return;
      }
      const queuedJob = this.jobQueue.shift();
      if (queuedJob) {
        this.onDebug({
          message: "Starting job",
          name: queuedJob.name,
          workerThread,
          backlog: this.jobQueue.length
        });
        const job = new WorkerJob(queuedJob.name, workerThread);
        workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
        workerThread.onError = (error2) => queuedJob.onError(job, error2);
        queuedJob.onStart(job);
        try {
          await job.result;
        } finally {
          this.returnWorkerToQueue(workerThread);
        }
      }
    }
    returnWorkerToQueue(worker) {
      const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }
      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
    _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }
      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        const name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
        return new WorkerThread({
          name,
          source: this.source,
          url: this.url
        });
      }
      return null;
    }
    _getMaxConcurrency() {
      return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  };

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js
  var DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: () => {
    }
  };
  var WorkerFarm = class _WorkerFarm {
    static isSupported() {
      return WorkerThread.isSupported();
    }
    static getWorkerFarm() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _WorkerFarm._workerFarm = _WorkerFarm._workerFarm || new _WorkerFarm({});
      _WorkerFarm._workerFarm.setProps(props);
      return _WorkerFarm._workerFarm;
    }
    constructor(props) {
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "workerPools", /* @__PURE__ */ new Map());
      this.props = {
        ...DEFAULT_PROPS
      };
      this.setProps(props);
      this.workerPools = /* @__PURE__ */ new Map();
    }
    destroy() {
      for (const workerPool of this.workerPools.values()) {
        workerPool.destroy();
      }
      this.workerPools = /* @__PURE__ */ new Map();
    }
    setProps(props) {
      this.props = {
        ...this.props,
        ...props
      };
      for (const workerPool of this.workerPools.values()) {
        workerPool.setProps(this._getWorkerPoolProps());
      }
    }
    getWorkerPool(options) {
      const {
        name,
        source,
        url
      } = options;
      let workerPool = this.workerPools.get(name);
      if (!workerPool) {
        workerPool = new WorkerPool({
          name,
          source,
          url
        });
        workerPool.setProps(this._getWorkerPoolProps());
        this.workerPools.set(name, workerPool);
      }
      return workerPool;
    }
    _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  };
  _defineProperty(WorkerFarm, "_workerFarm", void 0);

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js
  var NPM_TAG = "latest";
  function getWorkerURL(worker) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const workerOptions = options[worker.id] || {};
    const workerFile = "".concat(worker.id, "-worker.js");
    let url = workerOptions.workerUrl;
    if (!url && worker.id === "compression") {
      url = options.workerUrl;
    }
    if (options._workerType === "test") {
      url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
    }
    if (!url) {
      let version = worker.version;
      if (version === "latest") {
        version = NPM_TAG;
      }
      const versionTag = version ? "@".concat(version) : "";
      url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
    }
    assert2(url);
    return url;
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js
  function validateWorkerVersion(worker) {
    let coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION;
    assert2(worker, "no worker provided");
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) {
      return false;
    }
    return true;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js
  function canParseWithWorker(loader, options) {
    if (!WorkerFarm.isSupported()) {
      return false;
    }
    if (!isBrowser2 && !(options !== null && options !== void 0 && options._nodeWorkers)) {
      return false;
    }
    return loader.worker && (options === null || options === void 0 ? void 0 : options.worker);
  }
  async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
    const name = loader.id;
    const url = getWorkerURL(loader, options);
    const workerFarm = WorkerFarm.getWorkerFarm(options);
    const workerPool = workerFarm.getWorkerPool({
      name,
      url
    });
    options = JSON.parse(JSON.stringify(options));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob("process-on-worker", onMessage.bind(null, parseOnMainThread));
    job.postMessage("process", {
      input: data,
      options,
      context
    });
    const result = await job.result;
    return await result.result;
  }
  async function onMessage(parseOnMainThread, job, type, payload) {
    switch (type) {
      case "done":
        job.done(payload);
        break;
      case "error":
        job.error(new Error(payload.error));
        break;
      case "process":
        const {
          id,
          input,
          options
        } = payload;
        try {
          const result = await parseOnMainThread(input, options);
          job.postMessage("done", {
            id,
            result
          });
        } catch (error2) {
          const message = error2 instanceof Error ? error2.message : "unknown error";
          job.postMessage("error", {
            id,
            error: message
          });
        }
        break;
      default:
        console.warn("parse-with-worker unknown message ".concat(type));
    }
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
  function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
      return false;
    }
    const array12 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for (let i2 = 0; i2 < array12.length; ++i2) {
      if (array12[i2] !== array2[i2]) {
        return false;
      }
    }
    return true;
  }
  function concatenateArrayBuffers() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays) {
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
    return result.buffer;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js
  async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator) {
      arrayBuffers.push(chunk);
    }
    return concatenateArrayBuffers(...arrayBuffers);
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
  var pathPrefix = "";
  var fileAliases = {};
  function resolvePath(filename2) {
    for (const alias in fileAliases) {
      if (filename2.startsWith(alias)) {
        const replacement = fileAliases[alias];
        filename2 = filename2.replace(alias, replacement);
      }
    }
    if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
      filename2 = "".concat(pathPrefix).concat(filename2);
    }
    return filename2;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js
  function toArrayBuffer(buffer) {
    return buffer;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js
  function isBuffer(value) {
    return value && typeof value === "object" && value.isBuffer;
  }
  function toArrayBuffer2(data) {
    if (isBuffer(data)) {
      return toArrayBuffer(data);
    }
    if (data instanceof ArrayBuffer) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
        return data.buffer;
      }
      return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === "string") {
      const text = data;
      const uint8Array = new TextEncoder().encode(text);
      return uint8Array.buffer;
    }
    if (data && typeof data === "object" && data._toArrayBuffer) {
      return data._toArrayBuffer();
    }
    throw new Error("toArrayBuffer");
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
  var path_exports = {};
  __export(path_exports, {
    dirname: () => dirname,
    filename: () => filename,
    join: () => join,
    resolve: () => resolve
  });

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/get-cwd.js
  function getCWD() {
    var _window$location;
    if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
      return process.cwd();
    }
    const pathname = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
    return (pathname === null || pathname === void 0 ? void 0 : pathname.slice(0, pathname.lastIndexOf("/") + 1)) || "";
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
  function filename(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
  }
  function dirname(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
  }
  function join() {
    for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
      parts[_key] = arguments[_key];
    }
    const separator = "/";
    parts = parts.map((part, index) => {
      if (index) {
        part = part.replace(new RegExp("^".concat(separator)), "");
      }
      if (index !== parts.length - 1) {
        part = part.replace(new RegExp("".concat(separator, "$")), "");
      }
      return part;
    });
    return parts.join(separator);
  }
  function resolve() {
    const paths = [];
    for (let _i = 0; _i < arguments.length; _i++) {
      paths[_i] = _i < 0 || arguments.length <= _i ? void 0 : arguments[_i];
    }
    let resolvedPath = "";
    let resolvedAbsolute = false;
    let cwd;
    for (let i2 = paths.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
      let path;
      if (i2 >= 0) {
        path = paths[i2];
      } else {
        if (cwd === void 0) {
          cwd = getCWD();
        }
        path = cwd;
      }
      if (path.length === 0) {
        continue;
      }
      resolvedPath = "".concat(path, "/").concat(resolvedPath);
      resolvedAbsolute = path.charCodeAt(0) === SLASH;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      return "/".concat(resolvedPath);
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    }
    return ".";
  }
  var SLASH = 47;
  var DOT = 46;
  function normalizeStringPosix(path, allowAboveRoot) {
    let res = "";
    let lastSlash = -1;
    let dots = 0;
    let code;
    let isAboveRoot = false;
    for (let i2 = 0; i2 <= path.length; ++i2) {
      if (i2 < path.length) {
        code = path.charCodeAt(i2);
      } else if (code === SLASH) {
        break;
      } else {
        code = SLASH;
      }
      if (code === SLASH) {
        if (lastSlash === i2 - 1 || dots === 1) {
        } else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
            if (res.length > 2) {
              const start = res.length - 1;
              let j = start;
              for (; j >= 0; --j) {
                if (res.charCodeAt(j) === SLASH) {
                  break;
                }
              }
              if (j !== start) {
                res = j === -1 ? "" : res.slice(0, j);
                lastSlash = i2;
                dots = 0;
                isAboveRoot = false;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSlash = i2;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            isAboveRoot = true;
          }
        } else {
          const slice = path.slice(lastSlash + 1, i2);
          if (res.length > 0) {
            res += "/".concat(slice);
          } else {
            res = slice;
          }
          isAboveRoot = false;
        }
        lastSlash = i2;
        dots = 0;
      } else if (code === DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }

  // node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js
  var isBoolean = (x2) => typeof x2 === "boolean";
  var isFunction = (x2) => typeof x2 === "function";
  var isObject = (x2) => x2 !== null && typeof x2 === "object";
  var isPureObject = (x2) => isObject(x2) && x2.constructor === {}.constructor;
  var isIterable = (x2) => x2 && typeof x2[Symbol.iterator] === "function";
  var isAsyncIterable = (x2) => x2 && typeof x2[Symbol.asyncIterator] === "function";
  var isResponse = (x2) => typeof Response !== "undefined" && x2 instanceof Response || x2 && x2.arrayBuffer && x2.text && x2.json;
  var isBlob = (x2) => typeof Blob !== "undefined" && x2 instanceof Blob;
  var isBuffer2 = (x2) => x2 && typeof x2 === "object" && x2.isBuffer;
  var isReadableDOMStream = (x2) => typeof ReadableStream !== "undefined" && x2 instanceof ReadableStream || isObject(x2) && isFunction(x2.tee) && isFunction(x2.cancel) && isFunction(x2.getReader);
  var isReadableNodeStream = (x2) => isObject(x2) && isFunction(x2.read) && isFunction(x2.pipe) && isBoolean(x2.readable);
  var isReadableStream = (x2) => isReadableDOMStream(x2) || isReadableNodeStream(x2);

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js
  var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
  var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
  function parseMIMEType(mimeString) {
    const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
    if (matches3) {
      return matches3[1];
    }
    return mimeString;
  }
  function parseMIMETypeFromURL(url) {
    const matches3 = DATA_URL_PATTERN.exec(url);
    if (matches3) {
      return matches3[1];
    }
    return "";
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js
  var QUERY_STRING_PATTERN = /\?.*/;
  function extractQueryString(url) {
    const matches3 = url.match(QUERY_STRING_PATTERN);
    return matches3 && matches3[0];
  }
  function stripQueryString(url) {
    return url.replace(QUERY_STRING_PATTERN, "");
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js
  function getResourceUrl(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.url;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.name || "";
    }
    if (typeof resource === "string") {
      return resource;
    }
    return "";
  }
  function getResourceMIMEType(resource) {
    if (isResponse(resource)) {
      const response = resource;
      const contentTypeHeader = response.headers.get("content-type") || "";
      const noQueryUrl = stripQueryString(response.url);
      return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.type || "";
    }
    if (typeof resource === "string") {
      return parseMIMETypeFromURL(resource);
    }
    return "";
  }
  function getResourceContentLength(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.headers["content-length"] || -1;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.size;
    }
    if (typeof resource === "string") {
      return resource.length;
    }
    if (resource instanceof ArrayBuffer) {
      return resource.byteLength;
    }
    if (ArrayBuffer.isView(resource)) {
      return resource.byteLength;
    }
    return -1;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
  async function makeResponse(resource) {
    if (isResponse(resource)) {
      return resource;
    }
    const headers = {};
    const contentLength = getResourceContentLength(resource);
    if (contentLength >= 0) {
      headers["content-length"] = String(contentLength);
    }
    const url = getResourceUrl(resource);
    const type = getResourceMIMEType(resource);
    if (type) {
      headers["content-type"] = type;
    }
    const initialDataUrl = await getInitialDataUrl(resource);
    if (initialDataUrl) {
      headers["x-first-bytes"] = initialDataUrl;
    }
    if (typeof resource === "string") {
      resource = new TextEncoder().encode(resource);
    }
    const response = new Response(resource, {
      headers
    });
    Object.defineProperty(response, "url", {
      value: url
    });
    return response;
  }
  async function checkResponse(response) {
    if (!response.ok) {
      const message = await getResponseError(response);
      throw new Error(message);
    }
  }
  async function getResponseError(response) {
    let message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
    try {
      const contentType = response.headers.get("Content-Type");
      let text = response.statusText;
      if (contentType.includes("application/json")) {
        text += " ".concat(await response.text());
      }
      message += text;
      message = message.length > 60 ? "".concat(message.slice(0, 60), "...") : message;
    } catch (error2) {
    }
    return message;
  }
  async function getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === "string") {
      return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
    }
    if (resource instanceof Blob) {
      const blobSlice = resource.slice(0, 5);
      return await new Promise((resolve2) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          var _event$target;
          return resolve2(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
        };
        reader.readAsDataURL(blobSlice);
      });
    }
    if (resource instanceof ArrayBuffer) {
      const slice = resource.slice(0, INITIAL_DATA_LENGTH);
      const base64 = arrayBufferToBase64(slice);
      return "data:base64,".concat(base64);
    }
    return null;
  }
  function arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for (let i2 = 0; i2 < bytes.byteLength; i2++) {
      binary += String.fromCharCode(bytes[i2]);
    }
    return btoa(binary);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
  async function fetchFile(url, options) {
    if (typeof url === "string") {
      url = resolvePath(url);
      let fetchOptions = options;
      if (options !== null && options !== void 0 && options.fetch && typeof (options === null || options === void 0 ? void 0 : options.fetch) !== "function") {
        fetchOptions = options.fetch;
      }
      return await fetch(url, fetchOptions);
    }
    return await makeResponse(url);
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent2 = mockUserAgent || realUserAgent;
    if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser3() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js
  var self_3 = globalThis.self || globalThis.window || globalThis.global;
  var window_3 = globalThis.window || globalThis.self || globalThis.global;
  var document_3 = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/globals.js
  var VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser4 = isBrowser3();

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x2 = "__storage_test__";
      storage.setItem(x2, x2);
      storage.removeItem(x2);
      return storage;
    } catch (e2) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id, defaultConfig) {
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      this.storage = void 0;
      this.id = void 0;
      this.config = void 0;
      this.storage = getStorage(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = `${ms.toFixed(2)}ms`;
    } else if (ms < 100) {
      formatted = `${ms.toFixed(1)}ms`;
    } else if (ms < 1e3) {
      formatted = `${ms.toFixed(0)}ms`;
    } else {
      formatted = `${(ms / 1e3).toFixed(2)}s`;
    }
    return formatted;
  }
  function leftPad(string) {
    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return `${" ".repeat(padLength)}${string}`;
  }
  function formatImage(image, message, scale3) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale3 = Math.min(scale3, maxWidth / image.width);
    }
    const width = image.width * scale3;
    const height = image.height * scale3;
    const style = ["font-size:1px;", `padding:${Math.floor(height / 2)}px ${Math.floor(width / 2)}px;`, `line-height:${height}px;`, `background:url(${imageUrl});`, `background-size:${width}px ${height}px;`, "color:transparent;"].join("");
    return [`${message} %c+`, style];
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR3) {
    COLOR3[COLOR3["BLACK"] = 30] = "BLACK";
    COLOR3[COLOR3["RED"] = 31] = "RED";
    COLOR3[COLOR3["GREEN"] = 32] = "GREEN";
    COLOR3[COLOR3["YELLOW"] = 33] = "YELLOW";
    COLOR3[COLOR3["BLUE"] = 34] = "BLUE";
    COLOR3[COLOR3["MAGENTA"] = 35] = "MAGENTA";
    COLOR3[COLOR3["CYAN"] = 36] = "CYAN";
    COLOR3[COLOR3["WHITE"] = 37] = "WHITE";
    COLOR3[COLOR3["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR3[COLOR3["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR3[COLOR3["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR3[COLOR3["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR3[COLOR3["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR3[COLOR3["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR3[COLOR3["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR3[COLOR3["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string, color, background) {
    if (!isBrowser3 && typeof string === "string") {
      if (color) {
        const colorCode = getColor(color);
        string = `\x1B[${colorCode}m${string}\x1B[39m`;
      }
      if (background) {
        const colorCode = getColor(background);
        string = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string}\x1B[49m`;
      }
    }
    return string;
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object = obj;
    for (const key of propNames) {
      const value = object[key];
      if (typeof value === "function") {
        if (!predefined.find((name) => key === name)) {
          object[key] = value.bind(obj);
        }
      }
    }
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/assert.js
  function assert3(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (isBrowser3() && window_3.performance) {
      var _window$performance, _window$performance$n;
      timestamp = window_3 === null || window_3 === void 0 ? void 0 : (_window$performance = window_3.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_) {
      var _process$hrtime;
      const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser3() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  var Log = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      this.id = void 0;
      this.VERSION = VERSION2;
      this._startTs = getHiResTimestamp();
      this._deltaTs = getHiResTimestamp();
      this._storage = void 0;
      this.userData = {};
      this.LOG_THROTTLE_TIMEOUT = 0;
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
      this.timeStamp(`${this.id} started`);
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.setConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.setConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message) {
      assert3(condition, message);
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
    }
    removed(oldUsage, newUsage) {
      return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message = "",
        scale: scale3 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }
      return isBrowser3() ? logImageInBrowser({
        image,
        message,
        scale: scale3
      }) : logImageInNode({
        image,
        message,
        scale: scale3
      });
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop);
    }
    group(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments({
        logLevel,
        message,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({
          logLevel,
          message,
          args,
          opts
        });
        method = method || opts.method;
        assert3(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp();
          } else {
            return noop;
          }
        }
        message = decorateMessage(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop;
    }
  };
  Log.VERSION = VERSION2;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert3(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const {
      logLevel,
      message
    } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert3(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
      message = addColor(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode(_ref2) {
    let {
      image,
      message = "",
      scale: scale3 = 1
    } = _ref2;
    console.warn("removed");
    return noop;
  }
  function logImageInBrowser(_ref3) {
    let {
      image,
      message = "",
      scale: scale3 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage(img, message, scale3);
        console.log(...args);
      };
      img.src = image;
      return noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage(image, message, scale3));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage(img, message, scale3));
      img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/init.js
  globalThis.probe = {};

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({
    id: "@probe.gl/log"
  });

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js
  var probeLog = new Log({
    id: "loaders.gl"
  });
  var NullLog = class {
    log() {
      return () => {
      };
    }
    info() {
      return () => {
      };
    }
    warn() {
      return () => {
      };
    }
    error() {
      return () => {
      };
    }
  };
  var ConsoleLog = class {
    constructor() {
      _defineProperty(this, "console", void 0);
      this.console = console;
    }
    log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.console.log.bind(this.console, ...args);
    }
    info() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.console.info.bind(this.console, ...args);
    }
    warn() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.console.warn.bind(this.console, ...args);
    }
    error() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.console.error.bind(this.console, ...args);
    }
  };

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js
  var DEFAULT_LOADER_OPTIONS = {
    fetch: null,
    mimeType: void 0,
    nothrow: false,
    log: new ConsoleLog(),
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: isBrowser,
    _nodeWorkers: false,
    _workerType: "",
    limit: 0,
    _limitMB: 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
  };
  var REMOVED_LOADER_OPTIONS = {
    throws: "nothrow",
    dataType: "(no longer used)",
    uri: "baseUri",
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
  };

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js
  function getGlobalLoaderState() {
    globalThis.loaders = globalThis.loaders || {};
    const {
      loaders
    } = globalThis;
    loaders._state = loaders._state || {};
    return loaders._state;
  }
  var getGlobalLoaderOptions = () => {
    const state = getGlobalLoaderState();
    state.globalOptions = state.globalOptions || {
      ...DEFAULT_LOADER_OPTIONS
    };
    return state.globalOptions;
  };
  function normalizeOptions(options, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    validateOptions(options, loaders);
    return normalizeOptionsInternal(loader, options, url);
  }
  function validateOptions(options, loaders) {
    validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
    for (const loader of loaders) {
      const idOptions = options && options[loader.id] || {};
      const loaderOptions = loader.options && loader.options[loader.id] || {};
      const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
  }
  function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
    const loaderName = id || "Top level";
    const prefix = id ? "".concat(id, ".") : "";
    for (const key in options) {
      const isSubOptions = !id && isObject(options[key]);
      const isBaseUriOption = key === "baseUri" && !id;
      const isWorkerUrlOption = key === "workerUrl" && id;
      if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
        if (key in deprecatedOptions) {
          probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
        } else if (!isSubOptions) {
          const suggestion = findSimilarOption(key, loaders);
          probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
        }
      }
    }
  }
  function findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = "";
    for (const loader of loaders) {
      for (const key in loader.options) {
        if (optionKey === key) {
          return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        }
        const lowerCaseKey = key.toLowerCase();
        const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        }
      }
    }
    return bestSuggestion;
  }
  function normalizeOptionsInternal(loader, options, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = {
      ...loaderDefaultOptions
    };
    addUrlOptions(mergedOptions, url);
    if (mergedOptions.log === null) {
      mergedOptions.log = new NullLog();
    }
    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
    mergeNestedFields(mergedOptions, options);
    return mergedOptions;
  }
  function mergeNestedFields(mergedOptions, options) {
    for (const key in options) {
      if (key in options) {
        const value = options[key];
        if (isPureObject(value) && isPureObject(mergedOptions[key])) {
          mergedOptions[key] = {
            ...mergedOptions[key],
            ...options[key]
          };
        } else {
          mergedOptions[key] = options[key];
        }
      }
    }
  }
  function addUrlOptions(options, url) {
    if (url && !("baseUri" in options)) {
      options.baseUri = url;
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js
  function isLoaderObject(loader) {
    var _loader;
    if (!loader) {
      return false;
    }
    if (Array.isArray(loader)) {
      loader = loader[0];
    }
    const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
    return hasExtensions;
  }
  function normalizeLoader(loader) {
    var _loader2, _loader3;
    assert(loader, "null loader");
    assert(isLoaderObject(loader), "invalid loader");
    let options;
    if (Array.isArray(loader)) {
      options = loader[1];
      loader = loader[0];
      loader = {
        ...loader,
        options: {
          ...loader.options,
          ...options
        }
      };
    }
    if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
      loader.text = true;
    }
    if (!loader.text) {
      loader.binary = true;
    }
    return loader;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js
  var getGlobalLoaderRegistry = () => {
    const state = getGlobalLoaderState();
    state.loaderRegistry = state.loaderRegistry || [];
    return state.loaderRegistry;
  };
  function registerLoaders(loaders) {
    const loaderRegistry = getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    for (const loader of loaders) {
      const normalizedLoader = normalizeLoader(loader);
      if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
        loaderRegistry.unshift(normalizedLoader);
      }
    }
  }
  function getRegisteredLoaders() {
    return getGlobalLoaderRegistry();
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js
  var log = new Log({
    id: "loaders.gl"
  });

  // node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js
  var EXT_PATTERN = /\.([^.]+)$/;
  async function selectLoader(data) {
    let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    if (!validHTTPResponse(data)) {
      return null;
    }
    let loader = selectLoaderSync(data, loaders, {
      ...options,
      nothrow: true
    }, context);
    if (loader) {
      return loader;
    }
    if (isBlob(data)) {
      data = await data.slice(0, 10).arrayBuffer();
      loader = selectLoaderSync(data, loaders, options, context);
    }
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderSync(data) {
    let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let options = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    if (!validHTTPResponse(data)) {
      return null;
    }
    if (loaders && !Array.isArray(loaders)) {
      return normalizeLoader(loaders);
    }
    let candidateLoaders = [];
    if (loaders) {
      candidateLoaders = candidateLoaders.concat(loaders);
    }
    if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {
      candidateLoaders.push(...getRegisteredLoaders());
    }
    normalizeLoaders(candidateLoaders);
    const loader = selectLoaderInternal(data, candidateLoaders, options, context);
    if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderInternal(data, loaders, options, context) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    const testUrl = stripQueryString(url) || (context === null || context === void 0 ? void 0 : context.url);
    let loader = null;
    let reason = "";
    if (options !== null && options !== void 0 && options.mimeType) {
      loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);
      reason = "match forced by supplied MIME type ".concat(options === null || options === void 0 ? void 0 : options.mimeType);
    }
    loader = loader || findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? "matched url ".concat(testUrl) : "");
    loader = loader || findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? "matched MIME type ".concat(type) : "");
    loader = loader || findLoaderByInitialBytes(loaders, data);
    reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters(data)) : "");
    loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);
    reason = reason || (loader ? "matched fallback MIME type ".concat(type) : "");
    if (reason) {
      var _loader;
      log.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
    }
    return loader;
  }
  function validHTTPResponse(data) {
    if (data instanceof Response) {
      if (data.status === 204) {
        return false;
      }
    }
    return true;
  }
  function getNoValidLoaderMessage(data) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    let message = "No valid loader found (";
    message += url ? "".concat(path_exports.filename(url), ", ") : "no url provided, ";
    message += "MIME type: ".concat(type ? '"'.concat(type, '"') : "not provided", ", ");
    const firstCharacters = data ? getFirstCharacters(data) : "";
    message += firstCharacters ? ' first bytes: "'.concat(firstCharacters, '"') : "first bytes: not available";
    message += ")";
    return message;
  }
  function normalizeLoaders(loaders) {
    for (const loader of loaders) {
      normalizeLoader(loader);
    }
  }
  function findLoaderByUrl(loaders, url) {
    const match = url && EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? findLoaderByExtension(loaders, extension) : null;
  }
  function findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders) {
      for (const loaderExtension of loader.extensions) {
        if (loaderExtension.toLowerCase() === extension) {
          return loader;
        }
      }
    }
    return null;
  }
  function findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders) {
      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
        return loader;
      }
      if (mimeType === "application/x.".concat(loader.id)) {
        return loader;
      }
    }
    return null;
  }
  function findLoaderByInitialBytes(loaders, data) {
    if (!data) {
      return null;
    }
    for (const loader of loaders) {
      if (typeof data === "string") {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
    return null;
  }
  function testDataAgainstText(data, loader) {
    if (loader.testText) {
      return loader.testText(data);
    }
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => data.startsWith(test));
  }
  function testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => testBinary(data, byteOffset, loader, test));
  }
  function testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) {
      return compareArrayBuffers(test, data, test.byteLength);
    }
    switch (typeof test) {
      case "function":
        return test(data, loader);
      case "string":
        const magic = getMagicString(data, byteOffset, test.length);
        return test === magic;
      default:
        return false;
    }
  }
  function getFirstCharacters(data) {
    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString(data.buffer, data.byteOffset, length);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString(data, byteOffset, length);
    }
    return "";
  }
  function getMagicString(arrayBuffer2, byteOffset, length) {
    if (arrayBuffer2.byteLength < byteOffset + length) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i2 = 0; i2 < length; i2++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i2));
    }
    return magic;
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js
  var DEFAULT_CHUNK_SIZE = 256 * 1024;
  function* makeStringIterator(string, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while (offset < string.length) {
      const chunkLength = Math.min(string.length - offset, chunkSize);
      const chunk = string.slice(offset, offset + chunkLength);
      offset += chunkLength;
      yield textEncoder.encode(chunk);
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js
  var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
  function makeArrayBufferIterator(arrayBuffer2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      const {
        chunkSize = DEFAULT_CHUNK_SIZE2
      } = options;
      let byteOffset = 0;
      while (byteOffset < arrayBuffer2.byteLength) {
        const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
        const chunk = new ArrayBuffer(chunkByteLength);
        const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
        const chunkArray = new Uint8Array(chunk);
        chunkArray.set(sourceArray);
        byteOffset += chunkByteLength;
        yield chunk;
      }
    }();
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js
  var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
  async function* makeBlobIterator(blob, options) {
    const chunkSize = (options === null || options === void 0 ? void 0 : options.chunkSize) || DEFAULT_CHUNK_SIZE3;
    let offset = 0;
    while (offset < blob.size) {
      const end = offset + chunkSize;
      const chunk = await blob.slice(offset, end).arrayBuffer();
      offset = end;
      yield chunk;
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js
  function makeStreamIterator(stream, options) {
    return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
  }
  async function* makeBrowserStreamIterator(stream, options) {
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
      while (true) {
        const currentBatchPromise = nextBatchPromise || reader.read();
        if (options !== null && options !== void 0 && options._streamReadAhead) {
          nextBatchPromise = reader.read();
        }
        const {
          done,
          value
        } = await currentBatchPromise;
        if (done) {
          return;
        }
        yield toArrayBuffer2(value);
      }
    } catch (error2) {
      reader.releaseLock();
    }
  }
  async function* makeNodeStreamIterator(stream, options) {
    for await (const chunk of stream) {
      yield toArrayBuffer2(chunk);
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js
  function makeIterator(data, options) {
    if (typeof data === "string") {
      return makeStringIterator(data, options);
    }
    if (data instanceof ArrayBuffer) {
      return makeArrayBufferIterator(data, options);
    }
    if (isBlob(data)) {
      return makeBlobIterator(data, options);
    }
    if (isReadableStream(data)) {
      return makeStreamIterator(data, options);
    }
    if (isResponse(data)) {
      const response = data;
      return makeStreamIterator(response.body, options);
    }
    throw new Error("makeIterator");
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
  var ERR_DATA = "Cannot convert supplied data type";
  function getArrayBufferOrStringFromDataSync(data, loader, options) {
    if (loader.text && typeof data === "string") {
      return data;
    }
    if (isBuffer2(data)) {
      data = data.buffer;
    }
    if (data instanceof ArrayBuffer) {
      const arrayBuffer2 = data;
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(arrayBuffer2);
      }
      return arrayBuffer2;
    }
    if (ArrayBuffer.isView(data)) {
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(data);
      }
      let arrayBuffer2 = data.buffer;
      const byteLength = data.byteLength || data.length;
      if (data.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
        arrayBuffer2 = arrayBuffer2.slice(data.byteOffset, data.byteOffset + byteLength);
      }
      return arrayBuffer2;
    }
    throw new Error(ERR_DATA);
  }
  async function getArrayBufferOrStringFromData(data, loader, options) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === "string" || isArrayBuffer) {
      return getArrayBufferOrStringFromDataSync(data, loader, options);
    }
    if (isBlob(data)) {
      data = await makeResponse(data);
    }
    if (isResponse(data)) {
      const response = data;
      await checkResponse(response);
      return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if (isReadableStream(data)) {
      data = makeIterator(data, options);
    }
    if (isIterable(data) || isAsyncIterable(data)) {
      return concatenateArrayBuffersAsync(data);
    }
    throw new Error(ERR_DATA);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js
  function getFetchFunction(options, context) {
    const globalOptions = getGlobalLoaderOptions();
    const fetchOptions = options || globalOptions;
    if (typeof fetchOptions.fetch === "function") {
      return fetchOptions.fetch;
    }
    if (isObject(fetchOptions.fetch)) {
      return (url) => fetchFile(url, fetchOptions);
    }
    if (context !== null && context !== void 0 && context.fetch) {
      return context === null || context === void 0 ? void 0 : context.fetch;
    }
    return fetchFile;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js
  function getLoaderContext(context, options, parentContext) {
    if (parentContext) {
      return parentContext;
    }
    const newContext = {
      fetch: getFetchFunction(options, context),
      ...context
    };
    if (newContext.url) {
      const baseUrl = stripQueryString(newContext.url);
      newContext.baseUrl = baseUrl;
      newContext.queryString = extractQueryString(newContext.url);
      newContext.filename = path_exports.filename(baseUrl);
      newContext.baseUrl = path_exports.dirname(baseUrl);
    }
    if (!Array.isArray(newContext.loaders)) {
      newContext.loaders = null;
    }
    return newContext;
  }
  function getLoadersFromContext(loaders, context) {
    if (!context && loaders && !Array.isArray(loaders)) {
      return loaders;
    }
    let candidateLoaders;
    if (loaders) {
      candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
    }
    if (context && context.loaders) {
      const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
      candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
    }
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
  async function parse(data, loaders, options, context) {
    assert2(!context || typeof context === "object");
    if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
      context = void 0;
      options = loaders;
      loaders = void 0;
    }
    data = await data;
    options = options || {};
    const url = getResourceUrl(data);
    const typedLoaders = loaders;
    const candidateLoaders = getLoadersFromContext(typedLoaders, context);
    const loader = await selectLoader(data, candidateLoaders, options);
    if (!loader) {
      return null;
    }
    options = normalizeOptions(options, loader, candidateLoaders, url);
    context = getLoaderContext({
      url,
      parse,
      loaders: candidateLoaders
    }, options, context || null);
    return await parseWithLoader(loader, data, options, context);
  }
  async function parseWithLoader(loader, data, options, context) {
    validateWorkerVersion(loader);
    if (isResponse(data)) {
      const response = data;
      const {
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      } = response;
      const headers = Object.fromEntries(response.headers.entries());
      context.response = {
        headers,
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      };
    }
    data = await getArrayBufferOrStringFromData(data, loader, options);
    if (loader.parseTextSync && typeof data === "string") {
      options.dataType = "text";
      return loader.parseTextSync(data, options, context, loader);
    }
    if (canParseWithWorker(loader, options)) {
      return await parseWithWorker(loader, data, options, context, parse);
    }
    if (loader.parseText && typeof data === "string") {
      return await loader.parseText(data, options, context, loader);
    }
    if (loader.parse) {
      return await loader.parse(data, options, context, loader);
    }
    assert2(!loader.parseSync);
    throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/load.js
  async function load(url, loaders, options, context) {
    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
      context = void 0;
      options = loaders;
      loaders = void 0;
    }
    const fetch2 = getFetchFunction(options);
    let data = url;
    if (typeof url === "string") {
      data = await fetch2(url);
    }
    if (isBlob(url)) {
      data = await fetch2(url);
    }
    return await parse(data, loaders, options);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js
  var VERSION3 = true ? "3.4.14" : "latest";

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
  var {
    _parseImageNode
  } = globalThis;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
  var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer2, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer2);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error2) {
        throw new Error(error2.message);
      }
      const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
      return src;
    }
    return getBlob(arrayBuffer2, url);
  }
  function getBlob(arrayBuffer2, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer2)]);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
  async function parseToImage(arrayBuffer2, options, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
    const URL2 = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options);
    } finally {
      if (objectUrl) {
        URL2.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options) {
    const image = new Image();
    image.src = url;
    if (options.image && options.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve2, reject) => {
      try {
        image.onload = () => resolve2(image);
        image.onerror = (err) => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  async function parseToImageBitmap(arrayBuffer2, options, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer2, options, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer2, url);
    }
    const imagebitmapOptions = options && options.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob) {
    let imagebitmapOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error2) {
        console.warn(error2);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object) {
    for (const key in object || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js
  function getISOBMFFMediaType(buffer) {
    if (!checkString(buffer, "ftyp", 4)) {
      return null;
    }
    if ((buffer[8] & 96) === 0) {
      return null;
    }
    return decodeMajorBrand(buffer);
  }
  function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "avif":
      case "avis":
        return {
          extension: "avif",
          mimeType: "image/avif"
        };
      default:
        return null;
    }
  }
  function getUTF8String(array, start, end) {
    return String.fromCharCode(...array.slice(start, end));
  }
  function stringToBytes(string) {
    return [...string].map((character) => character.charCodeAt(0));
  }
  function checkString(buffer, header) {
    let offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const headerBytes = stringToBytes(header);
    for (let i2 = 0; i2 < headerBytes.length; ++i2) {
      if (headerBytes[i2] !== buffer[i2 + offset]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
  }
  function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = getISOBMFFMediaType(buffer);
    if (!mediaType) {
      return null;
    }
    return {
      mimeType: mediaType.mimeType,
      width: 0,
      height: 0
    };
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const {
      tableMarkers,
      sofMarkers
    } = getJpegMarkers();
    let i2 = 2;
    while (i2 + 9 < dataView.byteLength) {
      const marker = dataView.getUint16(i2, BIG_ENDIAN);
      if (sofMarkers.has(marker)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i2 + 5, BIG_ENDIAN),
          width: dataView.getUint16(i2 + 7, BIG_ENDIAN)
        };
      }
      if (!tableMarkers.has(marker)) {
        return null;
      }
      i2 += 2;
      i2 += dataView.getUint16(i2, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i2 = 65504; i2 < 65520; ++i2) {
      tableMarkers.add(i2);
    }
    const sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
    return {
      tableMarkers,
      sofMarkers
    };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
  async function parseToNodeImage(arrayBuffer2, options) {
    const {
      mimeType
    } = getBinaryImageMetadata(arrayBuffer2) || {};
    const _parseImageNode2 = globalThis._parseImageNode;
    assert(_parseImageNode2);
    return await _parseImageNode2(arrayBuffer2, mimeType);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
  async function parseImage(arrayBuffer2, options, context) {
    options = options || {};
    const imageOptions = options.image || {};
    const imageType = imageOptions.type || "auto";
    const {
      url
    } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer2, options, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer2, options, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer2, options);
        break;
      default:
        assert(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // node_modules/@loaders.gl/images/dist/esm/image-loader.js
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
  var MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
  var DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
      type: "auto",
      decode: true
    }
  };
  var ImageLoader = {
    id: "image",
    module: "images",
    name: "Images",
    version: VERSION3,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
  };

  // node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
  function isElectron2(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent2 = mockUserAgent || realUserAgent;
    if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
  function isBrowser5() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron2();
  }

  // node_modules/@probe.gl/env/dist/esm/lib/globals.js
  var globals3 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document,
    process: typeof process === "object" && process
  };
  var self_4 = globals3.self || globals3.window || globals3.global;
  var window_4 = globals3.window || globals3.self || globals3.global;
  var document_4 = globals3.document || {};
  var process_2 = globals3.process || {};

  // node_modules/@probe.gl/env/dist/esm/utils/globals.js
  var VERSION4 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser6 = isBrowser5();

  // node_modules/@probe.gl/env/dist/esm/lib/get-browser.js
  var window2 = globalThis;
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser5()) {
      return "Node";
    }
    if (isElectron2(mockUserAgent)) {
      return "Electron";
    }
    const navigator_2 = typeof navigator !== "undefined" ? navigator : {};
    const userAgent2 = mockUserAgent || navigator_2.userAgent || "";
    if (userAgent2.indexOf("Edge") > -1) {
      return "Edge";
    }
    const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
    const isTrident = userAgent2.indexOf("Trident/") !== -1;
    if (isMSIE || isTrident) {
      return "IE";
    }
    if (window2.chrome) {
      return "Chrome";
    }
    if (window2.safari) {
      return "Safari";
    }
    if (window2.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
  function getStorage2(type) {
    try {
      const storage = window[type];
      const x2 = "__storage_test__";
      storage.setItem(x2, x2);
      storage.removeItem(x2);
      return storage;
    } catch (e2) {
      return null;
    }
  }
  var LocalStorage2 = class {
    constructor(id, defaultConfig) {
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      _defineProperty(this, "storage", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "config", void 0);
      this.storage = getStorage2(type);
      this.id = id;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // node_modules/@probe.gl/log/dist/esm/utils/formatters.js
  function formatTime2(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad2(string) {
    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length - string.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string);
  }
  function formatImage2(image, message, scale3) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale3 = Math.min(scale3, maxWidth / image.width);
    }
    const width = image.width * scale3;
    const height = image.height * scale3;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
    return ["".concat(message, " %c+"), style];
  }

  // node_modules/@probe.gl/log/dist/esm/utils/color.js
  var COLOR2;
  (function(COLOR3) {
    COLOR3[COLOR3["BLACK"] = 30] = "BLACK";
    COLOR3[COLOR3["RED"] = 31] = "RED";
    COLOR3[COLOR3["GREEN"] = 32] = "GREEN";
    COLOR3[COLOR3["YELLOW"] = 33] = "YELLOW";
    COLOR3[COLOR3["BLUE"] = 34] = "BLUE";
    COLOR3[COLOR3["MAGENTA"] = 35] = "MAGENTA";
    COLOR3[COLOR3["CYAN"] = 36] = "CYAN";
    COLOR3[COLOR3["WHITE"] = 37] = "WHITE";
    COLOR3[COLOR3["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR3[COLOR3["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR3[COLOR3["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR3[COLOR3["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR3[COLOR3["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR3[COLOR3["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR3[COLOR3["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR3[COLOR3["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR2 || (COLOR2 = {}));
  function getColor2(color) {
    return typeof color === "string" ? COLOR2[color.toUpperCase()] || COLOR2.WHITE : color;
  }
  function addColor2(string, color, background) {
    if (!isBrowser5 && typeof string === "string") {
      if (color) {
        color = getColor2(color);
        string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
      }
      if (background) {
        color = getColor2(background);
        string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
      }
    }
    return string;
  }

  // node_modules/@probe.gl/log/dist/esm/utils/autobind.js
  function autobind2(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    for (const key of propNames) {
      if (typeof obj[key] === "function") {
        if (!predefined.find((name) => key === name)) {
          obj[key] = obj[key].bind(obj);
        }
      }
    }
  }

  // node_modules/@probe.gl/log/dist/esm/utils/assert.js
  function assert4(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }

  // node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (isBrowser5 && "performance" in window_4) {
      var _window$performance, _window$performance$n;
      timestamp = window_4 === null || window_4 === void 0 ? void 0 : (_window$performance = window_4.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_2) {
      var _process$hrtime;
      const timeParts = process_2 === null || process_2 === void 0 ? void 0 : (_process$hrtime = process_2.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_2);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // node_modules/@probe.gl/log/dist/esm/log.js
  var originalConsole2 = {
    debug: isBrowser5 ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_SETTINGS = {
    enabled: true,
    level: 0
  };
  function noop2() {
  }
  var cache2 = {};
  var ONCE2 = {
    once: true
  };
  var Log2 = class {
    constructor() {
      let {
        id
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "VERSION", VERSION4);
      _defineProperty(this, "_startTs", getHiResTimestamp2());
      _defineProperty(this, "_deltaTs", getHiResTimestamp2());
      _defineProperty(this, "_storage", void 0);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
      this.id = id;
      this.userData = {};
      this._storage = new LocalStorage2("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
      this.timeStamp("".concat(this.id, " started"));
      autobind2(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.setConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value) {
      this._storage.setConfiguration({
        [setting]: value
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message) {
      assert4(condition, message);
    }
    warn(message) {
      return this._getLogFunction(0, message, originalConsole2.warn, arguments, ONCE2);
    }
    error(message) {
      return this._getLogFunction(0, message, originalConsole2.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole2.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message) {
      return this._getLogFunction(logLevel, message, originalConsole2.debug, arguments);
    }
    info(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.info, arguments);
    }
    once(logLevel, message) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return this._getLogFunction(logLevel, message, originalConsole2.debug || originalConsole2.info, arguments, ONCE2);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop2, columns && [columns], {
          tag: getTableHeader2(table)
        });
      }
      return noop2;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message = "",
        scale: scale3 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop2;
      }
      return isBrowser5 ? logImageInBrowser2({
        image,
        message,
        scale: scale3
      }) : logImageInNode2({
        image,
        message,
        scale: scale3
      });
    }
    time(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message) {
      return this._getLogFunction(logLevel, message, console.timeStamp || noop2);
    }
    group(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options = normalizeArguments2({
        logLevel,
        message,
        opts
      });
      const {
        collapsed
      } = opts;
      options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options);
    }
    groupCollapsed(logLevel, message) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop2);
    }
    withGroup(logLevel, message, func) {
      this.group(logLevel, message)();
      try {
        func();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel2(logLevel);
    }
    _getLogFunction(logLevel, message, method, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments2({
          logLevel,
          message,
          args,
          opts
        });
        method = method || opts.method;
        assert4(method);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp2();
        const tag = opts.tag || opts.message;
        if (opts.once) {
          if (!cache2[tag]) {
            cache2[tag] = getHiResTimestamp2();
          } else {
            return noop2;
          }
        }
        message = decorateMessage2(this.id, opts.message, opts);
        return method.bind(console, message, ...opts.args);
      }
      return noop2;
    }
  };
  _defineProperty(Log2, "VERSION", VERSION4);
  function normalizeLogLevel2(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert4(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments2(opts) {
    const {
      logLevel,
      message
    } = opts;
    opts.logLevel = normalizeLogLevel2(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message !== void 0) {
          args.unshift(message);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert4(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage2(id, message, opts) {
    if (typeof message === "string") {
      const time = opts.time ? leftPad2(formatTime2(opts.total)) : "";
      message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
      message = addColor2(message, opts.color, opts.background);
    }
    return message;
  }
  function logImageInNode2(_ref2) {
    let {
      image,
      message = "",
      scale: scale3 = 1
    } = _ref2;
    console.warn("removed");
    return noop2;
  }
  function logImageInBrowser2(_ref3) {
    let {
      image,
      message = "",
      scale: scale3 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage2(img, message, scale3);
        console.log(...args);
      };
      img.src = image;
      return noop2;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage2(image, message, scale3));
      return noop2;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage2(img, message, scale3));
      img.src = image.toDataURL();
      return noop2;
    }
    return noop2;
  }
  function getTableHeader2(table) {
    for (const key in table) {
      for (const title in table[key]) {
        return title || "untitled";
      }
    }
    return "empty";
  }

  // node_modules/@probe.gl/log/dist/esm/index.js
  var esm_default = new Log2({
    id: "@probe.gl/log"
  });

  // node_modules/@deck.gl/core/dist/esm/utils/log.js
  var log_default = new Log2({
    id: "deck"
  });

  // node_modules/@deck.gl/core/dist/esm/debug/loggers.js
  var logState = {
    attributeUpdateStart: -1,
    attributeManagerUpdateStart: -1,
    attributeUpdateMessages: []
  };
  var LOG_LEVEL_MAJOR_UPDATE = 1;
  var LOG_LEVEL_MINOR_UPDATE = 2;
  var LOG_LEVEL_UPDATE_DETAIL = 3;
  var LOG_LEVEL_INFO = 4;
  var LOG_LEVEL_DRAW = 2;
  var getLoggers = (log4) => ({
    "layer.changeFlag": (layer, key, flags) => {
      log4.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
    },
    "layer.initialize": (layer) => {
      log4.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
    },
    "layer.update": (layer, needsUpdate) => {
      if (needsUpdate) {
        const flags = layer.getChangeFlags();
        log4.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter((key) => flags[key]).join(", ")))();
      } else {
        log4.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
      }
    },
    "layer.matched": (layer, changed) => {
      if (changed) {
        log4.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
      }
    },
    "layer.finalize": (layer) => {
      log4.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
    },
    "compositeLayer.renderLayers": (layer, updated, subLayers) => {
      if (updated) {
        log4.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
      } else {
        log4.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
      }
    },
    "layerManager.setLayers": (layerManager, updated, layers) => {
      if (updated) {
        log4.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
      }
    },
    "layerManager.activateViewport": (layerManager, viewport) => {
      log4.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
    },
    "attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
      log4.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
    },
    "attributeManager.updateStart": (attributeManager) => {
      logState.attributeUpdateMessages.length = 0;
      logState.attributeManagerUpdateStart = Date.now();
    },
    "attributeManager.updateEnd": (attributeManager, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
      log4.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();
      for (const updateMessage of logState.attributeUpdateMessages) {
        log4.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
      }
      log4.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
    },
    "attribute.updateStart": (attribute) => {
      logState.attributeUpdateStart = Date.now();
    },
    "attribute.allocate": (attribute, numInstances) => {
      const message = "".concat(attribute.id, " allocated ").concat(numInstances);
      logState.attributeUpdateMessages.push(message);
    },
    "attribute.updateEnd": (attribute, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
      const message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
      logState.attributeUpdateMessages.push(message);
    },
    "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
      const {
        pass,
        redrawReason,
        stats
      } = opts;
      for (const status of renderStats) {
        const {
          totalCount,
          visibleCount,
          compositeCount,
          pickableCount
        } = status;
        const primitiveCount = totalCount - compositeCount;
        const hiddenCount = primitiveCount - visibleCount;
        log4.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();
        if (stats) {
          stats.get("Redraw Layers").add(visibleCount);
        }
      }
    }
  });

  // node_modules/@deck.gl/core/dist/esm/debug/index.js
  var loggers = {};
  if (true) {
    loggers = getLoggers(log_default);
  }
  function register(handlers) {
    loggers = handlers;
  }
  function debug(eventType, arg1, arg2, arg3) {
    if (log_default.level > 0 && loggers[eventType]) {
      loggers[eventType].call(null, arg1, arg2, arg3);
    }
  }

  // node_modules/@deck.gl/core/dist/esm/utils/json-loader.js
  function isJSON(text) {
    const firstChar = text[0];
    const lastChar = text[text.length - 1];
    return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
  }
  var json_loader_default = {
    id: "JSON",
    name: "JSON",
    module: "",
    version: "",
    options: {},
    extensions: ["json", "geojson"],
    mimeTypes: ["application/json", "application/geo+json"],
    testText: isJSON,
    parseTextSync: JSON.parse
  };

  // node_modules/@deck.gl/core/dist/esm/lib/init.js
  function checkVersion() {
    const version = true ? "8.9.34" : globalThis.DECK_VERSION || "untranspiled source";
    const existingVersion = globalThis.deck && globalThis.deck.VERSION;
    if (existingVersion && existingVersion !== version) {
      throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
    }
    if (!existingVersion) {
      log_default.log(1, "deck.gl ".concat(version))();
      globalThis.deck = {
        ...globalThis.deck,
        VERSION: version,
        version,
        log: log_default,
        _registerLoggers: register
      };
      registerLoaders([json_loader_default, [ImageLoader, {
        imagebitmap: {
          premultiplyAlpha: "none"
        }
      }]]);
    }
    return version;
  }
  var VERSION5 = checkVersion();

  // node_modules/@deck.gl/core/dist/esm/lib/constants.js
  var COORDINATE_SYSTEM = {
    DEFAULT: -1,
    LNGLAT: 1,
    METER_OFFSETS: 2,
    LNGLAT_OFFSETS: 3,
    CARTESIAN: 0
  };
  Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
    get: () => {
      log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
      return 0;
    }
  });
  var PROJECTION_MODE = {
    WEB_MERCATOR: 1,
    GLOBE: 2,
    WEB_MERCATOR_AUTO_OFFSET: 4,
    IDENTITY: 0
  };
  var UNIT = {
    common: 0,
    meters: 1,
    pixels: 2
  };
  var EVENTS = {
    click: {
      handler: "onClick"
    },
    panstart: {
      handler: "onDragStart"
    },
    panmove: {
      handler: "onDrag"
    },
    panend: {
      handler: "onDragEnd"
    }
  };

  // node_modules/@luma.gl/gltools/dist/esm/utils/log.js
  var log2 = new Log2({
    id: "luma.gl"
  });

  // node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
  function assert5(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
  var ERR_CONTEXT = "Invalid WebGLRenderingContext";
  var ERR_WEBGL2 = "Requires WebGL2";
  function isWebGL(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getWebGL2Context(gl) {
    return isWebGL2(gl) ? gl : null;
  }
  function assertWebGLContext(gl) {
    assert5(isWebGL(gl), ERR_CONTEXT);
    return gl;
  }
  function assertWebGL2Context(gl) {
    assert5(isWebGL2(gl), ERR_WEBGL2);
    return gl;
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
  var glErrorShadow = {};
  function error(msg) {
    if (globalThis.console && globalThis.console.error) {
      globalThis.console.error(msg);
    }
  }
  function log3(msg) {
    if (globalThis.console && globalThis.console.log) {
      globalThis.console.log(msg);
    }
  }
  function synthesizeGLError(err, opt_msg) {
    glErrorShadow[err] = true;
    if (opt_msg !== void 0) {
      error(opt_msg);
    }
  }
  function wrapGLError(gl) {
    const f2 = gl.getError;
    gl.getError = function getError() {
      let err;
      do {
        err = f2.apply(gl);
        if (err !== 0) {
          glErrorShadow[err] = true;
        }
      } while (err !== 0);
      for (err in glErrorShadow) {
        if (glErrorShadow[err]) {
          delete glErrorShadow[err];
          return parseInt(err, 10);
        }
      }
      return 0;
    };
  }
  var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
    const gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for (let n2 = 0; n2 < this.attribs.length; n2++) {
      const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
      this.attribs[n2] = attrib;
    }
    this.maxAttrib = 0;
  };
  WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
  };
  WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
  };
  var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
    const self2 = this;
    this.gl = gl;
    wrapGLError(gl);
    const original = this.original = {
      getParameter: gl.getParameter,
      enableVertexAttribArray: gl.enableVertexAttribArray,
      disableVertexAttribArray: gl.disableVertexAttribArray,
      bindBuffer: gl.bindBuffer,
      getVertexAttrib: gl.getVertexAttrib,
      vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
      if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
        if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
          return null;
        }
        return self2.currentVertexArrayObject;
      }
      return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = true;
      return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index);
      const attrib = vao.attribs[index];
      attrib.enabled = false;
      return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer(target, buffer) {
      switch (target) {
        case 34962:
          self2.currentArrayBuffer = buffer;
          break;
        case 34963:
          self2.currentVertexArrayObject.elementArrayBuffer = buffer;
          break;
        default:
      }
      return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib(index, pname) {
      const vao = self2.currentVertexArrayObject;
      const attrib = vao.attribs[index];
      switch (pname) {
        case 34975:
          return attrib.buffer;
        case 34338:
          return attrib.enabled;
        case 34339:
          return attrib.size;
        case 34340:
          return attrib.stride;
        case 34341:
          return attrib.type;
        case 34922:
          return attrib.normalized;
        default:
          return original.getVertexAttrib.apply(this, arguments);
      }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, indx);
      const attrib = vao.attribs[indx];
      attrib.buffer = self2.currentArrayBuffer;
      attrib.size = size;
      attrib.type = type;
      attrib.normalized = normalized;
      attrib.stride = stride;
      attrib.offset = offset;
      attrib.recache();
      return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) {
      gl.instrumentExtension(this, "OES_vertex_array_object");
    }
    if (gl.canvas) {
      gl.canvas.addEventListener("webglcontextrestored", () => {
        log3("OESVertexArrayObject emulation library context restored");
        self2.reset_();
      }, true);
    }
    this.reset_();
  };
  OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
  OESVertexArrayObject.prototype.reset_ = function reset_() {
    const contextWasLost = this.vertexArrayObjects !== void 0;
    if (contextWasLost) {
      for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
        this.vertexArrayObjects.isAlive = false;
      }
    }
    const gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [this.defaultVertexArrayObject];
    this.bindVertexArrayOES(null);
  };
  OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    const arrayObject = new WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
  };
  OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) {
      this.bindVertexArrayOES(null);
    }
  };
  OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
      if (arrayObject.hasBeenBound && arrayObject.ext === this) {
        return true;
      }
    }
    return false;
  };
  OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    const gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
      synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
      return;
    }
    const original = this.original;
    const oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    const newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) {
      return;
    }
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
      original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    }
    let currentBinding = this.currentArrayBuffer;
    const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for (let n2 = 0; n2 <= maxAttrib; n2++) {
      const attrib = newVAO.attribs[n2];
      const oldAttrib = oldVAO ? oldVAO.attribs[n2] : null;
      if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
        if (attrib.enabled) {
          original.enableVertexAttribArray.call(gl, n2);
        } else {
          original.disableVertexAttribArray.call(gl, n2);
        }
      }
      if (attrib.enabled) {
        let bufferChanged = false;
        if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
          if (currentBinding !== attrib.buffer) {
            original.bindBuffer.call(gl, 34962, attrib.buffer);
            currentBinding = attrib.buffer;
          }
          bufferChanged = true;
        }
        if (bufferChanged || attrib.cached !== oldAttrib.cached) {
          original.vertexAttribPointer.call(gl, n2, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
      }
    }
    if (this.currentArrayBuffer !== currentBinding) {
      original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
    }
  };
  function polyfillVertexArrayObject(gl) {
    if (typeof gl.createVertexArray === "function") {
      return;
    }
    const original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
      const list = original_getSupportedExtensions.call(this) || [];
      if (list.indexOf("OES_vertex_array_object") < 0) {
        list.push("OES_vertex_array_object");
      }
      return list;
    };
    const original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name) {
      const ext = original_getExtension.call(this, name);
      if (ext) {
        return ext;
      }
      if (name !== "OES_vertex_array_object") {
        return null;
      }
      if (!gl.__OESVertexArrayObject) {
        this.__OESVertexArrayObject = new OESVertexArrayObject(this);
      }
      return this.__OESVertexArrayObject;
    };
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
  var OES_element_index = "OES_element_index";
  var WEBGL_draw_buffers = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
  var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
  var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
  var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
  var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
  var GL_DONT_CARE = 4352;
  var GL_GPU_DISJOINT_EXT = 36795;
  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  var GL_UNMASKED_VENDOR_WEBGL = 37445;
  var GL_UNMASKED_RENDERER_WEBGL = 37446;
  var getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
  var WEBGL_PARAMETERS = {
    [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
    [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
    [35977]: getWebGL2ValueOrZero,
    [32937]: getWebGL2ValueOrZero,
    [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
      const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
      return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
    },
    [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
    },
    [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
    },
    [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
      const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
      return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    },
    [32883]: getWebGL2ValueOrZero,
    [35071]: getWebGL2ValueOrZero,
    [37447]: getWebGL2ValueOrZero,
    [36063]: (gl, getParameter) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
      }
      return void 0;
    },
    [35379]: getWebGL2ValueOrZero,
    [35374]: getWebGL2ValueOrZero,
    [35377]: getWebGL2ValueOrZero,
    [34852]: (gl) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
      }
      return void 0;
    },
    [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
    [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
    [33e3]: (gl) => 16777216,
    [37157]: getWebGL2ValueOrZero,
    [35373]: getWebGL2ValueOrZero,
    [35657]: getWebGL2ValueOrZero,
    [36183]: getWebGL2ValueOrZero,
    [37137]: getWebGL2ValueOrZero,
    [34045]: getWebGL2ValueOrZero,
    [35978]: getWebGL2ValueOrZero,
    [35979]: getWebGL2ValueOrZero,
    [35968]: getWebGL2ValueOrZero,
    [35376]: getWebGL2ValueOrZero,
    [35375]: getWebGL2ValueOrZero,
    [35659]: getWebGL2ValueOrZero,
    [37154]: getWebGL2ValueOrZero,
    [35371]: getWebGL2ValueOrZero,
    [35658]: getWebGL2ValueOrZero,
    [35076]: getWebGL2ValueOrZero,
    [35077]: getWebGL2ValueOrZero,
    [35380]: getWebGL2ValueOrZero
  };
  function getParameterPolyfill(gl, originalGetParameter, pname) {
    const limit = WEBGL_PARAMETERS[pname];
    const value = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    const result = value !== void 0 ? value : originalGetParameter(pname);
    return result;
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
  var OES_vertex_array_object = "OES_vertex_array_object";
  var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
  var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
  var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
  var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
  function getExtensionData(gl, extension) {
    return {
      webgl2: isWebGL2(gl),
      ext: gl.getExtension(extension)
    };
  }
  var WEBGL2_CONTEXT_POLYFILLS = {
    [OES_vertex_array_object]: {
      meta: {
        suffix: "OES"
      },
      createVertexArray: () => {
        assert5(false, ERR_VAO_NOT_SUPPORTED);
      },
      deleteVertexArray: () => {
      },
      bindVertexArray: () => {
      },
      isVertexArray: () => false
    },
    [ANGLE_instanced_arrays]: {
      meta: {
        suffix: "ANGLE"
      },
      vertexAttribDivisor(location, divisor) {
        assert5(divisor === 0, "WebGL instanced rendering not supported");
      },
      drawElementsInstanced: () => {
      },
      drawArraysInstanced: () => {
      }
    },
    [WEBGL_draw_buffers2]: {
      meta: {
        suffix: "WEBGL"
      },
      drawBuffers: () => {
        assert5(false);
      }
    },
    [EXT_disjoint_timer_query2]: {
      meta: {
        suffix: "EXT"
      },
      createQuery: () => {
        assert5(false);
      },
      deleteQuery: () => {
        assert5(false);
      },
      beginQuery: () => {
        assert5(false);
      },
      endQuery: () => {
      },
      getQuery(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryParameter(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryObject: () => {
      }
    }
  };
  var WEBGL2_CONTEXT_OVERRIDES = {
    readBuffer: (gl, originalFunc, attachment) => {
      if (isWebGL2(gl)) {
        originalFunc(attachment);
      } else {
      }
    },
    getVertexAttrib: (gl, originalFunc, location, pname) => {
      const {
        webgl2,
        ext
      } = getExtensionData(gl, ANGLE_instanced_arrays);
      let result;
      switch (pname) {
        case 35069:
          result = !webgl2 ? false : void 0;
          break;
        case 35070:
          result = !webgl2 && !ext ? 0 : void 0;
          break;
        default:
      }
      return result !== void 0 ? result : originalFunc(location, pname);
    },
    getProgramParameter: (gl, originalFunc, program, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 35967:
            return 35981;
          case 35971:
            return 0;
          case 35382:
            return 0;
          default:
        }
      }
      return originalFunc(program, pname);
    },
    getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 32937:
            return new Int32Array([0]);
          default:
        }
      }
      return gl.getInternalformatParameter(target, format, pname);
    },
    getTexParameter(gl, originalFunc, target, pname) {
      switch (pname) {
        case 34046:
          const {
            extensions
          } = gl.luma;
          const ext = extensions[EXT_texture_filter_anisotropic2];
          pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
          break;
        default:
      }
      return originalFunc(target, pname);
    },
    getParameter: getParameterPolyfill,
    hint(gl, originalFunc, pname, value) {
      return originalFunc(pname, value);
    }
  };

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
  function polyfillContext(gl) {
    gl.luma = gl.luma || {};
    const {
      luma
    } = gl;
    if (!luma.polyfilled) {
      polyfillVertexArrayObject(gl);
      initializeExtensions(gl);
      installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
      installOverrides(gl, {
        target: luma,
        target2: gl
      });
      luma.polyfilled = true;
    }
    return gl;
  }
  globalThis.polyfillContext = polyfillContext;
  function initializeExtensions(gl) {
    gl.luma.extensions = {};
    const EXTENSIONS2 = gl.getSupportedExtensions() || [];
    for (const extension of EXTENSIONS2) {
      gl.luma[extension] = gl.getExtension(extension);
    }
  }
  function installOverrides(gl, _ref) {
    let {
      target,
      target2
    } = _ref;
    Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
      if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
        const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
        };
        const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    });
  }
  function installPolyfills(gl, polyfills) {
    for (const extension of Object.getOwnPropertyNames(polyfills)) {
      if (extension !== "overrides") {
        polyfillExtension(gl, {
          extension,
          target: gl.luma,
          target2: gl
        });
      }
    }
  }
  function polyfillExtension(gl, _ref2) {
    let {
      extension,
      target,
      target2
    } = _ref2;
    const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
    assert5(defaults);
    const {
      meta = {}
    } = defaults;
    const {
      suffix = ""
    } = meta;
    const ext = gl.getExtension(extension);
    for (const key of Object.keys(defaults)) {
      const extKey = "".concat(key).concat(suffix);
      let polyfill = null;
      if (key === "meta") {
      } else if (typeof gl[key] === "function") {
      } else if (ext && typeof ext[extKey] === "function") {
        polyfill = function() {
          return ext[extKey](...arguments);
        };
      } else if (typeof defaults[key] === "function") {
        polyfill = defaults[key].bind(target);
      }
      if (polyfill) {
        target[key] = polyfill;
        target2[key] = polyfill;
      }
    }
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
  var GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([0, 0, 0, 0]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([0, 0, 0, 0]),
    [3107]: [true, true, true, true],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([0, 1]),
    [2930]: true,
    [3024]: true,
    [36006]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32938]: 1,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([0, 0, 1024, 1024]),
    [2960]: false,
    [2961]: 0,
    [2968]: 4294967295,
    [36005]: 4294967295,
    [2962]: 519,
    [2967]: 0,
    [2963]: 4294967295,
    [34816]: 519,
    [36003]: 0,
    [36004]: 4294967295,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [0, 0, 1024, 1024],
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
  };
  var enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value, key) => gl.hint(key, value);
  var pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
  var drawFramebuffer = (gl, value) => {
    const target = isWebGL2(gl) ? 36009 : 36160;
    return gl.bindFramebuffer(target, value);
  };
  var readFramebuffer = (gl, value) => {
    return gl.bindFramebuffer(36008, value);
  };
  function isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array);
  }
  var GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value) => gl.blendColor(...value),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value) => gl.clearColor(...value),
    [3107]: (gl, value) => gl.colorMask(...value),
    [2884]: enable,
    [2885]: (gl, value) => gl.cullFace(value),
    [2929]: enable,
    [2931]: (gl, value) => gl.clearDepth(value),
    [2932]: (gl, value) => gl.depthFunc(value),
    [2928]: (gl, value) => gl.depthRange(...value),
    [2930]: (gl, value) => gl.depthMask(value),
    [3024]: enable,
    [35723]: hint,
    [36006]: drawFramebuffer,
    [2886]: (gl, value) => gl.frontFace(value),
    [33170]: hint,
    [2849]: (gl, value) => gl.lineWidth(value),
    [32823]: enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: enable,
    [3088]: (gl, value) => gl.scissor(...value),
    [2960]: enable,
    [2961]: (gl, value) => gl.clearStencil(value),
    [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
    [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value) => gl.viewport(...value),
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [36010]: readFramebuffer,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value) => gl.blendColor(...value),
    blendEquation: (gl, args) => {
      args = isArray(args) ? args : [args, args];
      gl.blendEquationSeparate(...args);
    },
    blendFunc: (gl, args) => {
      args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...args);
    },
    clearColor: (gl, value) => gl.clearColor(...value),
    clearDepth: (gl, value) => gl.clearDepth(value),
    clearStencil: (gl, value) => gl.clearStencil(value),
    colorMask: (gl, value) => gl.colorMask(...value),
    cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value) => gl.cullFace(value),
    depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value) => gl.depthFunc(value),
    depthMask: (gl, value) => gl.depthMask(value),
    depthRange: (gl, value) => gl.depthRange(...value),
    dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value) => {
      gl.hint(35723, value);
    },
    frontFace: (gl, value) => gl.frontFace(value),
    mipmapHint: (gl, value) => gl.hint(33170, value),
    lineWidth: (gl, value) => gl.lineWidth(value),
    polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value) => gl.polygonOffset(...value),
    sampleCoverage: (gl, value) => gl.sampleCoverage(...value),
    scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value) => gl.scissor(...value),
    stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value) => {
      value = isArray(value) ? value : [value, value];
      const [mask, backMask] = value;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [func, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028, func, ref, mask);
      gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value) => gl.viewport(...value)
  };
  function getValue(glEnum, values, cache3) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache3[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values, cache3) => gl.blendEquationSeparate(getValue(32777, values, cache3), getValue(34877, values, cache3)),
    blendFunc: (gl, values, cache3) => gl.blendFuncSeparate(getValue(32969, values, cache3), getValue(32968, values, cache3), getValue(32971, values, cache3), getValue(32970, values, cache3)),
    polygonOffset: (gl, values, cache3) => gl.polygonOffset(getValue(32824, values, cache3), getValue(10752, values, cache3)),
    sampleCoverage: (gl, values, cache3) => gl.sampleCoverage(getValue(32938, values, cache3), getValue(32939, values, cache3)),
    stencilFuncFront: (gl, values, cache3) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache3), getValue(2967, values, cache3), getValue(2963, values, cache3)),
    stencilFuncBack: (gl, values, cache3) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache3), getValue(36003, values, cache3), getValue(36004, values, cache3)),
    stencilOpFront: (gl, values, cache3) => gl.stencilOpSeparate(1028, getValue(2964, values, cache3), getValue(2965, values, cache3), getValue(2966, values, cache3)),
    stencilOpBack: (gl, values, cache3) => gl.stencilOpSeparate(1029, getValue(34817, values, cache3), getValue(34818, values, cache3), getValue(34819, values, cache3))
  };
  var GL_HOOKED_SETTERS = {
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value) => update({
      [pname]: value
    }),
    hint: (update, pname, hint2) => update({
      [pname]: hint2
    }),
    bindFramebuffer: (update, target, framebuffer) => {
      switch (target) {
        case 36160:
          return update({
            [36006]: framebuffer,
            [36010]: framebuffer
          });
        case 36009:
          return update({
            [36006]: framebuffer
          });
        case 36008:
          return update({
            [36010]: framebuffer
          });
        default:
          return null;
      }
    },
    blendColor: (update, r2, g2, b2, a2) => update({
      [32773]: new Float32Array([r2, g2, b2, a2])
    }),
    blendEquation: (update, mode) => update({
      [32777]: mode,
      [34877]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777]: modeRGB,
      [34877]: modeAlpha
    }),
    blendFunc: (update, src, dst) => update({
      [32969]: src,
      [32968]: dst,
      [32971]: src,
      [32970]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969]: srcRGB,
      [32968]: dstRGB,
      [32971]: srcAlpha,
      [32970]: dstAlpha
    }),
    clearColor: (update, r2, g2, b2, a2) => update({
      [3106]: new Float32Array([r2, g2, b2, a2])
    }),
    clearDepth: (update, depth) => update({
      [2931]: depth
    }),
    clearStencil: (update, s) => update({
      [2961]: s
    }),
    colorMask: (update, r2, g2, b2, a2) => update({
      [3107]: [r2, g2, b2, a2]
    }),
    cullFace: (update, mode) => update({
      [2885]: mode
    }),
    depthFunc: (update, func) => update({
      [2932]: func
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930]: mask
    }),
    frontFace: (update, face) => update({
      [2886]: face
    }),
    lineWidth: (update, width) => update({
      [2849]: width
    }),
    polygonOffset: (update, factor, units) => update({
      [32824]: factor,
      [10752]: units
    }),
    sampleCoverage: (update, value, invert2) => update({
      [32938]: value,
      [32939]: invert2
    }),
    scissor: (update, x2, y2, width, height) => update({
      [3088]: new Int32Array([x2, y2, width, height])
    }),
    stencilMask: (update, mask) => update({
      [2968]: mask,
      [36005]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 ? 2968 : 36005]: mask
    }),
    stencilFunc: (update, func, ref, mask) => update({
      [2962]: func,
      [2967]: ref,
      [2963]: mask,
      [34816]: func,
      [36003]: ref,
      [36004]: mask
    }),
    stencilFuncSeparate: (update, face, func, ref, mask) => update({
      [face === 1028 ? 2962 : 34816]: func,
      [face === 1028 ? 2967 : 36003]: ref,
      [face === 1028 ? 2963 : 36004]: mask
    }),
    stencilOp: (update, fail, zfail, zpass) => update({
      [2964]: fail,
      [2965]: zfail,
      [2966]: zpass,
      [34817]: fail,
      [34818]: zfail,
      [34819]: zpass
    }),
    stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
      [face === 1028 ? 2964 : 34817]: fail,
      [face === 1028 ? 2965 : 34818]: zfail,
      [face === 1028 ? 2966 : 34819]: zpass
    }),
    viewport: (update, x2, y2, width, height) => update({
      [2978]: [x2, y2, width, height]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
  };

  // node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
  function isObjectEmpty(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }
  function deepArrayEqual(x2, y2) {
    if (x2 === y2) {
      return true;
    }
    const isArrayX = Array.isArray(x2) || ArrayBuffer.isView(x2);
    const isArrayY = Array.isArray(y2) || ArrayBuffer.isView(y2);
    if (isArrayX && isArrayY && x2.length === y2.length) {
      for (let i2 = 0; i2 < x2.length; ++i2) {
        if (x2[i2] !== y2[i2]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get() {
      const pname = arguments.length <= 0 ? void 0 : arguments[0];
      if (!(pname in gl.state.cache)) {
        return originalGetterFunc(...arguments);
      }
      return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-from-cache"),
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      const {
        valueChanged,
        oldValue
      } = setter(gl.state._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-to-cache"),
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      if (gl.state.program !== handle) {
        originalUseProgram(handle);
        gl.state.program = handle;
      }
    };
  }
  var GLState = class {
    constructor(gl) {
      let {
        copyState = false,
        log: log4 = () => {
        }
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.program = null;
      this.stateStack = [];
      this.enable = true;
      this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log4;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push() {
      let values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.stateStack.push({});
    }
    pop() {
      assert5(this.stateStack.length > 0);
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    _updateCache(values) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
      for (const key in values) {
        assert5(key !== void 0);
        const value = values[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value;
        }
      }
      return {
        valueChanged,
        oldValue
      };
    }
  };
  function trackContextState(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      enable: enable2 = true,
      copyState
    } = options;
    assert5(copyState !== void 0);
    if (!gl.state) {
      const {
        polyfillContext: polyfillContext2
      } = globalThis;
      if (polyfillContext2) {
        polyfillContext2(gl);
      }
      gl.state = new GLState(gl, {
        copyState
      });
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    gl.state.enable = enable2;
    return gl;
  }
  function pushContextState(gl) {
    if (!gl.state) {
      trackContextState(gl, {
        copyState: false
      });
    }
    gl.state.push();
  }
  function popContextState(gl) {
    assert5(gl.state);
    gl.state.pop();
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
  function setParameters(gl, values) {
    assert5(isWebGL(gl), "setParameters requires a WebGL context");
    if (isObjectEmpty(values)) {
      return;
    }
    const compositeSetters = {};
    for (const key in values) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, values[key], glConstant);
        }
      }
    }
    const cache3 = gl.state && gl.state.cache;
    if (cache3) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, values, cache3);
      }
    }
  }
  function getParameters(gl, parameters) {
    parameters = parameters || GL_PARAMETER_DEFAULTS;
    if (typeof parameters === "number") {
      const key = parameters;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function resetParameters(gl) {
    setParameters(gl, GL_PARAMETER_DEFAULTS);
  }
  function withParameters(gl, parameters, func) {
    if (isObjectEmpty(parameters)) {
      return func(gl);
    }
    const {
      nocatch = true
    } = parameters;
    pushContextState(gl);
    setParameters(gl, parameters);
    let value;
    if (nocatch) {
      value = func(gl);
      popContextState(gl);
    } else {
      try {
        value = func(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value;
  }

  // node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js
  function cssToDeviceRatio(gl) {
    const {
      luma
    } = gl;
    if (gl.canvas && luma) {
      const cachedSize = luma.canvasSizeInfo;
      const clientWidth = "clientWidth" in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
      return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
    }
    return 1;
  }
  function cssToDevicePixels(gl, cssPixel) {
    let yInvert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const ratio = cssToDeviceRatio(gl);
    const width = gl.drawingBufferWidth;
    const height = gl.drawingBufferHeight;
    return scalePixels(cssPixel, ratio, width, height, yInvert);
  }
  function getDevicePixelRatio(useDevicePixels) {
    const windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
    if (Number.isFinite(useDevicePixels)) {
      return useDevicePixels <= 0 ? 1 : useDevicePixels;
    }
    return useDevicePixels ? windowRatio : 1;
  }
  function scalePixels(pixel, ratio, width, height, yInvert) {
    const x2 = scaleX(pixel[0], ratio, width);
    let y2 = scaleY(pixel[1], ratio, height, yInvert);
    let t2 = scaleX(pixel[0] + 1, ratio, width);
    const xHigh = t2 === width - 1 ? t2 : t2 - 1;
    t2 = scaleY(pixel[1] + 1, ratio, height, yInvert);
    let yHigh;
    if (yInvert) {
      t2 = t2 === 0 ? t2 : t2 + 1;
      yHigh = y2;
      y2 = t2;
    } else {
      yHigh = t2 === height - 1 ? t2 : t2 - 1;
    }
    return {
      x: x2,
      y: y2,
      width: Math.max(xHigh - x2 + 1, 1),
      height: Math.max(yHigh - y2 + 1, 1)
    };
  }
  function scaleX(x2, ratio, width) {
    const r2 = Math.min(Math.round(x2 * ratio), width - 1);
    return r2;
  }
  function scaleY(y2, ratio, height, yInvert) {
    return yInvert ? Math.max(0, height - 1 - Math.round(y2 * ratio)) : Math.min(Math.round(y2 * ratio), height - 1);
  }

  // node_modules/@luma.gl/gltools/dist/esm/context/context.js
  var isBrowser7 = isBrowser5();
  var isPage = isBrowser7 && typeof document !== "undefined";
  var CONTEXT_DEFAULTS = {
    webgl2: true,
    webgl1: true,
    throwOnError: true,
    manageState: true,
    canvas: null,
    debug: false,
    width: 800,
    height: 600
  };
  function createGLContext() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    assert5(isBrowser7, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
    options = Object.assign({}, CONTEXT_DEFAULTS, options);
    const {
      width,
      height
    } = options;
    function onError(message) {
      if (options.throwOnError) {
        throw new Error(message);
      }
      console.error(message);
      return null;
    }
    options.onError = onError;
    let gl;
    const {
      canvas
    } = options;
    const targetCanvas = getCanvas({
      canvas,
      width,
      height,
      onError
    });
    gl = createBrowserContext(targetCanvas, options);
    if (!gl) {
      return null;
    }
    gl = instrumentGLContext(gl, options);
    logInfo(gl);
    return gl;
  }
  function instrumentGLContext(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!gl || gl._instrumented) {
      return gl;
    }
    gl._version = gl._version || getVersion(gl);
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    options = Object.assign({}, CONTEXT_DEFAULTS, options);
    const {
      manageState,
      debug: debug2
    } = options;
    if (manageState) {
      trackContextState(gl, {
        copyState: false,
        log: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return log2.log(1, ...args)();
        }
      });
    }
    if (isBrowser7 && debug2) {
      if (!globalThis.makeDebugContext) {
        log2.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
      } else {
        gl = globalThis.makeDebugContext(gl, options);
        log2.level = Math.max(log2.level, 1);
      }
    }
    gl._instrumented = true;
    return gl;
  }
  function getContextDebugInfo(gl) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    const ext = gl.getExtension("WEBGL_debug_renderer_info");
    const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
    const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
    return {
      vendor: vendorUnmasked || vendorMasked,
      renderer: rendererUnmasked || rendererMasked,
      vendorMasked,
      rendererMasked,
      version: gl.getParameter(7938),
      shadingLanguageVersion: gl.getParameter(35724)
    };
  }
  function resizeGLContext(gl) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (gl.canvas) {
      const devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);
      setDevicePixelRatio(gl, devicePixelRatio, options);
      return;
    }
    const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
    if (ext && "width" in options && "height" in options) {
      ext.resize(options.width, options.height);
    }
  }
  function createBrowserContext(canvas, options) {
    const {
      onError
    } = options;
    let errorMessage = null;
    const onCreateError = (error2) => errorMessage = error2.statusMessage || errorMessage;
    canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
    const {
      webgl1 = true,
      webgl2 = true
    } = options;
    let gl = null;
    if (webgl2) {
      gl = gl || canvas.getContext("webgl2", options);
      gl = gl || canvas.getContext("experimental-webgl2", options);
    }
    if (webgl1) {
      gl = gl || canvas.getContext("webgl", options);
      gl = gl || canvas.getContext("experimental-webgl", options);
    }
    canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) {
      return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
    }
    if (options.onContextLost) {
      canvas.addEventListener("webglcontextlost", options.onContextLost, false);
    }
    if (options.onContextRestored) {
      canvas.addEventListener("webglcontextrestored", options.onContextRestored, false);
    }
    return gl;
  }
  function getCanvas(_ref) {
    let {
      canvas,
      width = 800,
      height = 600,
      onError
    } = _ref;
    let targetCanvas;
    if (typeof canvas === "string") {
      const isPageLoaded = isPage && document.readyState === "complete";
      if (!isPageLoaded) {
        onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
      }
      targetCanvas = document.getElementById(canvas);
    } else if (canvas) {
      targetCanvas = canvas;
    } else {
      targetCanvas = document.createElement("canvas");
      targetCanvas.id = "lumagl-canvas";
      targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : "100%";
      targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : "100%";
      document.body.insertBefore(targetCanvas, document.body.firstChild);
    }
    return targetCanvas;
  }
  function logInfo(gl) {
    const webGL = isWebGL2(gl) ? "WebGL2" : "WebGL1";
    const info = getContextDebugInfo(gl);
    const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
    const debug2 = gl.debug ? " debug" : "";
    log2.info(1, "".concat(webGL).concat(debug2, " context ").concat(driver))();
  }
  function getVersion(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return 2;
    }
    return 1;
  }
  function setDevicePixelRatio(gl, devicePixelRatio, options) {
    let clientWidth = "width" in options ? options.width : gl.canvas.clientWidth;
    let clientHeight = "height" in options ? options.height : gl.canvas.clientHeight;
    if (!clientWidth || !clientHeight) {
      log2.log(1, "Canvas clientWidth/clientHeight is 0")();
      devicePixelRatio = 1;
      clientWidth = gl.canvas.width || 1;
      clientHeight = gl.canvas.height || 1;
    }
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    const cachedSize = gl.luma.canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
      let clampedPixelRatio = devicePixelRatio;
      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
      gl.canvas.width = canvasWidth;
      gl.canvas.height = canvasHeight;
      if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
        log2.warn("Device pixel ratio clamped")();
        clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
        gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
        gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
      }
      Object.assign(gl.luma.canvasSizeInfo, {
        clientWidth,
        clientHeight,
        devicePixelRatio
      });
    }
  }

  // node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp3() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // node_modules/@probe.gl/stats/dist/esm/lib/stat.js
  var Stat = class {
    constructor(name, type) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "sampleSize", 1);
      _defineProperty(this, "time", void 0);
      _defineProperty(this, "count", void 0);
      _defineProperty(this, "samples", void 0);
      _defineProperty(this, "lastTiming", void 0);
      _defineProperty(this, "lastSampleTime", void 0);
      _defineProperty(this, "lastSampleCount", void 0);
      _defineProperty(this, "_count", 0);
      _defineProperty(this, "_time", 0);
      _defineProperty(this, "_samples", 0);
      _defineProperty(this, "_startTime", 0);
      _defineProperty(this, "_timerPending", false);
      this.name = name;
      this.type = type;
      this.reset();
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value) {
      this._count += value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value) {
      this._count -= value;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp3();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp3() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // node_modules/@probe.gl/stats/dist/esm/lib/stats.js
  var Stats = class {
    constructor(options) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "stats", {});
      this.id = options.id;
      this.stats = {};
      this._initializeStats(options.stats);
      Object.seal(this);
    }
    get(name) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const key in this.stats) {
        this.stats[key].reset();
      }
      return this;
    }
    forEach(fn) {
      for (const key in this.stats) {
        fn(this.stats[key]);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }
      const {
        name,
        type
      } = stat;
      if (!this.stats[name]) {
        if (stat instanceof Stat) {
          this.stats[name] = stat;
        } else {
          this.stats[name] = new Stat(name, type);
        }
      }
      return this.stats[name];
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/init.js
  var VERSION6 = true ? "8.5.21" : "untranspiled source";
  var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
  var StatsManager = class {
    constructor() {
      this.stats = /* @__PURE__ */ new Map();
    }
    get(name) {
      if (!this.stats.has(name)) {
        this.stats.set(name, new Stats({
          id: name
        }));
      }
      return this.stats.get(name);
    }
  };
  var lumaStats = new StatsManager();
  if (globalThis.luma && globalThis.luma.VERSION !== VERSION6) {
    throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION6));
  }
  if (!globalThis.luma) {
    if (isBrowser5()) {
      log2.log(1, "luma.gl ".concat(VERSION6, " - ").concat(STARTUP_MESSAGE))();
    }
    globalThis.luma = globalThis.luma || {
      VERSION: VERSION6,
      version: VERSION6,
      log: log2,
      stats: lumaStats,
      globals: {
        modules: {},
        nodeIO: {}
      }
    };
  }
  var init_default = globalThis.luma;

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js
  function requestAnimationFrame2(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
  }
  function cancelAnimationFrame(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
  function assert6(condition, message) {
    if (!condition) {
      throw new Error(message || "luma.gl: assertion failed.");
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
  function getKeyValue(gl, name) {
    if (typeof name !== "string") {
      return name;
    }
    const number = Number(name);
    if (!isNaN(number)) {
      return number;
    }
    name = name.replace(/^.*\./, "");
    const value = gl[name];
    assert6(value !== void 0, "Accessing undefined constant GL.".concat(name));
    return value;
  }
  function getKey(gl, value) {
    value = Number(value);
    for (const key in gl) {
      if (gl[key] === value) {
        return "GL.".concat(key);
      }
    }
    return String(value);
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
  var uidCounters = {};
  function uid() {
    let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
    uidCounters[id] = uidCounters[id] || 1;
    const count2 = uidCounters[id]++;
    return "".concat(id, "-").concat(count2);
  }
  function isPowerOfTwo(n2) {
    assert6(typeof n2 === "number", "Input must be a number");
    return n2 && (n2 & n2 - 1) === 0;
  }
  function isObjectEmpty2(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
  function stubRemovedMethods(instance, className, version, methodNames) {
    const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName) => {
      if (prototype.methodName) {
        return;
      }
      prototype[methodName] = () => {
        log2.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
        throw new Error(methodName);
      };
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
  var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  var Resource = class {
    get [Symbol.toStringTag]() {
      return "Resource";
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      const {
        id,
        userData = {}
      } = opts;
      this.gl = gl;
      this.gl2 = gl;
      this.id = id || uid(this[Symbol.toStringTag]);
      this.userData = userData;
      this._bound = false;
      this._handle = opts.handle;
      if (this._handle === void 0) {
        this._handle = this._createHandle();
      }
      this.byteLength = 0;
      this._addStats();
    }
    toString() {
      return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
    }
    get handle() {
      return this._handle;
    }
    delete() {
      let {
        deleteChildren = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const children = this._handle && this._deleteHandle(this._handle);
      if (this._handle) {
        this._removeStats();
      }
      this._handle = null;
      if (children && deleteChildren) {
        children.filter(Boolean).forEach((child) => child.delete());
      }
      return this;
    }
    bind() {
      let funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
      if (typeof funcOrHandle !== "function") {
        this._bindHandle(funcOrHandle);
        return this;
      }
      let value;
      if (!this._bound) {
        this._bindHandle(this.handle);
        this._bound = true;
        value = funcOrHandle();
        this._bound = false;
        this._bindHandle(null);
      } else {
        value = funcOrHandle();
      }
      return value;
    }
    unbind() {
      this.bind(null);
    }
    getParameter(pname) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      pname = getKeyValue(this.gl, pname);
      assert6(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          const webgl1Default = parameter.webgl1;
          const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
          const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue;
        }
      }
      return this._getParameter(pname, opts);
    }
    getParameters() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        parameters,
        keys
      } = options;
      const PARAMETERS = this.constructor.PARAMETERS || {};
      const isWebgl2 = isWebGL2(this.gl);
      const values = {};
      const parameterKeys = parameters || Object.keys(PARAMETERS);
      for (const pname of parameterKeys) {
        const parameter = PARAMETERS[pname];
        const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (parameterAvailable) {
          const key = keys ? getKey(this.gl, pname) : pname;
          values[key] = this.getParameter(pname, options);
          if (keys && parameter.type === "GLenum") {
            values[key] = getKey(this.gl, values[key]);
          }
        }
      }
      return values;
    }
    setParameter(pname, value) {
      pname = getKeyValue(this.gl, pname);
      assert6(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          throw new Error("Parameter not available on this platform");
        }
        if (parameter.type === "GLenum") {
          value = getKeyValue(value);
        }
      }
      this._setParameter(pname, value);
      return this;
    }
    setParameters(parameters) {
      for (const pname in parameters) {
        this.setParameter(pname, parameters[pname]);
      }
      return this;
    }
    stubRemovedMethods(className, version, methodNames) {
      return stubRemovedMethods(this, className, version, methodNames);
    }
    initialize(opts) {
    }
    _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, opts) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _context() {
      this.gl.luma = this.gl.luma || {};
      return this.gl.luma;
    }
    _addStats() {
      const name = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("Resources Created").incrementCount();
      stats.get("".concat(name, "s Created")).incrementCount();
      stats.get("".concat(name, "s Active")).incrementCount();
    }
    _removeStats() {
      const name = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("".concat(name, "s Active")).decrementCount();
    }
    _trackAllocatedMemory(bytes) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      this._trackAllocatedMemoryForContext(bytes, name);
      this._trackAllocatedMemoryForContext(bytes, name, this.gl.canvas && this.gl.canvas.id);
      this.byteLength = bytes;
    }
    _trackAllocatedMemoryForContext(bytes) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      const stats = lumaStats.get("Memory Usage".concat(id));
      stats.get("GPU Memory").addCount(bytes);
      stats.get("".concat(name, " Memory")).addCount(bytes);
    }
    _trackDeallocatedMemory() {
      let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      this._trackDeallocatedMemoryForContext(name);
      this._trackDeallocatedMemoryForContext(name, this.gl.canvas && this.gl.canvas.id);
      this.byteLength = 0;
    }
    _trackDeallocatedMemoryForContext() {
      let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      let id = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const stats = lumaStats.get("Memory Usage".concat(id));
      stats.get("GPU Memory").subtractCount(this.byteLength);
      stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType) {
    let {
      clamped = true
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }
  function flipRows(_ref) {
    let {
      data,
      width,
      height,
      bytesPerPixel = 4,
      temp
    } = _ref;
    const bytesPerRow = width * bytesPerPixel;
    temp = temp || new Uint8Array(bytesPerRow);
    for (let y2 = 0; y2 < height / 2; ++y2) {
      const topOffset = y2 * bytesPerRow;
      const bottomOffset = (height - y2 - 1) * bytesPerRow;
      temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
      data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      data.set(temp, bottomOffset);
    }
  }
  function scalePixels2(_ref2) {
    let {
      data,
      width,
      height
    } = _ref2;
    const newWidth = Math.round(width / 2);
    const newHeight = Math.round(height / 2);
    const newData = new Uint8Array(newWidth * newHeight * 4);
    for (let y2 = 0; y2 < newHeight; y2++) {
      for (let x2 = 0; x2 < newWidth; x2++) {
        for (let c2 = 0; c2 < 4; c2++) {
          newData[(y2 * newWidth + x2) * 4 + c2] = data[(y2 * 2 * width + x2 * 2) * 4 + c2];
        }
      }
    }
    return {
      data: newData,
      width: newWidth,
      height: newHeight
    };
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
  function checkProps(className, props, propChecks) {
    const {
      removedProps = {},
      deprecatedProps = {},
      replacedProps = {}
    } = propChecks;
    for (const propName in removedProps) {
      if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
        log2.removed("".concat(className, ".").concat(propName), replacement)();
      }
    }
    for (const propName in deprecatedProps) {
      if (propName in props) {
        const replacementProp = deprecatedProps[propName];
        log2.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      }
    }
    let newProps = null;
    for (const propName in replacedProps) {
      if (propName in props) {
        const replacementProp = replacedProps[propName];
        log2.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName];
        delete newProps[propName];
      }
    }
    return newProps || props;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = class _Accessor {
    static getBytesPerElement(accessor) {
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
      assert6(accessor.size);
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve() {
      for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
        accessors[_key] = arguments[_key];
      }
      return new _Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
    }
    constructor() {
      for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        accessors[_key2] = arguments[_key2];
      }
      accessors.forEach((accessor) => this._assign(accessor));
      Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
      return _Accessor.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return _Accessor.getBytesPerVertex(this);
    }
    _assign() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      props = checkProps("Accessor", props, PROP_CHECKS);
      if (props.type !== void 0) {
        this.type = props.type;
        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }
      if (props.size !== void 0) {
        this.size = props.size;
      }
      if (props.offset !== void 0) {
        this.offset = props.offset;
      }
      if (props.stride !== void 0) {
        this.stride = props.stride;
      }
      if (props.normalized !== void 0) {
        this.normalized = props.normalized;
      }
      if (props.integer !== void 0) {
        this.integer = props.integer;
      }
      if (props.divisor !== void 0) {
        this.divisor = props.divisor;
      }
      if (props.buffer !== void 0) {
        this.buffer = props.buffer;
      }
      if (props.index !== void 0) {
        if (typeof props.index === "boolean") {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }
      if (props.instanced !== void 0) {
        this.divisor = props.instanced ? 1 : 0;
      }
      if (props.isInstanced !== void 0) {
        this.divisor = props.isInstanced ? 1 : 0;
      }
      return this;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
  var DEBUG_DATA_LENGTH = 10;
  var DEPRECATED_PROPS = {
    offset: "accessor.offset",
    stride: "accessor.stride",
    type: "accessor.type",
    size: "accessor.size",
    divisor: "accessor.divisor",
    normalized: "accessor.normalized",
    integer: "accessor.integer",
    instanced: "accessor.divisor",
    isInstanced: "accessor.divisor"
  };
  var PROP_CHECKS_INITIALIZE = {
    removedProps: {},
    replacedProps: {
      bytes: "byteLength"
    },
    deprecatedProps: DEPRECATED_PROPS
  };
  var PROP_CHECKS_SET_PROPS = {
    removedProps: DEPRECATED_PROPS
  };
  var Buffer2 = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
      this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
      this.initialize(props);
      Object.seal(this);
    }
    getElementCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
    }
    getVertexCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      if (Number.isFinite(props)) {
        props = {
          byteLength: props
        };
      }
      props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
      this.usage = props.usage || 35044;
      this.debugData = null;
      this.setAccessor(Object.assign({}, props, props.accessor));
      if (props.data) {
        this._setData(props.data, props.offset, props.byteLength);
      } else {
        this._setByteLength(props.byteLength || 0);
      }
      return this;
    }
    setProps(props) {
      props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
      if ("accessor" in props) {
        this.setAccessor(props.accessor);
      }
      return this;
    }
    setAccessor(accessor) {
      accessor = Object.assign({}, accessor);
      delete accessor.buffer;
      this.accessor = new Accessor(accessor);
      return this;
    }
    reallocate(byteLength) {
      if (byteLength > this.byteLength) {
        this._setByteLength(byteLength);
        return true;
      }
      this.bytesUsed = byteLength;
      return false;
    }
    setData(props) {
      return this.initialize(props);
    }
    subData(props) {
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      const {
        data,
        offset = 0,
        srcOffset = 0
      } = props;
      const byteLength = props.byteLength || props.length;
      assert6(data);
      const target = this.gl.webgl2 ? 36663 : this.target;
      this.gl.bindBuffer(target, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        assertWebGL2Context(this.gl);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(target, offset, data);
      }
      this.gl.bindBuffer(target, null);
      this.debugData = null;
      this._inferType(data);
      return this;
    }
    copyData(_ref) {
      let {
        sourceBuffer,
        readOffset = 0,
        writeOffset = 0,
        size
      } = _ref;
      const {
        gl
      } = this;
      assertWebGL2Context(gl);
      gl.bindBuffer(36662, sourceBuffer.handle);
      gl.bindBuffer(36663, this.handle);
      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
      gl.bindBuffer(36662, null);
      gl.bindBuffer(36663, null);
      this.debugData = null;
      return this;
    }
    getData() {
      let {
        dstData = null,
        srcByteOffset = 0,
        dstOffset = 0,
        length = 0
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      assertWebGL2Context(this.gl);
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
      const dstElementOffset = dstOffset;
      let dstAvailableElementCount;
      let dstElementCount;
      if (dstData) {
        dstElementCount = dstData.length;
        dstAvailableElementCount = dstElementCount - dstElementOffset;
      } else {
        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
        dstElementCount = dstElementOffset + dstAvailableElementCount;
      }
      const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
      length = length || copyElementCount;
      assert6(length <= copyElementCount);
      dstData = dstData || new ArrayType(dstElementCount);
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);
      this.gl.bindBuffer(36662, null);
      return dstData;
    }
    bind() {
      let {
        target = this.target,
        index = this.accessor && this.accessor.index,
        offset = 0,
        size
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (target === 35345 || target === 35982) {
        if (size !== void 0) {
          this.gl.bindBufferRange(target, index, this.handle, offset, size);
        } else {
          assert6(offset === 0);
          this.gl.bindBufferBase(target, index, this.handle);
        }
      } else {
        this.gl.bindBuffer(target, this.handle);
      }
      return this;
    }
    unbind() {
      let {
        target = this.target,
        index = this.accessor && this.accessor.index
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const isIndexedBuffer = target === 35345 || target === 35982;
      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target, index, null);
      } else {
        this.gl.bindBuffer(target, null);
      }
      return this;
    }
    getDebugData() {
      if (!this.debugData) {
        this.debugData = this.getData({
          length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
        });
        return {
          data: this.debugData,
          changed: true
        };
      }
      return {
        data: this.debugData,
        changed: false
      };
    }
    invalidateDebugData() {
      this.debugData = null;
    }
    _setData(data) {
      let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data.byteLength + offset;
      assert6(ArrayBuffer.isView(data));
      this._trackDeallocatedMemory();
      const target = this._getTarget();
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, byteLength, this.usage);
      this.gl.bufferSubData(target, offset, data);
      this.gl.bindBuffer(target, null);
      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      const type = getGLTypeFromTypedArray(data);
      assert6(type);
      this.setAccessor(new Accessor(this.accessor, {
        type
      }));
      return this;
    }
    _setByteLength(byteLength) {
      let usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
      assert6(byteLength >= 0);
      this._trackDeallocatedMemory();
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const target = this._getTarget();
      this.gl.bindBuffer(target, this.handle);
      this.gl.bufferData(target, data, usage);
      this.gl.bindBuffer(target, null);
      this.usage = usage;
      this.debugData = null;
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      return this;
    }
    _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
    _getAvailableElementCount(srcByteOffset) {
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
      return this.getElementCount() - sourceElementOffset;
    }
    _inferType(data) {
      if (!this.accessor.type) {
        this.setAccessor(new Accessor(this.accessor, {
          type: getGLTypeFromTypedArray(data)
        }));
      }
    }
    _createHandle() {
      return this.gl.createBuffer();
    }
    _deleteHandle() {
      this.gl.deleteBuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      const value = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value;
    }
    get type() {
      log2.deprecated("Buffer.type", "Buffer.accessor.type")();
      return this.accessor.type;
    }
    get bytes() {
      log2.deprecated("Buffer.bytes", "Buffer.byteLength")();
      return this.byteLength;
    }
    setByteLength(byteLength) {
      log2.deprecated("setByteLength", "reallocate")();
      return this.reallocate(byteLength);
    }
    updateAccessor(opts) {
      log2.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
      this.accessor = new Accessor(this.accessor, opts);
      return this;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
  var TEXTURE_FORMATS = {
    [6407]: {
      dataFormat: 6407,
      types: [5121, 33635]
    },
    [6408]: {
      dataFormat: 6408,
      types: [5121, 32819, 32820]
    },
    [6406]: {
      dataFormat: 6406,
      types: [5121]
    },
    [6409]: {
      dataFormat: 6409,
      types: [5121]
    },
    [6410]: {
      dataFormat: 6410,
      types: [5121]
    },
    [33326]: {
      dataFormat: 6403,
      types: [5126],
      gl2: true
    },
    [33328]: {
      dataFormat: 33319,
      types: [5126],
      gl2: true
    },
    [34837]: {
      dataFormat: 6407,
      types: [5126],
      gl2: true
    },
    [34836]: {
      dataFormat: 6408,
      types: [5126],
      gl2: true
    }
  };
  var DATA_FORMAT_CHANNELS = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
  };
  var TYPE_SIZES = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
  };
  function isFormatSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (info.gl1 === void 0 && info.gl2 === void 0) {
      return true;
    }
    const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    return typeof value === "string" ? gl.getExtension(value) : value;
  }
  function isLinearFilteringSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    switch (info && info.types[0]) {
      case 5126:
        return gl.getExtension("OES_texture_float_linear");
      case 5131:
        return gl.getExtension("OES_texture_half_float_linear");
      default:
        return true;
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
  var NPOT_MIN_FILTERS = [9729, 9728];
  var WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer2() {
  };
  var Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    static isSupported(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        format,
        linearFiltering
      } = opts;
      let supported = true;
      if (format) {
        supported = supported && isFormatSupported(gl, format);
        supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
      }
      return supported;
    }
    constructor(gl, props) {
      const {
        id = uid("texture"),
        handle,
        target
      } = props;
      super(gl, {
        id,
        handle
      });
      this.target = target;
      this.textureUnit = void 0;
      this.loaded = false;
      this.width = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.format = void 0;
      this.type = void 0;
      this.dataFormat = void 0;
      this.border = void 0;
      this.textureUnit = void 0;
      this.mipmaps = void 0;
    }
    toString() {
      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let data = props.data;
      if (data instanceof Promise) {
        data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
          pixels: resolvedImageData,
          data: resolvedImageData
        })));
        return this;
      }
      const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
        this._video = null;
        data.addEventListener("loadeddata", () => this.initialize(props));
        return this;
      }
      const {
        pixels = null,
        format = 6408,
        border = 0,
        recreate = false,
        parameters = {},
        pixelStore = {},
        textureUnit = void 0
      } = props;
      if (!data) {
        data = pixels;
      }
      let {
        width,
        height,
        dataFormat,
        type,
        compressed = false,
        mipmaps = true
      } = props;
      const {
        depth = 0
      } = props;
      ({
        width,
        height,
        compressed,
        dataFormat,
        type
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.format = format;
      this.type = type;
      this.dataFormat = dataFormat;
      this.border = border;
      this.textureUnit = textureUnit;
      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }
      if (mipmaps && this._isNPOT()) {
        log2.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        mipmaps = false;
        this._updateForNPOT(parameters);
      }
      this.mipmaps = mipmaps;
      this.setImageData({
        data,
        width,
        height,
        depth,
        format,
        type,
        dataFormat,
        border,
        mipmaps,
        parameters: pixelStore,
        compressed
      });
      if (mipmaps) {
        this.generateMipmap();
      }
      this.setParameters(parameters);
      if (recreate) {
        this.data = data;
      }
      if (isVideo) {
        this._video = {
          video: data,
          parameters,
          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
      }
      return this;
    }
    update() {
      if (this._video) {
        const {
          video,
          parameters,
          lastTime
        } = this._video;
        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
          return;
        }
        this.setSubImageData({
          data: video,
          parameters
        });
        if (this.mipmaps) {
          this.generateMipmap();
        }
        this._video.lastTime = video.currentTime;
      }
    }
    resize(_ref) {
      let {
        height,
        width,
        mipmaps = false
      } = _ref;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          border: this.border,
          mipmaps
        });
      }
      return this;
    }
    generateMipmap() {
      let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isNPOT()) {
        log2.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        return this;
      }
      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, params, () => {
        this.gl.generateMipmap(this.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
    setImageData(options) {
      this._trackDeallocatedMemory("Texture");
      const {
        target = this.target,
        pixels = null,
        level = 0,
        format = this.format,
        border = this.border,
        offset = 0,
        parameters = {}
      } = options;
      let {
        data = null,
        type = this.type,
        width = this.width,
        height = this.height,
        dataFormat = this.dataFormat,
        compressed = false
      } = options;
      if (!data) {
        data = pixels;
      }
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      const {
        gl
      } = this;
      gl.bindTexture(this.target, this.handle);
      let dataType = null;
      ({
        data,
        dataType
      } = this._getDataType({
        data,
        compressed
      }));
      let gl2;
      let compressedTextureSize = 0;
      withParameters(this.gl, parameters, () => {
        switch (dataType) {
          case "null":
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            break;
          case "typed-array":
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
            break;
          case "buffer":
            gl2 = assertWebGL2Context(gl);
            gl2.bindBuffer(35052, data.handle || data);
            gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
            break;
          case "browser-object":
            if (isWebGL2(gl)) {
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
            } else {
              gl.texImage2D(target, level, format, dataFormat, type, data);
            }
            break;
          case "compressed":
            for (const [levelIndex, levelData] of data.entries()) {
              gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
              compressedTextureSize += levelData.levelSize;
            }
            break;
          default:
            assert6(false, "Unknown image data type");
        }
      });
      if (dataType === "compressed") {
        this._trackAllocatedMemory(compressedTextureSize, "Texture");
      } else if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        const channelSize = TYPE_SIZES[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
      }
      this.loaded = true;
      return this;
    }
    setSubImageData(_ref2) {
      let {
        target = this.target,
        pixels = null,
        data = null,
        x: x2 = 0,
        y: y2 = 0,
        width = this.width,
        height = this.height,
        level = 0,
        format = this.format,
        type = this.type,
        dataFormat = this.dataFormat,
        compressed = false,
        offset = 0,
        border = this.border,
        parameters = {}
      } = _ref2;
      ({
        type,
        dataFormat,
        compressed,
        width,
        height
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width,
        height
      }));
      assert6(this.depth === 0, "texSubImage not supported for 3D textures");
      if (!data) {
        data = pixels;
      }
      if (data && data.data) {
        const ndarray = data;
        data = ndarray.data;
        width = ndarray.shape[0];
        height = ndarray.shape[1];
      }
      if (data instanceof Buffer2) {
        data = data.handle;
      }
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, parameters, () => {
        if (compressed) {
          this.gl.compressedTexSubImage2D(target, level, x2, y2, width, height, format, data);
        } else if (data === null) {
          this.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          this.gl.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, data, offset);
        } else if (data instanceof WebGLBuffer) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.bindBuffer(35052, data);
          gl2.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
        } else if (isWebGL2(this.gl)) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.texSubImage2D(target, level, x2, y2, width, height, dataFormat, type, data);
        } else {
          this.gl.texSubImage2D(target, level, x2, y2, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
    unbind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, null);
      return textureUnit;
    }
    _getDataType(_ref3) {
      let {
        data,
        compressed = false
      } = _ref3;
      if (compressed) {
        return {
          data,
          dataType: "compressed"
        };
      }
      if (data === null) {
        return {
          data,
          dataType: "null"
        };
      }
      if (ArrayBuffer.isView(data)) {
        return {
          data,
          dataType: "typed-array"
        };
      }
      if (data instanceof Buffer2) {
        return {
          data: data.handle,
          dataType: "buffer"
        };
      }
      if (data instanceof WebGLBuffer) {
        return {
          data,
          dataType: "buffer"
        };
      }
      return {
        data,
        dataType: "browser-object"
      };
    }
    _deduceParameters(opts) {
      const {
        format,
        data
      } = opts;
      let {
        width,
        height,
        dataFormat,
        type,
        compressed
      } = opts;
      const textureFormat = TEXTURE_FORMATS[format];
      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
      type = type || textureFormat && textureFormat.types[0];
      compressed = compressed || textureFormat && textureFormat.compressed;
      ({
        width,
        height
      } = this._deduceImageSize(data, width, height));
      return {
        dataFormat,
        type,
        compressed,
        width,
        height,
        format,
        data
      };
    }
    _deduceImageSize(data, width, height) {
      let size;
      if (typeof ImageData !== "undefined" && data instanceof ImageData) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        size = {
          width: data.naturalWidth,
          height: data.naturalHeight
        };
      } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
        size = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        size = {
          width: data.videoWidth,
          height: data.videoHeight
        };
      } else if (!data) {
        size = {
          width: width >= 0 ? width : 1,
          height: height >= 0 ? height : 1
        };
      } else {
        size = {
          width,
          height
        };
      }
      assert6(size, "Could not deduced texture size");
      assert6(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
      assert6(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
      return size;
    }
    _createHandle() {
      return this.gl.createTexture();
    }
    _deleteHandle() {
      this.gl.deleteTexture(this.handle);
      this._trackDeallocatedMemory("Texture");
    }
    _getParameter(pname) {
      switch (pname) {
        case 4096:
          return this.width;
        case 4097:
          return this.height;
        default:
          this.gl.bindTexture(this.target, this.handle);
          const value = this.gl.getTexParameter(this.target, pname);
          this.gl.bindTexture(this.target, null);
          return value;
      }
    }
    _setParameter(pname, param) {
      this.gl.bindTexture(this.target, this.handle);
      param = this._getNPOTParam(pname, param);
      switch (pname) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.handle, pname, param);
          break;
        case 4096:
        case 4097:
          assert6(false);
          break;
        default:
          this.gl.texParameteri(this.target, pname, param);
          break;
      }
      this.gl.bindTexture(this.target, null);
      return this;
    }
    _isNPOT() {
      if (isWebGL2(this.gl)) {
        return false;
      }
      if (!this.width || !this.height) {
        return false;
      }
      return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
    }
    _updateForNPOT(parameters) {
      if (parameters[this.gl.TEXTURE_MIN_FILTER] === void 0) {
        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
      }
      if (parameters[this.gl.TEXTURE_WRAP_S] === void 0) {
        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
      }
      if (parameters[this.gl.TEXTURE_WRAP_T] === void 0) {
        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
      }
    }
    _getNPOTParam(pname, param) {
      if (this._isNPOT()) {
        switch (pname) {
          case 10241:
            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
              param = 9729;
            }
            break;
          case 10242:
          case 10243:
            if (param !== 33071) {
              param = 33071;
            }
            break;
          default:
            break;
        }
      }
      return param;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
  var pathPrefix2 = "";
  function loadImage(url, opts) {
    assert6(typeof url === "string");
    url = pathPrefix2 + url;
    return new Promise((resolve2, reject) => {
      try {
        const image = new Image();
        image.onload = () => resolve2(image);
        image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
        image.crossOrigin = opts && opts.crossOrigin || "anonymous";
        image.src = url;
      } catch (error2) {
        reject(error2);
      }
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
  var Texture2D = class extends Texture {
    get [Symbol.toStringTag]() {
      return "Texture2D";
    }
    static isSupported(gl, opts) {
      return Texture.isSupported(gl, opts);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      if (typeof props.data === "string") {
        props = Object.assign({}, props, {
          data: loadImage(props.data)
        });
      }
      super(gl, Object.assign({}, props, {
        target: 3553
      }));
      this.initialize(props);
      Object.seal(this);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js
  var FACES = [34069, 34070, 34071, 34072, 34073, 34074];
  var TextureCube = class extends Texture {
    get [Symbol.toStringTag]() {
      return "TextureCube";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      super(gl, Object.assign({}, props, {
        target: 34067
      }));
      this.initialize(props);
      Object.seal(this);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        mipmaps = true,
        parameters = {}
      } = props;
      this.opts = props;
      this.setCubeMapImageData(props).then(() => {
        this.loaded = true;
        if (mipmaps) {
          this.generateMipmap(props);
        }
        this.setParameters(parameters);
      });
      return this;
    }
    subImage(_ref) {
      let {
        face,
        data,
        x: x2 = 0,
        y: y2 = 0,
        mipmapLevel = 0
      } = _ref;
      return this._subImage({
        target: face,
        data,
        x: x2,
        y: y2,
        mipmapLevel
      });
    }
    async setCubeMapImageData(_ref2) {
      let {
        width,
        height,
        pixels,
        data,
        border = 0,
        format = 6408,
        type = 5121
      } = _ref2;
      const {
        gl
      } = this;
      const imageDataMap = pixels || data;
      const resolvedFaces = await Promise.all(FACES.map((face) => {
        const facePixels = imageDataMap[face];
        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
      }));
      this.bind();
      FACES.forEach((face, index) => {
        if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
          log2.warn("".concat(this.id, " has mipmap and multiple LODs."))();
        }
        resolvedFaces[index].forEach((image, lodLevel) => {
          if (width && height) {
            gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
          } else {
            gl.texImage2D(face, lodLevel, format, format, type, image);
          }
        });
      });
      this.unbind();
    }
    setImageDataForFace(options) {
      const {
        face,
        width,
        height,
        pixels,
        data,
        border = 0,
        format = 6408,
        type = 5121
      } = options;
      const {
        gl
      } = this;
      const imageData = pixels || data;
      this.bind();
      if (imageData instanceof Promise) {
        imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
          face,
          data: resolvedImageData,
          pixels: resolvedImageData
        })));
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }
      return this;
    }
  };
  TextureCube.FACES = FACES;

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js
  var Texture3D = class extends Texture {
    get [Symbol.toStringTag]() {
      return "Texture3D";
    }
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGL2Context(gl);
      props = Object.assign({
        depth: 1
      }, props, {
        target: 32879,
        unpackFlipY: false
      });
      super(gl, props);
      this.initialize(props);
      Object.seal(this);
    }
    setImageData(_ref) {
      let {
        level = 0,
        dataFormat = 6408,
        width,
        height,
        depth = 1,
        border = 0,
        format,
        type = 5121,
        offset = 0,
        data,
        parameters = {}
      } = _ref;
      this._trackDeallocatedMemory("Texture");
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, parameters, () => {
        if (ArrayBuffer.isView(data)) {
          this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
        }
        if (data instanceof Buffer2) {
          this.gl.bindBuffer(35052, data.handle);
          this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
        }
      });
      if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        const channelSize = TYPE_SIZES[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
      }
      this.loaded = true;
      return this;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
  var EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
  var renderbuffer_formats_default = {
    [33189]: {
      bpp: 2
    },
    [33190]: {
      gl2: true,
      bpp: 3
    },
    [36012]: {
      gl2: true,
      bpp: 4
    },
    [36168]: {
      bpp: 1
    },
    [34041]: {
      bpp: 4
    },
    [35056]: {
      gl2: true,
      bpp: 4
    },
    [36013]: {
      gl2: true,
      bpp: 5
    },
    [32854]: {
      bpp: 2
    },
    [36194]: {
      bpp: 2
    },
    [32855]: {
      bpp: 2
    },
    [33321]: {
      gl2: true,
      bpp: 1
    },
    [33330]: {
      gl2: true,
      bpp: 1
    },
    [33329]: {
      gl2: true,
      bpp: 1
    },
    [33332]: {
      gl2: true,
      bpp: 2
    },
    [33331]: {
      gl2: true,
      bpp: 2
    },
    [33334]: {
      gl2: true,
      bpp: 4
    },
    [33333]: {
      gl2: true,
      bpp: 4
    },
    [33323]: {
      gl2: true,
      bpp: 2
    },
    [33336]: {
      gl2: true,
      bpp: 2
    },
    [33335]: {
      gl2: true,
      bpp: 2
    },
    [33338]: {
      gl2: true,
      bpp: 4
    },
    [33337]: {
      gl2: true,
      bpp: 4
    },
    [33340]: {
      gl2: true,
      bpp: 8
    },
    [33339]: {
      gl2: true,
      bpp: 8
    },
    [32849]: {
      gl2: true,
      bpp: 3
    },
    [32856]: {
      gl2: true,
      bpp: 4
    },
    [32857]: {
      gl2: true,
      bpp: 4
    },
    [36220]: {
      gl2: true,
      bpp: 4
    },
    [36238]: {
      gl2: true,
      bpp: 4
    },
    [36975]: {
      gl2: true,
      bpp: 4
    },
    [36214]: {
      gl2: true,
      bpp: 8
    },
    [36232]: {
      gl2: true,
      bpp: 8
    },
    [36226]: {
      gl2: true,
      bpp: 16
    },
    [36208]: {
      gl2: true,
      bpp: 16
    },
    [33325]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 2
    },
    [33327]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [34842]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [33326]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [33328]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [34836]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 16
    },
    [35898]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
  function isFormatSupported2(gl, format, formats) {
    const info = formats[format];
    if (!info) {
      return false;
    }
    const value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    if (typeof value === "string") {
      return gl.getExtension(value);
    }
    return value;
  }
  var Renderbuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Renderbuffer";
    }
    static isSupported(gl) {
      let {
        format
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        format: null
      };
      return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
    }
    static getSamplesForFormat(gl, _ref) {
      let {
        format
      } = _ref;
      return gl.getInternalformatParameter(36161, format, 32937);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.initialize(opts);
      Object.seal(this);
    }
    initialize(_ref2) {
      let {
        format,
        width = 1,
        height = 1,
        samples = 0
      } = _ref2;
      assert6(format, "Needs format");
      this._trackDeallocatedMemory();
      this.gl.bindRenderbuffer(36161, this.handle);
      if (samples !== 0 && isWebGL2(this.gl)) {
        this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
      } else {
        this.gl.renderbufferStorage(36161, format, width, height);
      }
      this.format = format;
      this.width = width;
      this.height = height;
      this.samples = samples;
      this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
      return this;
    }
    resize(_ref3) {
      let {
        width,
        height
      } = _ref3;
      if (width !== this.width || height !== this.height) {
        return this.initialize({
          width,
          height,
          format: this.format,
          samples: this.samples
        });
      }
      return this;
    }
    _createHandle() {
      return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161, handle);
    }
    _syncHandle(handle) {
      this.format = this.getParameter(36164);
      this.width = this.getParameter(36162);
      this.height = this.getParameter(36163);
      this.samples = this.getParameter(36011);
    }
    _getParameter(pname) {
      this.gl.bindRenderbuffer(36161, this.handle);
      const value = this.gl.getRenderbufferParameter(36161, pname);
      return value;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var GL_DEPTH = 6145;
  var GL_STENCIL = 6146;
  var GL_DEPTH_STENCIL = 34041;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(gl) {
    let {
      framebuffer = null,
      color = null,
      depth = null,
      stencil = null
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const parameters = {};
    if (framebuffer) {
      parameters.framebuffer = framebuffer;
    }
    let clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT;
      if (color !== true) {
        parameters.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearStencil = depth;
      }
    }
    assert6(clearFlags !== 0, ERR_ARGUMENTS);
    withParameters(gl, parameters, () => {
      gl.clear(clearFlags);
    });
  }
  function clearBuffer(gl) {
    let {
      framebuffer = null,
      buffer = GL_COLOR,
      drawBuffer = 0,
      value = [0, 0, 0, 0]
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGL2Context(gl);
    withParameters(gl, {
      framebuffer
    }, () => {
      switch (buffer) {
        case GL_COLOR:
          switch (value.constructor) {
            case Int32Array:
              gl.clearBufferiv(buffer, drawBuffer, value);
              break;
            case Uint32Array:
              gl.clearBufferuiv(buffer, drawBuffer, value);
              break;
            case Float32Array:
            default:
              gl.clearBufferfv(buffer, drawBuffer, value);
          }
          break;
        case GL_DEPTH:
          gl.clearBufferfv(GL_DEPTH, 0, [value]);
          break;
        case GL_STENCIL:
          gl.clearBufferiv(GL_STENCIL, 0, [value]);
          break;
        case GL_DEPTH_STENCIL:
          const [depth, stencil] = value;
          gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
          break;
        default:
          assert6(false, ERR_ARGUMENTS);
      }
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        assert6(false);
        return 0;
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
  function readPixelsToArray(source) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408
    } = options;
    let {
      sourceAttachment = 36064,
      target = null,
      sourceWidth,
      sourceHeight,
      sourceType
    } = options;
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer(source);
    assert6(framebuffer);
    const {
      gl,
      handle,
      attachments
    } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    if (sourceAttachment === 36064 && handle === null) {
      sourceAttachment = 1028;
    }
    assert6(attachments[sourceAttachment]);
    sourceType = sourceType || attachments[sourceAttachment].type;
    target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.delete();
    }
    return target;
  }
  function copyToDataUrl(source) {
    let {
      sourceAttachment = 36064,
      targetMaxHeight = Number.MAX_SAFE_INTEGER
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let data = readPixelsToArray(source, {
      sourceAttachment
    });
    let {
      width,
      height
    } = source;
    while (height > targetMaxHeight) {
      ({
        data,
        width,
        height
      } = scalePixels2({
        data,
        width,
        height
      }));
    }
    flipRows({
      data,
      width,
      height
    });
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const context = canvas.getContext("2d");
    const imageData = context.createImageData(width, height);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  }
  function getFramebuffer(source) {
    if (!(source instanceof Framebuffer)) {
      return {
        framebuffer: toFramebuffer(source),
        deleteFramebuffer: true
      };
    }
    return {
      framebuffer: source,
      deleteFramebuffer: false
    };
  }
  function getPixelArray(pixelArray, type, format, width, height) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121;
    const ArrayType = getTypedArrayFromGLType(type, {
      clamped: false
    });
    const components = glFormatToComponents(format);
    return new ArrayType(width * height * components);
  }

  // node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
  var FEATURES = {
    WEBGL2: "WEBGL2",
    VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
    TIMER_QUERY: "TIMER_QUERY",
    INSTANCED_RENDERING: "INSTANCED_RENDERING",
    MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
    ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
    BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
    FLOAT_BLEND: "FLOAT_BLEND",
    COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
    TEXTURE_DEPTH: "TEXTURE_DEPTH",
    TEXTURE_FLOAT: "TEXTURE_FLOAT",
    TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
    TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
    TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
    COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
    COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
    COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
    GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
    GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
    GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
    GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
  };
  function checkFloat32ColorAttachment(gl) {
    const testTexture = new Texture2D(gl, {
      format: 6408,
      type: 5126,
      dataFormat: 6408
    });
    const testFb = new Framebuffer(gl, {
      id: "test-framebuffer",
      check: false,
      attachments: {
        [36064]: testTexture
      }
    });
    const status = testFb.getStatus();
    testTexture.delete();
    testFb.delete();
    return status === 36053;
  }
  var webgl_features_table_default = {
    [FEATURES.WEBGL2]: [false, true],
    [FEATURES.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true],
    [FEATURES.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
    [FEATURES.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true],
    [FEATURES.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true],
    [FEATURES.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true],
    [FEATURES.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true],
    [FEATURES.FLOAT_BLEND]: ["EXT_float_blend"],
    [FEATURES.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true],
    [FEATURES.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true],
    [FEATURES.TEXTURE_FLOAT]: ["OES_texture_float", true],
    [FEATURES.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true],
    [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
    [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
    [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
    [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
    [FEATURES.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true],
    [FEATURES.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true],
    [FEATURES.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true],
    [FEATURES.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true]
  };

  // node_modules/@luma.gl/webgl/dist/esm/features/features.js
  var LOG_UNSUPPORTED_FEATURE = 2;
  function hasFeature(gl, feature) {
    return hasFeatures(gl, feature);
  }
  function hasFeatures(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => {
      return isFeatureSupported(gl, feature);
    });
  }
  function getFeatures(gl) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    for (const cap in webgl_features_table_default) {
      if (gl.luma.caps[cap] === void 0) {
        gl.luma.caps[cap] = isFeatureSupported(gl, cap);
      }
    }
    return gl.luma.caps;
  }
  function isFeatureSupported(gl, cap) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = queryFeature(gl, cap);
    }
    if (!gl.luma.caps[cap]) {
      log2.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
    }
    return gl.luma.caps[cap];
  }
  function queryFeature(gl, cap) {
    const feature = webgl_features_table_default[cap];
    assert6(feature, cap);
    let isSupported;
    const featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
    if (typeof featureDefinition === "function") {
      isSupported = featureDefinition(gl);
    } else if (Array.isArray(featureDefinition)) {
      isSupported = true;
      for (const extension of featureDefinition) {
        isSupported = isSupported && Boolean(gl.getExtension(extension));
      }
    } else if (typeof featureDefinition === "string") {
      isSupported = Boolean(gl.getExtension(featureDefinition));
    } else if (typeof featureDefinition === "boolean") {
      isSupported = featureDefinition;
    } else {
      assert6(false);
    }
    return isSupported;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
  var ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
  var Framebuffer = class _Framebuffer extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    static isSupported(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        colorBufferFloat,
        colorBufferHalfFloat
      } = options;
      let supported = true;
      if (colorBufferFloat) {
        supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
      }
      if (colorBufferHalfFloat) {
        supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
      }
      return supported;
    }
    static getDefaultFramebuffer(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new _Framebuffer(gl, {
        id: "default-framebuffer",
        handle: null,
        attachments: {}
      });
      return gl.luma.defaultFramebuffer;
    }
    get MAX_COLOR_ATTACHMENTS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
    }
    get MAX_DRAW_BUFFERS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.width = null;
      this.height = null;
      this.attachments = {};
      this.readBuffer = 36064;
      this.drawBuffers = [36064];
      this.ownResources = [];
      this.initialize(opts);
      Object.seal(this);
    }
    get color() {
      return this.attachments[36064] || null;
    }
    get texture() {
      return this.attachments[36064] || null;
    }
    get depth() {
      return this.attachments[36096] || this.attachments[33306] || null;
    }
    get stencil() {
      return this.attachments[36128] || this.attachments[33306] || null;
    }
    initialize(_ref) {
      let {
        width = 1,
        height = 1,
        attachments = null,
        color = true,
        depth = true,
        stencil = false,
        check = true,
        readBuffer = void 0,
        drawBuffers = void 0
      } = _ref;
      assert6(width >= 0 && height >= 0, "Width and height need to be integers");
      this.width = width;
      this.height = height;
      if (attachments) {
        for (const attachment in attachments) {
          const target = attachments[attachment];
          const object = Array.isArray(target) ? target[0] : target;
          object.resize({
            width,
            height
          });
        }
      } else {
        attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
      }
      this.update({
        clearAttachments: true,
        attachments,
        readBuffer,
        drawBuffers
      });
      if (attachments && check) {
        this.checkStatus();
      }
    }
    delete() {
      for (const resource of this.ownResources) {
        resource.delete();
      }
      super.delete();
      return this;
    }
    update(_ref2) {
      let {
        attachments = {},
        readBuffer,
        drawBuffers,
        clearAttachments = false,
        resizeAttachments = true
      } = _ref2;
      this.attach(attachments, {
        clearAttachments,
        resizeAttachments
      });
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      if (readBuffer) {
        this._setReadBuffer(readBuffer);
      }
      if (drawBuffers) {
        this._setDrawBuffers(drawBuffers);
      }
      gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    resize() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let {
        width,
        height
      } = options;
      if (this.handle === null) {
        assert6(width === void 0 && height === void 0);
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }
      if (width === void 0) {
        width = this.gl.drawingBufferWidth;
      }
      if (height === void 0) {
        height = this.gl.drawingBufferHeight;
      }
      if (width !== this.width && height !== this.height) {
        log2.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
      }
      for (const attachmentPoint in this.attachments) {
        this.attachments[attachmentPoint].resize({
          width,
          height
        });
      }
      this.width = width;
      this.height = height;
      return this;
    }
    attach(attachments) {
      let {
        clearAttachments = false,
        resizeAttachments = true
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const newAttachments = {};
      if (clearAttachments) {
        Object.keys(this.attachments).forEach((key) => {
          newAttachments[key] = null;
        });
      }
      Object.assign(newAttachments, attachments);
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      for (const key in newAttachments) {
        assert6(key !== void 0, "Misspelled framebuffer binding point?");
        const attachment = Number(key);
        const descriptor = newAttachments[attachment];
        let object = descriptor;
        if (!object) {
          this._unattach(attachment);
        } else if (object instanceof Renderbuffer) {
          this._attachRenderbuffer({
            attachment,
            renderbuffer: object
          });
        } else if (Array.isArray(descriptor)) {
          const [texture, layer = 0, level = 0] = descriptor;
          object = texture;
          this._attachTexture({
            attachment,
            texture,
            layer,
            level
          });
        } else {
          this._attachTexture({
            attachment,
            texture: object,
            layer: 0,
            level: 0
          });
        }
        if (resizeAttachments && object) {
          object.resize({
            width: this.width,
            height: this.height
          });
        }
      }
      this.gl.bindFramebuffer(36160, prevHandle || null);
      Object.assign(this.attachments, attachments);
      Object.keys(this.attachments).filter((key) => !this.attachments[key]).forEach((key) => {
        delete this.attachments[key];
      });
    }
    checkStatus() {
      const {
        gl
      } = this;
      const status = this.getStatus();
      if (status !== 36053) {
        throw new Error(_getFrameBufferStatus(status));
      }
      return this;
    }
    getStatus() {
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      const status = gl.checkFramebufferStatus(36160);
      gl.bindFramebuffer(36160, prevHandle || null);
      return status;
    }
    clear() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        color,
        depth,
        stencil,
        drawBuffers = []
      } = options;
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      if (color || depth || stencil) {
        clear(this.gl, {
          color,
          depth,
          stencil
        });
      }
      drawBuffers.forEach((value, drawBuffer) => {
        clearBuffer(this.gl, {
          drawBuffer,
          value
        });
      });
      this.gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    readPixels() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
      return null;
    }
    readPixelsToBuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
      return null;
    }
    copyToDataUrl() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
      return null;
    }
    copyToImage() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
      return null;
    }
    copyToTexture() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    blit() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
      return null;
    }
    invalidate(_ref3) {
      let {
        attachments = [],
        x: x2 = 0,
        y: y2 = 0,
        width,
        height
      } = _ref3;
      const gl2 = assertWebGL2Context(this.gl);
      const prevHandle = gl2.bindFramebuffer(36008, this.handle);
      const invalidateAll = x2 === 0 && y2 === 0 && width === void 0 && height === void 0;
      if (invalidateAll) {
        gl2.invalidateFramebuffer(36008, attachments);
      } else {
        gl2.invalidateFramebuffer(36008, attachments, x2, y2, width, height);
      }
      gl2.bindFramebuffer(36008, prevHandle);
      return this;
    }
    getAttachmentParameter(attachment, pname, keys) {
      let value = this._getAttachmentParameterFallback(pname);
      if (value === null) {
        this.gl.bindFramebuffer(36160, this.handle);
        value = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
        this.gl.bindFramebuffer(36160, null);
      }
      if (keys && value > 1e3) {
        value = getKey(this.gl, value);
      }
      return value;
    }
    getAttachmentParameters() {
      let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
      let keys = arguments.length > 1 ? arguments[1] : void 0;
      let parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
      const values = {};
      for (const pname of parameters) {
        const key = keys ? getKey(this.gl, pname) : pname;
        values[key] = this.getAttachmentParameter(attachment, pname, keys);
      }
      return values;
    }
    getParameters() {
      let keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const attachments = Object.keys(this.attachments);
      const parameters = {};
      for (const attachmentName of attachments) {
        const attachment = Number(attachmentName);
        const key = keys ? getKey(this.gl, attachment) : attachment;
        parameters[key] = this.getAttachmentParameters(attachment, keys);
      }
      return parameters;
    }
    show() {
      if (typeof window !== "undefined") {
        window.open(copyToDataUrl(this), "luma-debug-texture");
      }
      return this;
    }
    log() {
      let logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (logLevel > log2.level || typeof window === "undefined") {
        return this;
      }
      message = message || "Framebuffer ".concat(this.id);
      const image = copyToDataUrl(this, {
        targetMaxHeight: 100
      });
      log2.image({
        logLevel,
        message,
        image
      }, message)();
      return this;
    }
    bind() {
      let {
        target = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target, this.handle);
      return this;
    }
    unbind() {
      let {
        target = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target, null);
      return this;
    }
    _createDefaultAttachments(color, depth, stencil, width, height) {
      let defaultAttachments = null;
      if (color) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36064] = new Texture2D(this.gl, {
          id: "".concat(this.id, "-color0"),
          pixels: null,
          format: 6408,
          type: 5121,
          width,
          height,
          mipmaps: false,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.ownResources.push(defaultAttachments[36064]);
      }
      if (depth && stencil) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[33306] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth-stencil"),
          format: 35056,
          width,
          height: 111
        });
        this.ownResources.push(defaultAttachments[33306]);
      } else if (depth) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36096] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth"),
          format: 33189,
          width,
          height
        });
        this.ownResources.push(defaultAttachments[36096]);
      } else if (stencil) {
        assert6(false);
      }
      return defaultAttachments;
    }
    _unattach(attachment) {
      const oldAttachment = this.attachments[attachment];
      if (!oldAttachment) {
        return;
      }
      if (oldAttachment instanceof Renderbuffer) {
        this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
      } else {
        this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
      }
      delete this.attachments[attachment];
    }
    _attachRenderbuffer(_ref4) {
      let {
        attachment = 36064,
        renderbuffer
      } = _ref4;
      const {
        gl
      } = this;
      gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
      this.attachments[attachment] = renderbuffer;
    }
    _attachTexture(_ref5) {
      let {
        attachment = 36064,
        texture,
        layer,
        level
      } = _ref5;
      const {
        gl
      } = this;
      gl.bindTexture(texture.target, texture.handle);
      switch (texture.target) {
        case 35866:
        case 32879:
          const gl2 = assertWebGL2Context(gl);
          gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;
        case 34067:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;
        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;
        default:
          assert6(false, "Illegal texture type");
      }
      gl.bindTexture(texture.target, null);
      this.attachments[attachment] = texture;
    }
    _setReadBuffer(readBuffer) {
      const gl2 = getWebGL2Context(this.gl);
      if (gl2) {
        gl2.readBuffer(readBuffer);
      } else {
        assert6(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
      }
      this.readBuffer = readBuffer;
    }
    _setDrawBuffers(drawBuffers) {
      const {
        gl
      } = this;
      const gl2 = assertWebGL2Context(gl);
      if (gl2) {
        gl2.drawBuffers(drawBuffers);
      } else {
        const ext = gl.getExtension("WEBGL_draw_buffers");
        if (ext) {
          ext.drawBuffersWEBGL(drawBuffers);
        } else {
          assert6(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
        }
      }
      this.drawBuffers = drawBuffers;
    }
    _getAttachmentParameterFallback(pname) {
      const caps = getFeatures(this.gl);
      switch (pname) {
        case 36052:
          return !caps.WEBGL2 ? 0 : null;
        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
          return !caps.WEBGL2 ? 8 : null;
        case 33297:
          return !caps.WEBGL2 ? 5125 : null;
        case 33296:
          return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
        default:
          return null;
      }
    }
    _createHandle() {
      return this.gl.createFramebuffer();
    }
    _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
    _bindHandle(handle) {
      return this.gl.bindFramebuffer(36160, handle);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    const STATUS = Framebuffer.STATUS || {};
    return STATUS[status] || "Framebuffer error ".concat(status);
  }
  var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
  Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
  function cloneTextureFrom(refTexture, overrides) {
    assert6(refTexture instanceof Texture2D || refTexture instanceof TextureCube || refTexture instanceof Texture3D);
    const TextureType = refTexture.constructor;
    const {
      gl,
      width,
      height,
      format,
      type,
      dataFormat,
      border,
      mipmaps
    } = refTexture;
    const textureOptions = Object.assign({
      width,
      height,
      format,
      type,
      dataFormat,
      border,
      mipmaps
    }, overrides);
    return new TextureType(gl, textureOptions);
  }
  function toFramebuffer(texture, opts) {
    const {
      gl,
      width,
      height,
      id
    } = texture;
    const framebuffer = new Framebuffer(gl, Object.assign({}, opts, {
      id: "framebuffer-for-".concat(id),
      width,
      height,
      attachments: {
        [36064]: texture
      }
    }));
    return framebuffer;
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js
  function getShaderName(shader) {
    let defaultName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = shader.match(SHADER_NAME_REGEXP);
    return match ? match[1] : defaultName;
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js
  var GL_FRAGMENT_SHADER = 35632;
  var GL_VERTEX_SHADER = 35633;
  function getShaderTypeName(type) {
    switch (type) {
      case GL_FRAGMENT_SHADER:
        return "fragment";
      case GL_VERTEX_SHADER:
        return "vertex";
      default:
        return "unknown type";
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js
  function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
    const errorStrings = errLog.split(/\r?\n/);
    const errors = {};
    const warnings = {};
    const name = shaderName || getShaderName(src) || "(unnamed)";
    const shaderDescription = "".concat(getShaderTypeName(shaderType), " shader ").concat(name);
    for (let i2 = 0; i2 < errorStrings.length; i2++) {
      const errorString = errorStrings[i2];
      if (errorString.length <= 1) {
        continue;
      }
      const segments = errorString.split(":");
      const type = segments[0];
      const line = parseInt(segments[2], 10);
      if (isNaN(line)) {
        throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
      }
      if (type !== "WARNING") {
        errors[line] = errorString;
      } else {
        warnings[line] = errorString;
      }
    }
    const lines = addLineNumbers(src);
    return {
      shaderName: shaderDescription,
      errors: formatErrors(errors, lines),
      warnings: formatErrors(warnings, lines)
    };
  }
  function formatErrors(errors, lines) {
    let message = "";
    for (let i2 = 0; i2 < lines.length; i2++) {
      const line = lines[i2];
      if (!errors[i2 + 3] && !errors[i2 + 2] && !errors[i2 + 1]) {
        continue;
      }
      message += "".concat(line, "\n");
      if (errors[i2 + 1]) {
        const error2 = errors[i2 + 1];
        const segments = error2.split(":", 3);
        const type = segments[0];
        const column = parseInt(segments[1], 10) || 0;
        const err = error2.substring(segments.join(":").length + 1).trim();
        message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
      }
    }
    return message;
  }
  function addLineNumbers(string) {
    let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let delim = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
    const lines = string.split(/\r?\n/);
    const maxDigits = String(lines.length + start - 1).length;
    return lines.map((line, i2) => {
      const lineNumber = String(i2 + start);
      const digits = lineNumber.length;
      const prefix = padLeft(lineNumber, maxDigits - digits);
      return prefix + delim + line;
    });
  }
  function padLeft(string, digits) {
    let result = "";
    for (let i2 = 0; i2 < digits; ++i2) {
      result += " ";
    }
    return "".concat(result).concat(string);
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js
  function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words.length >= 2 && words[0] === "#version") {
      const v2 = parseInt(words[1], 10);
      if (Number.isFinite(v2)) {
        version = v2;
      }
    }
    return version;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/shader.js
  var ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
  var Shader = class _Shader extends Resource {
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    static getTypeName(shaderType) {
      switch (shaderType) {
        case 35633:
          return "vertex-shader";
        case 35632:
          return "fragment-shader";
        default:
          assert6(false);
          return "unknown";
      }
    }
    constructor(gl, props) {
      assertWebGLContext(gl);
      assert6(typeof props.source === "string", ERR_SOURCE);
      const id = getShaderName(props.source, null) || props.id || uid("unnamed ".concat(_Shader.getTypeName(props.shaderType)));
      super(gl, {
        id
      });
      this.shaderType = props.shaderType;
      this.source = props.source;
      this.initialize(props);
    }
    initialize(_ref) {
      let {
        source
      } = _ref;
      const shaderName = getShaderName(source, null);
      if (shaderName) {
        this.id = uid(shaderName);
      }
      this._compile(source);
    }
    getParameter(pname) {
      return this.gl.getShaderParameter(this.handle, pname);
    }
    toString() {
      return "".concat(_Shader.getTypeName(this.shaderType), ":").concat(this.id);
    }
    getName() {
      return getShaderName(this.source) || "unnamed-shader";
    }
    getSource() {
      return this.gl.getShaderSource(this.handle);
    }
    getTranslatedSource() {
      const extension = this.gl.getExtension("WEBGL_debug_shaders");
      return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
    }
    _compile() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
      if (!source.startsWith("#version ")) {
        source = "#version 100\n".concat(source);
      }
      this.source = source;
      this.gl.shaderSource(this.handle, this.source);
      this.gl.compileShader(this.handle);
      const compileStatus = this.getParameter(35713);
      if (!compileStatus) {
        const infoLog = this.gl.getShaderInfoLog(this.handle);
        const {
          shaderName,
          errors,
          warnings
        } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);
        log2.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
        log2.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
        throw new Error("GLSL compilation errors in ".concat(shaderName));
      }
    }
    _deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
    _getOptsFromHandle() {
      return {
        type: this.getParameter(35663),
        source: this.getSource()
      };
    }
  };
  var VertexShader = class extends Shader {
    get [Symbol.toStringTag]() {
      return "VertexShader";
    }
    constructor(gl, props) {
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      super(gl, Object.assign({}, props, {
        shaderType: 35633
      }));
    }
    _createHandle() {
      return this.gl.createShader(35633);
    }
  };
  var FragmentShader = class extends Shader {
    get [Symbol.toStringTag]() {
      return "FragmentShader";
    }
    constructor(gl, props) {
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      super(gl, Object.assign({}, props, {
        shaderType: 35632
      }));
    }
    _createHandle() {
      return this.gl.createShader(35632);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js
  var UNIFORM_SETTERS = {
    [5126]: getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform),
    [35664]: getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform),
    [35665]: getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform),
    [35666]: getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform),
    [5124]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
    [35667]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
    [35668]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
    [35669]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
    [35670]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
    [35671]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
    [35672]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
    [35673]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
    [35674]: getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform),
    [35675]: getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform),
    [35676]: getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform),
    [35678]: getSamplerSetter,
    [35680]: getSamplerSetter,
    [5125]: getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform),
    [36294]: getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform),
    [36295]: getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform),
    [36296]: getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform),
    [35685]: getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform),
    [35686]: getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform),
    [35687]: getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform),
    [35688]: getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform),
    [35689]: getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform),
    [35690]: getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform),
    [35678]: getSamplerSetter,
    [35680]: getSamplerSetter,
    [35679]: getSamplerSetter,
    [35682]: getSamplerSetter,
    [36289]: getSamplerSetter,
    [36292]: getSamplerSetter,
    [36293]: getSamplerSetter,
    [36298]: getSamplerSetter,
    [36299]: getSamplerSetter,
    [36300]: getSamplerSetter,
    [36303]: getSamplerSetter,
    [36306]: getSamplerSetter,
    [36307]: getSamplerSetter,
    [36308]: getSamplerSetter,
    [36311]: getSamplerSetter
  };
  var FLOAT_ARRAY = {};
  var INT_ARRAY = {};
  var UINT_ARRAY = {};
  var array1 = [0];
  function toTypedArray(value, uniformLength, Type, cache3) {
    if (uniformLength === 1 && typeof value === "boolean") {
      value = value ? 1 : 0;
    }
    if (Number.isFinite(value)) {
      array1[0] = value;
      value = array1;
    }
    const length = value.length;
    if (length % uniformLength) {
      log2.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
    }
    if (value instanceof Type) {
      return value;
    }
    let result = cache3[length];
    if (!result) {
      result = new Type(length);
      cache3[length] = result;
    }
    for (let i2 = 0; i2 < length; i2++) {
      result[i2] = value[i2];
    }
    return result;
  }
  function toFloatArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
  }
  function toIntArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
  }
  function toUIntArray(value, uniformLength) {
    return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
  }
  function getUniformSetter(gl, location, info) {
    const setter = UNIFORM_SETTERS[info.type];
    if (!setter) {
      throw new Error("Unknown GLSL uniform type ".concat(info.type));
    }
    return setter().bind(null, gl, location);
  }
  function parseUniformName(name) {
    if (name[name.length - 1] !== "]") {
      return {
        name,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches3 = name.match(UNIFORM_NAME_REGEXP);
    if (!matches3 || matches3.length < 2) {
      throw new Error("Failed to parse GLSL uniform name ".concat(name));
    }
    return {
      name: matches3[1],
      length: matches3[2] || 1,
      isArray: Boolean(matches3[2])
    };
  }
  function checkUniformValues(uniforms, source, uniformMap) {
    for (const uniformName in uniforms) {
      const value = uniforms[uniformName];
      const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
      if (shouldCheck && !checkUniformValue(value)) {
        source = source ? "".concat(source, " ") : "";
        console.error("".concat(source, " Bad uniform ").concat(uniformName), value);
        throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
      }
    }
    return true;
  }
  function checkUniformValue(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return checkUniformArray(value);
    }
    if (isFinite(value)) {
      return true;
    } else if (value === true || value === false) {
      return true;
    } else if (value instanceof Texture) {
      return true;
    } else if (value instanceof Renderbuffer) {
      return true;
    } else if (value instanceof Framebuffer) {
      return Boolean(value.texture);
    }
    return false;
  }
  function copyUniform(uniforms, key, value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      if (uniforms[key]) {
        const dest = uniforms[key];
        for (let i2 = 0, len = value.length; i2 < len; ++i2) {
          dest[i2] = value[i2];
        }
      } else {
        uniforms[key] = value.slice();
      }
    } else {
      uniforms[key] = value;
    }
  }
  function checkUniformArray(value) {
    if (value.length === 0) {
      return false;
    }
    const checkLength = Math.min(value.length, 16);
    for (let i2 = 0; i2 < checkLength; ++i2) {
      if (!Number.isFinite(value[i2])) {
        return false;
      }
    }
    return true;
  }
  function getSamplerSetter() {
    let cache3 = null;
    return (gl, location, value) => {
      const update = cache3 !== value;
      if (update) {
        gl.uniform1i(location, value);
        cache3 = value;
      }
      return update;
    };
  }
  function getArraySetter(functionName, toArray, size, uniformSetter) {
    let cache3 = null;
    let cacheLength = null;
    return (gl, location, value) => {
      const arrayValue = toArray(value, size);
      const length = arrayValue.length;
      let update = false;
      if (cache3 === null) {
        cache3 = new Float32Array(length);
        cacheLength = length;
        update = true;
      } else {
        assert6(cacheLength === length, "Uniform length cannot change.");
        for (let i2 = 0; i2 < length; ++i2) {
          if (arrayValue[i2] !== cache3[i2]) {
            update = true;
            break;
          }
        }
      }
      if (update) {
        uniformSetter(gl, functionName, location, arrayValue);
        cache3.set(arrayValue);
      }
      return update;
    };
  }
  function setVectorUniform(gl, functionName, location, value) {
    gl[functionName](location, value);
  }
  function setMatrixUniform(gl, functionName, location, value) {
    gl[functionName](location, false, value);
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js
  var GL_BYTE = 5120;
  var GL_UNSIGNED_BYTE = 5121;
  var GL_SHORT = 5122;
  var GL_UNSIGNED_SHORT = 5123;
  var GL_POINTS = 0;
  var GL_LINES = 1;
  var GL_LINE_LOOP = 2;
  var GL_LINE_STRIP = 3;
  var GL_TRIANGLES = 4;
  var GL_TRIANGLE_STRIP = 5;
  var GL_TRIANGLE_FAN = 6;
  var GL_FLOAT = 5126;
  var GL_FLOAT_VEC2 = 35664;
  var GL_FLOAT_VEC3 = 35665;
  var GL_FLOAT_VEC4 = 35666;
  var GL_INT = 5124;
  var GL_INT_VEC2 = 35667;
  var GL_INT_VEC3 = 35668;
  var GL_INT_VEC4 = 35669;
  var GL_UNSIGNED_INT = 5125;
  var GL_UNSIGNED_INT_VEC2 = 36294;
  var GL_UNSIGNED_INT_VEC3 = 36295;
  var GL_UNSIGNED_INT_VEC4 = 36296;
  var GL_BOOL = 35670;
  var GL_BOOL_VEC2 = 35671;
  var GL_BOOL_VEC3 = 35672;
  var GL_BOOL_VEC4 = 35673;
  var GL_FLOAT_MAT2 = 35674;
  var GL_FLOAT_MAT3 = 35675;
  var GL_FLOAT_MAT4 = 35676;
  var GL_FLOAT_MAT2x3 = 35685;
  var GL_FLOAT_MAT2x4 = 35686;
  var GL_FLOAT_MAT3x2 = 35687;
  var GL_FLOAT_MAT3x4 = 35688;
  var GL_FLOAT_MAT4x2 = 35689;
  var GL_FLOAT_MAT4x3 = 35690;
  var COMPOSITE_GL_TYPES = {
    [GL_FLOAT]: [GL_FLOAT, 1, "float"],
    [GL_FLOAT_VEC2]: [GL_FLOAT, 2, "vec2"],
    [GL_FLOAT_VEC3]: [GL_FLOAT, 3, "vec3"],
    [GL_FLOAT_VEC4]: [GL_FLOAT, 4, "vec4"],
    [GL_INT]: [GL_INT, 1, "int"],
    [GL_INT_VEC2]: [GL_INT, 2, "ivec2"],
    [GL_INT_VEC3]: [GL_INT, 3, "ivec3"],
    [GL_INT_VEC4]: [GL_INT, 4, "ivec4"],
    [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, "uint"],
    [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, "uvec2"],
    [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, "uvec3"],
    [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, "uvec4"],
    [GL_BOOL]: [GL_FLOAT, 1, "bool"],
    [GL_BOOL_VEC2]: [GL_FLOAT, 2, "bvec2"],
    [GL_BOOL_VEC3]: [GL_FLOAT, 3, "bvec3"],
    [GL_BOOL_VEC4]: [GL_FLOAT, 4, "bvec4"],
    [GL_FLOAT_MAT2]: [GL_FLOAT, 8, "mat2"],
    [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, "mat2x3"],
    [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, "mat2x4"],
    [GL_FLOAT_MAT3]: [GL_FLOAT, 12, "mat3"],
    [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, "mat3x2"],
    [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, "mat3x4"],
    [GL_FLOAT_MAT4]: [GL_FLOAT, 16, "mat4"],
    [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, "mat4x2"],
    [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, "mat4x3"]
  };
  function getPrimitiveDrawMode(drawMode) {
    switch (drawMode) {
      case GL_POINTS:
        return GL_POINTS;
      case GL_LINES:
        return GL_LINES;
      case GL_LINE_STRIP:
        return GL_LINES;
      case GL_LINE_LOOP:
        return GL_LINES;
      case GL_TRIANGLES:
        return GL_TRIANGLES;
      case GL_TRIANGLE_STRIP:
        return GL_TRIANGLES;
      case GL_TRIANGLE_FAN:
        return GL_TRIANGLES;
      default:
        assert6(false);
        return 0;
    }
  }
  function decomposeCompositeGLType(compositeGLType) {
    const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
    if (!typeAndSize) {
      return null;
    }
    const [type, components] = typeAndSize;
    return {
      type,
      components
    };
  }
  function getCompositeGLType(type, components) {
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
        type = GL_FLOAT;
        break;
      default:
    }
    for (const glType in COMPOSITE_GL_TYPES) {
      const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];
      if (compType === type && compComponents === components) {
        return {
          glType,
          name
        };
      }
    }
    return null;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js
  var ProgramConfiguration = class {
    constructor(program) {
      this.id = program.id;
      this.attributeInfos = [];
      this.attributeInfosByName = {};
      this.attributeInfosByLocation = [];
      this.varyingInfos = [];
      this.varyingInfosByName = {};
      Object.seal(this);
      this._readAttributesFromProgram(program);
      this._readVaryingsFromProgram(program);
    }
    getAttributeInfo(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return this.attributeInfosByLocation[location];
      }
      return this.attributeInfosByName[locationOrName] || null;
    }
    getAttributeLocation(locationOrName) {
      const attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.location : -1;
    }
    getAttributeAccessor(locationOrName) {
      const attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.accessor : null;
    }
    getVaryingInfo(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return this.varyingInfos[location];
      }
      return this.varyingInfosByName[locationOrName] || null;
    }
    getVaryingIndex(locationOrName) {
      const varying = this.getVaryingInfo();
      return varying ? varying.location : -1;
    }
    getVaryingAccessor(locationOrName) {
      const varying = this.getVaryingInfo();
      return varying ? varying.accessor : null;
    }
    _readAttributesFromProgram(program) {
      const {
        gl
      } = program;
      const count2 = gl.getProgramParameter(program.handle, 35721);
      for (let index = 0; index < count2; index++) {
        const {
          name,
          type,
          size
        } = gl.getActiveAttrib(program.handle, index);
        const location = gl.getAttribLocation(program.handle, name);
        if (location >= 0) {
          this._addAttribute(location, name, type, size);
        }
      }
      this.attributeInfos.sort((a2, b2) => a2.location - b2.location);
    }
    _readVaryingsFromProgram(program) {
      const {
        gl
      } = program;
      if (!isWebGL2(gl)) {
        return;
      }
      const count2 = gl.getProgramParameter(program.handle, 35971);
      for (let location = 0; location < count2; location++) {
        const {
          name,
          type,
          size
        } = gl.getTransformFeedbackVarying(program.handle, location);
        this._addVarying(location, name, type, size);
      }
      this.varyingInfos.sort((a2, b2) => a2.location - b2.location);
    }
    _addAttribute(location, name, compositeType, size) {
      const {
        type,
        components
      } = decomposeCompositeGLType(compositeType);
      const accessor = {
        type,
        size: size * components
      };
      this._inferProperties(location, name, accessor);
      const attributeInfo = {
        location,
        name,
        accessor: new Accessor(accessor)
      };
      this.attributeInfos.push(attributeInfo);
      this.attributeInfosByLocation[location] = attributeInfo;
      this.attributeInfosByName[attributeInfo.name] = attributeInfo;
    }
    _inferProperties(location, name, accessor) {
      if (/instance/i.test(name)) {
        accessor.divisor = 1;
      }
    }
    _addVarying(location, name, compositeType, size) {
      const {
        type,
        components
      } = decomposeCompositeGLType(compositeType);
      const accessor = new Accessor({
        type,
        size: size * components
      });
      const varying = {
        location,
        name,
        accessor
      };
      this.varyingInfos.push(varying);
      this.varyingInfosByName[varying.name] = varying;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/program.js
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var GL_SEPARATE_ATTRIBS = 35981;
  var V6_DEPRECATED_METHODS = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
  var Program = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Program";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Program", "v6.0", V6_DEPRECATED_METHODS);
      this._isCached = false;
      this.initialize(props);
      Object.seal(this);
      this._setId(props.id);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        hash,
        vs: vs7,
        fs: fs4,
        varyings,
        bufferMode = GL_SEPARATE_ATTRIBS
      } = props;
      this.hash = hash || "";
      this.vs = typeof vs7 === "string" ? new VertexShader(this.gl, {
        id: "".concat(props.id, "-vs"),
        source: vs7
      }) : vs7;
      this.fs = typeof fs4 === "string" ? new FragmentShader(this.gl, {
        id: "".concat(props.id, "-fs"),
        source: fs4
      }) : fs4;
      assert6(this.vs instanceof VertexShader);
      assert6(this.fs instanceof FragmentShader);
      this.uniforms = {};
      this._textureUniforms = {};
      if (varyings && varyings.length > 0) {
        assertWebGL2Context(this.gl);
        this.varyings = varyings;
        this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }
      this._compileAndLink();
      this._readUniformLocationsFromLinkedProgram();
      this.configuration = new ProgramConfiguration(this);
      return this.setProps(props);
    }
    delete() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isCached) {
        return this;
      }
      return super.delete(options);
    }
    setProps(props) {
      if ("uniforms" in props) {
        this.setUniforms(props.uniforms);
      }
      return this;
    }
    draw(_ref) {
      let {
        logPriority,
        drawMode = 4,
        vertexCount,
        offset = 0,
        start,
        end,
        isIndexed = false,
        indexType = 5123,
        instanceCount = 0,
        isInstanced = instanceCount > 0,
        vertexArray = null,
        transformFeedback,
        framebuffer,
        parameters = {},
        uniforms,
        samplers
      } = _ref;
      if (uniforms || samplers) {
        log2.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
        this.setUniforms(uniforms || {});
      }
      if (log2.priority >= logPriority) {
        const fb = framebuffer ? framebuffer.id : "default";
        const message = "mode=".concat(getKey(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(getKey(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
        log2.log(logPriority, message)();
      }
      assert6(vertexArray);
      this.gl.useProgram(this.handle);
      if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
        return false;
      }
      vertexArray.bindForDraw(vertexCount, instanceCount, () => {
        if (framebuffer !== void 0) {
          parameters = Object.assign({}, parameters, {
            framebuffer
          });
        }
        if (transformFeedback) {
          const primitiveMode = getPrimitiveDrawMode(drawMode);
          transformFeedback.begin(primitiveMode);
        }
        this._bindTextures();
        withParameters(this.gl, parameters, () => {
          if (isIndexed && isInstanced) {
            this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
          } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {
            this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
          } else if (isIndexed) {
            this.gl.drawElements(drawMode, vertexCount, indexType, offset);
          } else if (isInstanced) {
            this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
          } else {
            this.gl.drawArrays(drawMode, offset, vertexCount);
          }
        });
        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      return true;
    }
    setUniforms() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (log2.priority >= 2) {
        checkUniformValues(uniforms, this.id, this._uniformSetters);
      }
      this.gl.useProgram(this.handle);
      for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        const uniformSetter = this._uniformSetters[uniformName];
        if (uniformSetter) {
          let value = uniform;
          let textureUpdate = false;
          if (value instanceof Framebuffer) {
            value = value.texture;
          }
          if (value instanceof Texture) {
            textureUpdate = this.uniforms[uniformName] !== uniform;
            if (textureUpdate) {
              if (uniformSetter.textureIndex === void 0) {
                uniformSetter.textureIndex = this._textureIndexCounter++;
              }
              const texture = value;
              const {
                textureIndex
              } = uniformSetter;
              texture.bind(textureIndex);
              value = textureIndex;
              this._textureUniforms[uniformName] = texture;
            } else {
              value = uniformSetter.textureIndex;
            }
          } else if (this._textureUniforms[uniformName]) {
            delete this._textureUniforms[uniformName];
          }
          if (uniformSetter(value) || textureUpdate) {
            copyUniform(this.uniforms, uniformName, uniform);
          }
        }
      }
      return this;
    }
    _areTexturesRenderable() {
      let texturesRenderable = true;
      for (const uniformName in this._textureUniforms) {
        const texture = this._textureUniforms[uniformName];
        texture.update();
        texturesRenderable = texturesRenderable && texture.loaded;
      }
      return texturesRenderable;
    }
    _bindTextures() {
      for (const uniformName in this._textureUniforms) {
        const textureIndex = this._uniformSetters[uniformName].textureIndex;
        this._textureUniforms[uniformName].bind(textureIndex);
      }
    }
    _createHandle() {
      return this.gl.createProgram();
    }
    _deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
    _getOptionsFromHandle(handle) {
      const shaderHandles = this.gl.getAttachedShaders(handle);
      const opts = {};
      for (const shaderHandle of shaderHandles) {
        const type = this.gl.getShaderParameter(this.handle, 35663);
        switch (type) {
          case 35633:
            opts.vs = new VertexShader({
              handle: shaderHandle
            });
            break;
          case 35632:
            opts.fs = new FragmentShader({
              handle: shaderHandle
            });
            break;
          default:
        }
      }
      return opts;
    }
    _getParameter(pname) {
      return this.gl.getProgramParameter(this.handle, pname);
    }
    _setId(id) {
      if (!id) {
        const programName = this._getName();
        this.id = uid(programName);
      }
    }
    _getName() {
      let programName = this.vs.getName() || this.fs.getName();
      programName = programName.replace(/shader/i, "");
      programName = programName ? "".concat(programName, "-program") : "program";
      return programName;
    }
    _compileAndLink() {
      const {
        gl
      } = this;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      log2.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
      gl.linkProgram(this.handle);
      log2.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
      if (gl.debug || log2.level > 0) {
        const linked = gl.getProgramParameter(this.handle, 35714);
        if (!linked) {
          throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
        }
        gl.validateProgram(this.handle);
        const validated = gl.getProgramParameter(this.handle, 35715);
        if (!validated) {
          throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
        }
      }
    }
    _readUniformLocationsFromLinkedProgram() {
      const {
        gl
      } = this;
      this._uniformSetters = {};
      this._uniformCount = this._getParameter(35718);
      for (let i2 = 0; i2 < this._uniformCount; i2++) {
        const info = this.gl.getActiveUniform(this.handle, i2);
        const {
          name
        } = parseUniformName(info.name);
        let location = gl.getUniformLocation(this.handle, name);
        this._uniformSetters[name] = getUniformSetter(gl, location, info);
        if (info.size > 1) {
          for (let l2 = 0; l2 < info.size; l2++) {
            location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l2, "]"));
            this._uniformSetters["".concat(name, "[").concat(l2, "]")] = getUniformSetter(gl, location, info);
          }
        }
      }
      this._textureIndexCounter = 0;
    }
    getActiveUniforms(uniformIndices, pname) {
      return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
    }
    getUniformBlockIndex(blockName) {
      return this.gl2.getUniformBlockIndex(this.handle, blockName);
    }
    getActiveUniformBlockParameter(blockIndex, pname) {
      return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
    }
    uniformBlockBinding(blockIndex, blockBinding) {
      this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/query.js
  var GL_QUERY_RESULT = 34918;
  var GL_QUERY_RESULT_AVAILABLE = 34919;
  var GL_TIME_ELAPSED_EXT = 35007;
  var GL_GPU_DISJOINT_EXT2 = 36795;
  var GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
  var GL_ANY_SAMPLES_PASSED = 35887;
  var GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
  var Query = class _Query extends Resource {
    get [Symbol.toStringTag]() {
      return "Query";
    }
    static isSupported(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      const webgl2 = isWebGL2(gl);
      const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);
      let supported = webgl2 || hasTimerQuery;
      for (const key of opts) {
        switch (key) {
          case "queries":
            supported = supported && webgl2;
            break;
          case "timers":
            supported = supported && hasTimerQuery;
            break;
          default:
            assert6(false);
        }
      }
      return supported;
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.target = null;
      this._queryPending = false;
      this._pollingPromise = null;
      Object.seal(this);
    }
    beginTimeElapsedQuery() {
      return this.begin(GL_TIME_ELAPSED_EXT);
    }
    beginOcclusionQuery() {
      let {
        conservative = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
    }
    beginTransformFeedbackQuery() {
      return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
    }
    begin(target) {
      if (this._queryPending) {
        return this;
      }
      this.target = target;
      this.gl2.beginQuery(this.target, this.handle);
      return this;
    }
    end() {
      if (this._queryPending) {
        return this;
      }
      if (this.target) {
        this.gl2.endQuery(this.target);
        this.target = null;
        this._queryPending = true;
      }
      return this;
    }
    isResultAvailable() {
      if (!this._queryPending) {
        return false;
      }
      const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
      if (resultAvailable) {
        this._queryPending = false;
      }
      return resultAvailable;
    }
    isTimerDisjoint() {
      return this.gl2.getParameter(GL_GPU_DISJOINT_EXT2);
    }
    getResult() {
      return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
    }
    getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
    createPoll() {
      let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
      if (this._pollingPromise) {
        return this._pollingPromise;
      }
      let counter2 = 0;
      this._pollingPromise = new Promise((resolve2, reject) => {
        const poll = () => {
          if (this.isResultAvailable()) {
            resolve2(this.getResult());
            this._pollingPromise = null;
          } else if (counter2++ > limit) {
            reject("Timed out");
            this._pollingPromise = null;
          } else {
            requestAnimationFrame(poll);
          }
        };
        requestAnimationFrame(poll);
      });
      return this._pollingPromise;
    }
    _createHandle() {
      return _Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
    }
    _deleteHandle() {
      this.gl2.deleteQuery(this.handle);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js
  var TransformFeedback = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGL2Context(gl);
      super(gl, props);
      this.initialize(props);
      this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]);
      Object.seal(this);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.buffers = {};
      this.unused = {};
      this.configuration = null;
      this.bindOnUse = true;
      if (!isObjectEmpty2(this.buffers)) {
        this.bind(() => this._unbindBuffers());
      }
      this.setProps(props);
      return this;
    }
    setProps(props) {
      if ("program" in props) {
        this.configuration = props.program && props.program.configuration;
      }
      if ("configuration" in props) {
        this.configuration = props.configuration;
      }
      if ("bindOnUse" in props) {
        props = props.bindOnUse;
      }
      if ("buffers" in props) {
        this.setBuffers(props.buffers);
      }
    }
    setBuffers() {
      let buffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.bind(() => {
        for (const bufferName in buffers) {
          this.setBuffer(bufferName, buffers[bufferName]);
        }
      });
      return this;
    }
    setBuffer(locationOrName, bufferOrParams) {
      const location = this._getVaryingIndex(locationOrName);
      const {
        buffer,
        byteSize,
        byteOffset
      } = this._getBufferParams(bufferOrParams);
      if (location < 0) {
        this.unused[locationOrName] = buffer;
        log2.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
        return this;
      }
      this.buffers[location] = bufferOrParams;
      if (!this.bindOnUse) {
        this._bindBuffer(location, buffer, byteOffset, byteSize);
      }
      return this;
    }
    begin() {
      let primitiveMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.gl.bindTransformFeedback(36386, this.handle);
      this._bindBuffers();
      this.gl.beginTransformFeedback(primitiveMode);
      return this;
    }
    end() {
      this.gl.endTransformFeedback();
      this._unbindBuffers();
      this.gl.bindTransformFeedback(36386, null);
      return this;
    }
    _getBufferParams(bufferOrParams) {
      let byteOffset;
      let byteSize;
      let buffer;
      if (bufferOrParams instanceof Buffer2 === false) {
        buffer = bufferOrParams.buffer;
        byteSize = bufferOrParams.byteSize;
        byteOffset = bufferOrParams.byteOffset;
      } else {
        buffer = bufferOrParams;
      }
      if (byteOffset !== void 0 || byteSize !== void 0) {
        byteOffset = byteOffset || 0;
        byteSize = byteSize || buffer.byteLength - byteOffset;
      }
      return {
        buffer,
        byteOffset,
        byteSize
      };
    }
    _getVaryingInfo(locationOrName) {
      return this.configuration && this.configuration.getVaryingInfo(locationOrName);
    }
    _getVaryingIndex(locationOrName) {
      if (this.configuration) {
        return this.configuration.getVaryingInfo(locationOrName).location;
      }
      const location = Number(locationOrName);
      return Number.isFinite(location) ? location : -1;
    }
    _bindBuffers() {
      if (this.bindOnUse) {
        for (const bufferIndex in this.buffers) {
          const {
            buffer,
            byteSize,
            byteOffset
          } = this._getBufferParams(this.buffers[bufferIndex]);
          this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
        }
      }
    }
    _unbindBuffers() {
      if (this.bindOnUse) {
        for (const bufferIndex in this.buffers) {
          this._bindBuffer(bufferIndex, null);
        }
      }
    }
    _bindBuffer(index, buffer) {
      let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      let byteSize = arguments.length > 3 ? arguments[3] : void 0;
      const handle = buffer && buffer.handle;
      if (!handle || byteSize === void 0) {
        this.gl.bindBufferBase(35982, index, handle);
      } else {
        this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
      }
      return this;
    }
    _createHandle() {
      return this.gl.createTransformFeedback();
    }
    _deleteHandle() {
      this.gl.deleteTransformFeedback(this.handle);
    }
    _bindHandle(handle) {
      this.gl.bindTransformFeedback(36386, this.handle);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js
  var arrayBuffer = null;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type, length) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
    return new Type(scratchArrayBuffer, 0, length);
  }
  function fillArray(_ref) {
    let {
      target,
      source,
      start = 0,
      count: count2 = 1
    } = _ref;
    const length = source.length;
    const total = count2 * length;
    let copied = 0;
    for (let i2 = start; copied < length; copied++) {
      target[i2++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return target;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js
  var ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
  var VertexArrayObject = class _VertexArrayObject extends Resource {
    get [Symbol.toStringTag]() {
      return "VertexArrayObject";
    }
    static isSupported(gl) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (options.constantAttributeZero) {
        return isWebGL2(gl) || getBrowser() === "Chrome";
      }
      return true;
    }
    static getDefaultArray(gl) {
      gl.luma = gl.luma || {};
      if (!gl.luma.defaultVertexArray) {
        gl.luma.defaultVertexArray = new _VertexArrayObject(gl, {
          handle: null,
          isDefaultArray: true
        });
      }
      return gl.luma.defaultVertexArray;
    }
    static getMaxAttributes(gl) {
      _VertexArrayObject.MAX_ATTRIBUTES = _VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
      return _VertexArrayObject.MAX_ATTRIBUTES;
    }
    static setConstant(gl, location, array) {
      switch (array.constructor) {
        case Float32Array:
          _VertexArrayObject._setConstantFloatArray(gl, location, array);
          break;
        case Int32Array:
          _VertexArrayObject._setConstantIntArray(gl, location, array);
          break;
        case Uint32Array:
          _VertexArrayObject._setConstantUintArray(gl, location, array);
          break;
        default:
          assert6(false);
      }
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const id = opts.id || opts.program && opts.program.id;
      super(gl, Object.assign({}, opts, {
        id
      }));
      this.buffer = null;
      this.bufferValue = null;
      this.isDefaultArray = opts.isDefaultArray || false;
      this.gl2 = gl;
      this.initialize(opts);
      Object.seal(this);
    }
    delete() {
      super.delete();
      if (this.buffer) {
        this.buffer.delete();
      }
      return this;
    }
    get MAX_ATTRIBUTES() {
      return _VertexArrayObject.getMaxAttributes(this.gl);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.setProps(props);
    }
    setProps(props) {
      return this;
    }
    setElementBuffer() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert6(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
      this.bind(() => {
        this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
      });
      return this;
    }
    setBuffer(location, buffer, accessor) {
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, accessor);
      }
      const {
        size,
        type,
        stride,
        offset,
        normalized,
        integer,
        divisor
      } = accessor;
      const {
        gl,
        gl2
      } = this;
      location = Number(location);
      this.bind(() => {
        gl.bindBuffer(34962, buffer.handle);
        if (integer) {
          assert6(isWebGL2(gl));
          gl2.vertexAttribIPointer(location, size, type, stride, offset);
        } else {
          gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        }
        gl.enableVertexAttribArray(location);
        gl2.vertexAttribDivisor(location, divisor || 0);
      });
      return this;
    }
    enable(location) {
      let enable2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const disablingAttributeZero = !enable2 && location === 0 && !_VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      });
      if (!disablingAttributeZero) {
        location = Number(location);
        this.bind(() => enable2 ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
      }
      return this;
    }
    getConstantBuffer(elementCount, value) {
      const constantValue = this._normalizeConstantArrayValue(value);
      const byteLength = constantValue.byteLength * elementCount;
      const length = constantValue.length * elementCount;
      let updateNeeded = !this.buffer;
      this.buffer = this.buffer || new Buffer2(this.gl, byteLength);
      updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
      updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
      if (updateNeeded) {
        const typedArray = getScratchArray(value.constructor, length);
        fillArray({
          target: typedArray,
          source: constantValue,
          start: 0,
          count: length
        });
        this.buffer.subData(typedArray);
        this.bufferValue = value;
      }
      return this.buffer;
    }
    _normalizeConstantArrayValue(arrayValue) {
      if (Array.isArray(arrayValue)) {
        return new Float32Array(arrayValue);
      }
      return arrayValue;
    }
    _compareConstantArrayValues(v1, v2) {
      if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
        return false;
      }
      for (let i2 = 0; i2 < v1.length; ++i2) {
        if (v1[i2] !== v2[i2]) {
          return false;
        }
      }
      return true;
    }
    static _setConstantFloatArray(gl, location, array) {
      switch (array.length) {
        case 1:
          gl.vertexAttrib1fv(location, array);
          break;
        case 2:
          gl.vertexAttrib2fv(location, array);
          break;
        case 3:
          gl.vertexAttrib3fv(location, array);
          break;
        case 4:
          gl.vertexAttrib4fv(location, array);
          break;
        default:
          assert6(false);
      }
    }
    static _setConstantIntArray(gl, location, array) {
      assert6(isWebGL2(gl));
      switch (array.length) {
        case 1:
          gl.vertexAttribI1iv(location, array);
          break;
        case 2:
          gl.vertexAttribI2iv(location, array);
          break;
        case 3:
          gl.vertexAttribI3iv(location, array);
          break;
        case 4:
          gl.vertexAttribI4iv(location, array);
          break;
        default:
          assert6(false);
      }
    }
    static _setConstantUintArray(gl, location, array) {
      assert6(isWebGL2(gl));
      switch (array.length) {
        case 1:
          gl.vertexAttribI1uiv(location, array);
          break;
        case 2:
          gl.vertexAttribI2uiv(location, array);
          break;
        case 3:
          gl.vertexAttribI3uiv(location, array);
          break;
        case 4:
          gl.vertexAttribI4uiv(location, array);
          break;
        default:
          assert6(false);
      }
    }
    _createHandle() {
      const gl2 = this.gl;
      return gl2.createVertexArray();
    }
    _deleteHandle(handle) {
      this.gl2.deleteVertexArray(handle);
      return [this.elements];
    }
    _bindHandle(handle) {
      this.gl2.bindVertexArray(handle);
    }
    _getParameter(pname, _ref) {
      let {
        location
      } = _ref;
      assert6(Number.isFinite(location));
      return this.bind(() => {
        switch (pname) {
          case 34373:
            return this.gl.getVertexAttribOffset(location, pname);
          default:
            return this.gl.getVertexAttrib(location, pname);
        }
      });
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js
  var ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
  var MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
  var DEPRECATIONS_V6 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
  var VertexArray = class {
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const id = opts.id || opts.program && opts.program.id;
      this.id = id;
      this.gl = gl;
      this.configuration = null;
      this.elements = null;
      this.elementsAccessor = null;
      this.values = null;
      this.accessors = null;
      this.unused = null;
      this.drawParams = null;
      this.buffer = null;
      this.attributes = {};
      this.vertexArrayObject = new VertexArrayObject(gl);
      stubRemovedMethods(this, "VertexArray", "v6.0", DEPRECATIONS_V6);
      this.initialize(opts);
      Object.seal(this);
    }
    delete() {
      if (this.buffer) {
        this.buffer.delete();
      }
      this.vertexArrayObject.delete();
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.reset();
      this.configuration = null;
      this.bindOnUse = false;
      return this.setProps(props);
    }
    reset() {
      this.elements = null;
      this.elementsAccessor = null;
      const {
        MAX_ATTRIBUTES
      } = this.vertexArrayObject;
      this.values = new Array(MAX_ATTRIBUTES).fill(null);
      this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
      this.unused = {};
      this.drawParams = null;
      return this;
    }
    setProps(props) {
      if ("program" in props) {
        this.configuration = props.program && props.program.configuration;
      }
      if ("configuration" in props) {
        this.configuration = props.configuration;
      }
      if ("attributes" in props) {
        this.setAttributes(props.attributes);
      }
      if ("elements" in props) {
        this.setElementBuffer(props.elements);
      }
      if ("bindOnUse" in props) {
        props = props.bindOnUse;
      }
      return this;
    }
    clearDrawParams() {
      this.drawParams = null;
    }
    getDrawParams() {
      this.drawParams = this.drawParams || this._updateDrawParams();
      return this.drawParams;
    }
    setAttributes(attributes) {
      Object.assign(this.attributes, attributes);
      this.vertexArrayObject.bind(() => {
        for (const locationOrName in attributes) {
          const value = attributes[locationOrName];
          this._setAttribute(locationOrName, value);
        }
        this.gl.bindBuffer(34962, null);
      });
      return this;
    }
    setElementBuffer() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.elements = elementBuffer;
      this.elementsAccessor = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
      return this;
    }
    setBuffer(locationOrName, buffer) {
      let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, appAccessor);
      }
      const {
        location,
        accessor
      } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
      if (location >= 0) {
        this.values[location] = buffer;
        this.accessors[location] = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setBuffer(location, buffer, accessor);
      }
      return this;
    }
    setConstant(locationOrName, arrayValue) {
      let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const {
        location,
        accessor
      } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
        size: arrayValue.length
      }, appAccessor));
      if (location >= 0) {
        arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
        this.values[location] = arrayValue;
        this.accessors[location] = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.enable(location, false);
      }
      return this;
    }
    unbindBuffers() {
      this.vertexArrayObject.bind(() => {
        if (this.elements) {
          this.vertexArrayObject.setElementBuffer(null);
        }
        this.buffer = this.buffer || new Buffer2(this.gl, {
          accessor: {
            size: 4
          }
        });
        for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          if (this.values[location] instanceof Buffer2) {
            this.gl.disableVertexAttribArray(location);
            this.gl.bindBuffer(34962, this.buffer.handle);
            this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
          }
        }
      });
      return this;
    }
    bindBuffers() {
      this.vertexArrayObject.bind(() => {
        if (this.elements) {
          this.setElementBuffer(this.elements);
        }
        for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          const buffer = this.values[location];
          if (buffer instanceof Buffer2) {
            this.setBuffer(location, buffer);
          }
        }
      });
      return this;
    }
    bindForDraw(vertexCount, instanceCount, func) {
      let value;
      this.vertexArrayObject.bind(() => {
        this._setConstantAttributes(vertexCount, instanceCount);
        value = func();
      });
      return value;
    }
    _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
      const INVALID_RESULT = {
        location: -1,
        accessor: null
      };
      const {
        location,
        name
      } = this._getAttributeIndex(locationOrName);
      if (!Number.isFinite(location) || location < 0) {
        this.unused[locationOrName] = value;
        log2.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
        return INVALID_RESULT;
      }
      const accessInfo = this._getAttributeInfo(name || location);
      if (!accessInfo) {
        return INVALID_RESULT;
      }
      const currentAccessor = this.accessors[location] || {};
      const accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
      const {
        size,
        type
      } = accessor;
      assert6(Number.isFinite(size) && Number.isFinite(type));
      return {
        location,
        accessor
      };
    }
    _getAttributeInfo(attributeName) {
      return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
    _getAttributeIndex(locationOrName) {
      const location = Number(locationOrName);
      if (Number.isFinite(location)) {
        return {
          location
        };
      }
      const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
      const name = multiLocation ? multiLocation[1] : locationOrName;
      const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
      if (this.configuration) {
        return {
          location: this.configuration.getAttributeLocation(name) + locationOffset,
          name
        };
      }
      return {
        location: -1
      };
    }
    _setAttribute(locationOrName, value) {
      if (value instanceof Buffer2) {
        this.setBuffer(locationOrName, value);
      } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer2) {
        const buffer = value[0];
        const accessor = value[1];
        this.setBuffer(locationOrName, buffer, accessor);
      } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
        const constant = value;
        this.setConstant(locationOrName, constant);
      } else if (value.buffer instanceof Buffer2) {
        const accessor = value;
        this.setBuffer(locationOrName, accessor.buffer, accessor);
      } else {
        throw new Error(ERR_ATTRIBUTE_TYPE);
      }
    }
    _setConstantAttributes(vertexCount, instanceCount) {
      const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
      let constant = this.values[0];
      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttributeZero(constant, elementCount);
      }
      for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        constant = this.values[location];
        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttribute(location, constant);
        }
      }
    }
    _setConstantAttributeZero(constant, elementCount) {
      if (VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      })) {
        this._setConstantAttribute(0, constant);
        return;
      }
      const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
      this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
    _setConstantAttribute(location, constant) {
      VertexArrayObject.setConstant(this.gl, location, constant);
    }
    _updateDrawParams() {
      const drawParams = {
        isIndexed: false,
        isInstanced: false,
        indexCount: Infinity,
        vertexCount: Infinity,
        instanceCount: Infinity
      };
      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        this._updateDrawParamsForLocation(drawParams, location);
      }
      if (this.elements) {
        drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
        drawParams.isIndexed = true;
        drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
        drawParams.indexOffset = this.elementsAccessor.offset || 0;
      }
      if (drawParams.indexCount === Infinity) {
        drawParams.indexCount = 0;
      }
      if (drawParams.vertexCount === Infinity) {
        drawParams.vertexCount = 0;
      }
      if (drawParams.instanceCount === Infinity) {
        drawParams.instanceCount = 0;
      }
      return drawParams;
    }
    _updateDrawParamsForLocation(drawParams, location) {
      const value = this.values[location];
      const accessor = this.accessors[location];
      if (!value) {
        return;
      }
      const {
        divisor
      } = accessor;
      const isInstanced = divisor > 0;
      drawParams.isInstanced = drawParams.isInstanced || isInstanced;
      if (value instanceof Buffer2) {
        const buffer = value;
        if (isInstanced) {
          const instanceCount = buffer.getVertexCount(accessor);
          drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
        } else {
          const vertexCount = buffer.getVertexCount(accessor);
          drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
        }
      }
    }
    setElements() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      log2.deprecated("setElements", "setElementBuffer")();
      return this.setElementBuffer(elementBuffer, accessor);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js
  function formatArrayValue(v2, opts) {
    const {
      maxElts = 16,
      size = 1
    } = opts;
    let string = "[";
    for (let i2 = 0; i2 < v2.length && i2 < maxElts; ++i2) {
      if (i2 > 0) {
        string += ",".concat(i2 % size === 0 ? " " : "");
      }
      string += formatValue(v2[i2], opts);
    }
    const terminator = v2.length > maxElts ? "..." : "]";
    return "".concat(string).concat(terminator);
  }
  function formatValue(v2) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const EPSILON3 = 1e-16;
    const {
      isInteger = false
    } = opts;
    if (Array.isArray(v2) || ArrayBuffer.isView(v2)) {
      return formatArrayValue(v2, opts);
    }
    if (!Number.isFinite(v2)) {
      return String(v2);
    }
    if (Math.abs(v2) < EPSILON3) {
      return isInteger ? "0" : "0.";
    }
    if (isInteger) {
      return v2.toFixed(0);
    }
    if (Math.abs(v2) > 100 && Math.abs(v2) < 1e4) {
      return v2.toFixed(0);
    }
    const string = v2.toPrecision(2);
    const decimal = string.indexOf(".0");
    return decimal === string.length - 2 ? string.slice(0, -1) : string;
  }

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js
  function getDebugTableForUniforms(_ref) {
    let {
      header = "Uniforms",
      program,
      uniforms,
      undefinedOnly = false
    } = _ref;
    assert6(program);
    const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
    const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
    const uniformLocations = program._uniformSetters;
    const table = {};
    const uniformNames = Object.keys(uniformLocations).sort();
    let count2 = 0;
    for (const uniformName of uniformNames) {
      if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    for (const uniformName of uniformNames) {
      if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    for (const uniformName of uniformNames) {
      if (!table[uniformName]) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    let unusedCount = 0;
    const unusedTable = {};
    if (!undefinedOnly) {
      for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        if (!table[uniformName]) {
          unusedCount++;
          unusedTable[uniformName] = {
            Type: "NOT USED: ".concat(uniform),
            [header]: formatValue(uniform)
          };
        }
      }
    }
    return {
      table,
      count: count2,
      unusedTable,
      unusedCount
    };
  }
  function addUniformToTable(_ref2) {
    let {
      table,
      header,
      uniforms,
      uniformName,
      undefinedOnly
    } = _ref2;
    const value = uniforms[uniformName];
    const isDefined = isUniformDefined(value);
    if (!undefinedOnly || !isDefined) {
      table[uniformName] = {
        [header]: isDefined ? formatValue(value) : "N/A",
        "Uniform Type": isDefined ? value : "NOT PROVIDED"
      };
      return true;
    }
    return false;
  }
  function isUniformDefined(value) {
    return value !== void 0 && value !== null;
  }

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js
  function getDebugTableForVertexArray(_ref) {
    let {
      vertexArray,
      header = "Attributes"
    } = _ref;
    if (!vertexArray.configuration) {
      return {};
    }
    const table = {};
    if (vertexArray.elements) {
      table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
    }
    const attributes = vertexArray.values;
    for (const attributeLocation in attributes) {
      const info = vertexArray._getAttributeInfo(attributeLocation);
      if (info) {
        let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
        const accessor = vertexArray.accessors[info.location];
        if (accessor) {
          rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
        }
        table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
      }
    }
    return table;
  }
  function getDebugTableRow(vertexArray, attribute, accessor, header) {
    const {
      gl
    } = vertexArray;
    if (!attribute) {
      return {
        [header]: "null",
        "Format ": "N/A"
      };
    }
    let type = "NOT PROVIDED";
    let size = 1;
    let verts = 0;
    let bytes = 0;
    let isInteger;
    let marker;
    let value;
    if (accessor) {
      type = accessor.type;
      size = accessor.size;
      type = String(type).replace("Array", "");
      isInteger = type.indexOf("nt") !== -1;
    }
    if (attribute instanceof Buffer2) {
      const buffer = attribute;
      const {
        data,
        changed
      } = buffer.getDebugData();
      marker = changed ? "*" : "";
      value = data;
      bytes = buffer.byteLength;
      verts = bytes / data.BYTES_PER_ELEMENT / size;
      let format;
      if (accessor) {
        const instanced = accessor.divisor > 0;
        format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat(getKey(gl, type), ")");
      } else {
        isInteger = true;
        format = "".concat(bytes, " bytes");
      }
      return {
        [header]: "".concat(marker).concat(formatValue(value, {
          size,
          isInteger
        })),
        "Format ": format
      };
    }
    value = attribute;
    size = attribute.length;
    type = String(attribute.constructor.name).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
    return {
      [header]: "".concat(formatValue(value, {
        size,
        isInteger
      }), " (constant)"),
      "Format ": "".concat(size, "x").concat(type, " (constant)")
    };
  }
  function getGLSLDeclaration(name, accessor) {
    const {
      type,
      size
    } = accessor;
    const typeAndName = getCompositeGLType(type, size);
    return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
  }

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js
  function getDebugTableForProgramConfiguration(config2) {
    const table = {};
    const header = "Accessors for ".concat(config2.id);
    for (const attributeInfo of config2.attributeInfos) {
      if (attributeInfo) {
        const glslDeclaration = getGLSLDeclaration2(attributeInfo);
        table["in ".concat(glslDeclaration)] = {
          [header]: JSON.stringify(attributeInfo.accessor)
        };
      }
    }
    for (const varyingInfo of config2.varyingInfos) {
      if (varyingInfo) {
        const glslDeclaration = getGLSLDeclaration2(varyingInfo);
        table["out ".concat(glslDeclaration)] = {
          [header]: JSON.stringify(varyingInfo.accessor)
        };
      }
    }
    return table;
  }
  function getGLSLDeclaration2(attributeInfo) {
    const {
      type,
      size
    } = attributeInfo.accessor;
    const typeAndName = getCompositeGLType(type, size);
    if (typeAndName) {
      return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
    }
    return attributeInfo.name;
  }

  // node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js
  var isPage2 = isBrowser5() && typeof document !== "undefined";
  var statIdCounter = 0;
  var AnimationLoop = class {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        onCreateContext = (opts) => createGLContext(opts),
        onAddHTML = null,
        onInitialize = () => {
        },
        onRender = () => {
        },
        onFinalize = () => {
        },
        onError,
        gl = null,
        glOptions = {},
        debug: debug2 = false,
        createFramebuffer = false,
        autoResizeViewport = true,
        autoResizeDrawingBuffer = true,
        stats = lumaStats.get("animation-loop-".concat(statIdCounter++))
      } = props;
      let {
        useDevicePixels = true
      } = props;
      if ("useDevicePixelRatio" in props) {
        log2.deprecated("useDevicePixelRatio", "useDevicePixels")();
        useDevicePixels = props.useDevicePixelRatio;
      }
      this.props = {
        onCreateContext,
        onAddHTML,
        onInitialize,
        onRender,
        onFinalize,
        onError,
        gl,
        glOptions,
        debug: debug2,
        createFramebuffer
      };
      this.gl = gl;
      this.needsRedraw = null;
      this.timeline = null;
      this.stats = stats;
      this.cpuTime = this.stats.get("CPU Time");
      this.gpuTime = this.stats.get("GPU Time");
      this.frameRate = this.stats.get("Frame Rate");
      this._initialized = false;
      this._running = false;
      this._animationFrameId = null;
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._cpuStartTime = 0;
      this.setProps({
        autoResizeViewport,
        autoResizeDrawingBuffer,
        useDevicePixels
      });
      this.start = this.start.bind(this);
      this.stop = this.stop.bind(this);
      this._pageLoadPromise = null;
      this._onMousemove = this._onMousemove.bind(this);
      this._onMouseleave = this._onMouseleave.bind(this);
    }
    delete() {
      this.stop();
      this._setDisplay(null);
    }
    setNeedsRedraw(reason) {
      assert6(typeof reason === "string");
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
    setProps(props) {
      if ("autoResizeViewport" in props) {
        this.autoResizeViewport = props.autoResizeViewport;
      }
      if ("autoResizeDrawingBuffer" in props) {
        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      }
      if ("useDevicePixels" in props) {
        this.useDevicePixels = props.useDevicePixels;
      }
      return this;
    }
    start() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._running) {
        return this;
      }
      this._running = true;
      const startPromise = this._getPageLoadPromise().then(() => {
        if (!this._running || this._initialized) {
          return null;
        }
        this._createWebGLContext(opts);
        this._createFramebuffer();
        this._startEventHandling();
        this._initializeCallbackData();
        this._updateCallbackData();
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
        this._gpuTimeQuery = Query.isSupported(this.gl, ["timers"]) ? new Query(this.gl) : null;
        this._initialized = true;
        return this.onInitialize(this.animationProps);
      }).then((appContext) => {
        if (this._running) {
          this._addCallbackData(appContext || {});
          if (appContext !== false) {
            this._startLoop();
          }
        }
      });
      if (this.props.onError) {
        startPromise.catch(this.props.onError);
      }
      return this;
    }
    redraw() {
      if (this.isContextLost()) {
        return this;
      }
      this._beginTimers();
      this._setupFrame();
      this._updateCallbackData();
      this._renderFrame(this.animationProps);
      this._clearNeedsRedraw();
      if (this.offScreen && this.gl.commit) {
        this.gl.commit();
      }
      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }
      this._endTimers();
      return this;
    }
    stop() {
      if (this._running) {
        this._finalizeCallbackData();
        this._cancelAnimationFrame(this._animationFrameId);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._animationFrameId = null;
        this._running = false;
      }
      return this;
    }
    attachTimeline(timeline) {
      this.timeline = timeline;
      return this.timeline;
    }
    detachTimeline() {
      this.timeline = null;
    }
    waitForRender() {
      this.setNeedsRedraw("waitForRender");
      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise((resolve2) => {
          this._resolveNextFrame = resolve2;
        });
      }
      return this._nextFramePromise;
    }
    async toDataURL() {
      this.setNeedsRedraw("toDataURL");
      await this.waitForRender();
      return this.gl.canvas.toDataURL();
    }
    isContextLost() {
      return this.gl.isContextLost();
    }
    onCreateContext() {
      return this.props.onCreateContext(...arguments);
    }
    onInitialize() {
      return this.props.onInitialize(...arguments);
    }
    onRender() {
      return this.props.onRender(...arguments);
    }
    onFinalize() {
      return this.props.onFinalize(...arguments);
    }
    getHTMLControlValue(id) {
      let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const element = document.getElementById(id);
      return element ? Number(element.value) : defaultValue;
    }
    setViewParameters() {
      log2.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
      return this;
    }
    _startLoop() {
      const renderFrame = () => {
        if (!this._running) {
          return;
        }
        this.redraw();
        this._animationFrameId = this._requestAnimationFrame(renderFrame);
      };
      this._cancelAnimationFrame(this._animationFrameId);
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    }
    _getPageLoadPromise() {
      if (!this._pageLoadPromise) {
        this._pageLoadPromise = isPage2 ? new Promise((resolve2, reject) => {
          if (isPage2 && document.readyState === "complete") {
            resolve2(document);
            return;
          }
          window.addEventListener("load", () => {
            resolve2(document);
          });
        }) : Promise.resolve({});
      }
      return this._pageLoadPromise;
    }
    _setDisplay(display) {
      if (this.display) {
        this.display.delete();
        this.display.animationLoop = null;
      }
      if (display) {
        display.animationLoop = this;
      }
      this.display = display;
    }
    _cancelAnimationFrame(animationFrameId) {
      if (this.display && this.display.cancelAnimationFrame) {
        return this.display.cancelAnimationFrame(animationFrameId);
      }
      return cancelAnimationFrame(animationFrameId);
    }
    _requestAnimationFrame(renderFrameCallback) {
      if (this._running) {
        if (this.display && this.display.requestAnimationFrame) {
          return this.display.requestAnimationFrame(renderFrameCallback);
        }
        return requestAnimationFrame2(renderFrameCallback);
      }
      return void 0;
    }
    _renderFrame() {
      if (this.display) {
        this.display._renderFrame(...arguments);
        return;
      }
      this.onRender(...arguments);
    }
    _clearNeedsRedraw() {
      this.needsRedraw = null;
    }
    _setupFrame() {
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
      this._resizeFramebuffer();
    }
    _initializeCallbackData() {
      this.animationProps = {
        gl: this.gl,
        stop: this.stop,
        canvas: this.gl.canvas,
        framebuffer: this.framebuffer,
        useDevicePixels: this.useDevicePixels,
        needsRedraw: null,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        time: 0,
        _timeline: this.timeline,
        _loop: this,
        _animationLoop: this,
        _mousePosition: null
      };
    }
    _updateCallbackData() {
      const {
        width,
        height,
        aspect
      } = this._getSizeAndAspect();
      if (width !== this.animationProps.width || height !== this.animationProps.height) {
        this.setNeedsRedraw("drawing buffer resized");
      }
      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw("drawing buffer aspect changed");
      }
      this.animationProps.width = width;
      this.animationProps.height = height;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw;
      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
      if (this.timeline) {
        this.timeline.update(this.animationProps.engineTime);
      }
      this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
      this.animationProps.tock++;
      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
      this.animationProps._offScreen = this.offScreen;
    }
    _finalizeCallbackData() {
      this.onFinalize(this.animationProps);
    }
    _addCallbackData(appContext) {
      if (typeof appContext === "object" && appContext !== null) {
        this.animationProps = Object.assign({}, this.animationProps, appContext);
      }
    }
    _createWebGLContext(opts) {
      this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
      opts = Object.assign({}, opts, this.props.glOptions);
      this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);
      if (!isWebGL(this.gl)) {
        throw new Error("AnimationLoop.onCreateContext - illegal context returned");
      }
      resetParameters(this.gl);
      this._createInfoDiv();
    }
    _createInfoDiv() {
      if (this.gl.canvas && this.props.onAddHTML) {
        const wrapperDiv = document.createElement("div");
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = "relative";
        const div = document.createElement("div");
        div.style.position = "absolute";
        div.style.left = "10px";
        div.style.bottom = "10px";
        div.style.width = "300px";
        div.style.background = "white";
        wrapperDiv.appendChild(this.gl.canvas);
        wrapperDiv.appendChild(div);
        const html = this.props.onAddHTML(div);
        if (html) {
          div.innerHTML = html;
        }
      }
    }
    _getSizeAndAspect() {
      const width = this.gl.drawingBufferWidth;
      const height = this.gl.drawingBufferHeight;
      let aspect = 1;
      const {
        canvas
      } = this.gl;
      if (canvas && canvas.clientHeight) {
        aspect = canvas.clientWidth / canvas.clientHeight;
      } else if (width > 0 && height > 0) {
        aspect = width / height;
      }
      return {
        width,
        height,
        aspect
      };
    }
    _resizeViewport() {
      if (this.autoResizeViewport) {
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
      }
    }
    _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        resizeGLContext(this.gl, {
          useDevicePixels: this.useDevicePixels
        });
      }
    }
    _createFramebuffer() {
      if (this.props.createFramebuffer) {
        this.framebuffer = new Framebuffer(this.gl);
      }
    }
    _resizeFramebuffer() {
      if (this.framebuffer) {
        this.framebuffer.resize({
          width: this.gl.drawingBufferWidth,
          height: this.gl.drawingBufferHeight
        });
      }
    }
    _beginTimers() {
      this.frameRate.timeEnd();
      this.frameRate.timeStart();
      if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
        this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
      }
      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.beginTimeElapsedQuery();
      }
      this.cpuTime.timeStart();
    }
    _endTimers() {
      this.cpuTime.timeEnd();
      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.end();
      }
    }
    _startEventHandling() {
      const {
        canvas
      } = this.gl;
      if (canvas) {
        canvas.addEventListener("mousemove", this._onMousemove);
        canvas.addEventListener("mouseleave", this._onMouseleave);
      }
    }
    _onMousemove(e2) {
      this.animationProps._mousePosition = [e2.offsetX, e2.offsetY];
    }
    _onMouseleave(e2) {
      this.animationProps._mousePosition = null;
    }
  };

  // node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js
  var VERTEX_SHADER = "vs";
  var FRAGMENT_SHADER = "fs";

  // node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js
  function assert7(condition, message) {
    if (!condition) {
      throw new Error(message || "shadertools: assertion failed.");
    }
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js
  var TYPE_DEFINITIONS = {
    number: {
      validate(value, propType) {
        return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
      }
    },
    array: {
      validate(value, propType) {
        return Array.isArray(value) || ArrayBuffer.isView(value);
      }
    }
  };
  function parsePropTypes(propDefs) {
    const propTypes = {};
    for (const propName in propDefs) {
      const propDef = propDefs[propName];
      const propType = parsePropType(propDef);
      propTypes[propName] = propType;
    }
    return propTypes;
  }
  function parsePropType(propDef) {
    let type = getTypeOf(propDef);
    if (type === "object") {
      if (!propDef) {
        return {
          type: "object",
          value: null
        };
      }
      if ("type" in propDef) {
        return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
      }
      if (!("value" in propDef)) {
        return {
          type: "object",
          value: propDef
        };
      }
      type = getTypeOf(propDef.value);
      return Object.assign({
        type
      }, propDef, TYPE_DEFINITIONS[type]);
    }
    return Object.assign({
      type,
      value: propDef
    }, TYPE_DEFINITIONS[type]);
  }
  function getTypeOf(value) {
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return "array";
    }
    return typeof value;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js
  var VERTEX_SHADER2 = "vs";
  var FRAGMENT_SHADER2 = "fs";
  var ShaderModule = class {
    constructor(_ref) {
      let {
        name,
        vs: vs7,
        fs: fs4,
        dependencies = [],
        uniforms,
        getUniforms: getUniforms5,
        deprecations = [],
        defines: defines2 = {},
        inject = {},
        vertexShader,
        fragmentShader
      } = _ref;
      assert7(typeof name === "string");
      this.name = name;
      this.vs = vs7 || vertexShader;
      this.fs = fs4 || fragmentShader;
      this.getModuleUniforms = getUniforms5;
      this.dependencies = dependencies;
      this.deprecations = this._parseDeprecationDefinitions(deprecations);
      this.defines = defines2;
      this.injections = normalizeInjections(inject);
      if (uniforms) {
        this.uniforms = parsePropTypes(uniforms);
      }
    }
    getModuleSource(type) {
      let moduleSource;
      switch (type) {
        case VERTEX_SHADER2:
          moduleSource = this.vs || "";
          break;
        case FRAGMENT_SHADER2:
          moduleSource = this.fs || "";
          break;
        default:
          assert7(false);
      }
      return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
    }
    getUniforms(opts, uniforms) {
      if (this.getModuleUniforms) {
        return this.getModuleUniforms(opts, uniforms);
      }
      if (this.uniforms) {
        return this._defaultGetUniforms(opts);
      }
      return {};
    }
    getDefines() {
      return this.defines;
    }
    checkDeprecations(shaderSource, log4) {
      this.deprecations.forEach((def) => {
        if (def.regex.test(shaderSource)) {
          if (def.deprecated) {
            log4.deprecated(def.old, def.new)();
          } else {
            log4.removed(def.old, def.new)();
          }
        }
      });
    }
    _parseDeprecationDefinitions(deprecations) {
      deprecations.forEach((def) => {
        switch (def.type) {
          case "function":
            def.regex = new RegExp("\\b".concat(def.old, "\\("));
            break;
          default:
            def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
        }
      });
      return deprecations;
    }
    _defaultGetUniforms() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const uniforms = {};
      const propTypes = this.uniforms;
      for (const key in propTypes) {
        const propDef = propTypes[key];
        if (key in opts && !propDef.private) {
          if (propDef.validate) {
            assert7(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
          }
          uniforms[key] = opts[key];
        } else {
          uniforms[key] = propDef.value;
        }
      }
      return uniforms;
    }
  };
  function normalizeInjections(injections) {
    const result = {
      vs: {},
      fs: {}
    };
    for (const hook in injections) {
      let injection = injections[hook];
      const stage = hook.slice(0, 2);
      if (typeof injection === "string") {
        injection = {
          order: 0,
          injection
        };
      }
      result[stage][hook] = injection;
    }
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js
  function resolveModules(modules) {
    return getShaderDependencies(instantiateModules(modules));
  }
  function getShaderDependencies(modules) {
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
      modules,
      level: 0,
      moduleMap,
      moduleDepth
    });
    return Object.keys(moduleDepth).sort((a2, b2) => moduleDepth[b2] - moduleDepth[a2]).map((name) => moduleMap[name]);
  }
  function getDependencyGraph(_ref) {
    let {
      modules,
      level,
      moduleMap,
      moduleDepth
    } = _ref;
    if (level >= 5) {
      throw new Error("Possible loop in shader dependency graph");
    }
    for (const module of modules) {
      moduleMap[module.name] = module;
      if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
        moduleDepth[module.name] = level;
      }
    }
    for (const module of modules) {
      if (module.dependencies) {
        getDependencyGraph({
          modules: module.dependencies,
          level: level + 1,
          moduleMap,
          moduleDepth
        });
      }
    }
  }
  function instantiateModules(modules, seen) {
    return modules.map((module) => {
      if (module instanceof ShaderModule) {
        return module;
      }
      assert7(typeof module !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
      assert7(module.name, "shader module has no name");
      module = new ShaderModule(module);
      module.dependencies = instantiateModules(module.dependencies);
      return module;
    });
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js
  function isOldIE() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const navigator2 = typeof window !== "undefined" ? window.navigator || {} : {};
    const userAgent2 = opts.userAgent || navigator2.userAgent || "";
    const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
    const isTrident = userAgent2.indexOf("Trident/") !== -1;
    return isMSIE || isTrident;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js
  var GL_VENDOR = 7936;
  var GL_RENDERER = 7937;
  var GL_VERSION = 7938;
  var GL_SHADING_LANGUAGE_VERSION = 35724;
  var WEBGL_FEATURES = {
    GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true],
    GLSL_FRAG_DEPTH: ["EXT_frag_depth", true],
    GLSL_DERIVATIVES: ["OES_standard_derivatives", true],
    GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true]
  };
  var FEATURES2 = {};
  Object.keys(WEBGL_FEATURES).forEach((key) => {
    FEATURES2[key] = key;
  });
  function isWebGL22(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getContextInfo(gl) {
    const info = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
    const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    const gpuInfo = {
      gpuVendor,
      vendor,
      renderer,
      version: gl.getParameter(GL_VERSION),
      shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
    };
    return gpuInfo;
  }
  function identifyGPUVendor(vendor, renderer) {
    if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
      return "NVIDIA";
    }
    if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
      return "INTEL";
    }
    if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
      return "AMD";
    }
    return "UNKNOWN GPU";
  }
  var compiledGlslExtensions = {};
  function canCompileGLGSExtension(gl, cap) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const feature = WEBGL_FEATURES[cap];
    assert7(feature, cap);
    if (!isOldIE(opts)) {
      return true;
    }
    if (cap in compiledGlslExtensions) {
      return compiledGlslExtensions[cap];
    }
    const extensionName = feature[0];
    const behavior = opts.behavior || "enable";
    const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
    const shader = gl.createShader(35633);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const canCompile = gl.getShaderParameter(shader, 35713);
    gl.deleteShader(shader);
    compiledGlslExtensions[cap] = canCompile;
    return canCompile;
  }
  function getFeature(gl, cap) {
    const feature = WEBGL_FEATURES[cap];
    assert7(feature, cap);
    const extensionName = isWebGL22(gl) ? feature[1] || feature[0] : feature[0];
    const value = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
    assert7(value === false || value === true);
    return value;
  }
  function hasFeatures2(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => getFeature(gl, feature));
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js
  function getPlatformShaderDefines(gl) {
    const debugInfo = getContextInfo(gl);
    switch (debugInfo.gpuVendor.toLowerCase()) {
      case "nvidia":
        return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
      case "intel":
        return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
      case "amd":
        return "#define AMD_GPU\n";
      default:
        return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    }
  }
  function getVersionDefines(gl, glslVersion, isFragment) {
    let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DEPTH)) {
      versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_DERIVATIVES) && canCompileGLGSExtension(gl, FEATURES2.GLSL_DERIVATIVES)) {
      versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DATA) && canCompileGLGSExtension(gl, FEATURES2.GLSL_FRAG_DATA, {
      behavior: "require"
    })) {
      versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_TEXTURE_LOD)) {
      versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
    }
    return versionDefines;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js
  var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
  var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";

  // node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js
  var MODULE_INJECTORS = {
    [VERTEX_SHADER]: MODULE_INJECTORS_VS,
    [FRAGMENT_SHADER]: MODULE_INJECTORS_FS
  };
  var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
  var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
  var fragments = [];
  function injectShader(source, type, inject) {
    let injectStandardStubs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const isVertex = type === VERTEX_SHADER;
    for (const key in inject) {
      const fragmentData = inject[key];
      fragmentData.sort((a2, b2) => a2.order - b2.order);
      fragments.length = fragmentData.length;
      for (let i2 = 0, len = fragmentData.length; i2 < len; ++i2) {
        fragments[i2] = fragmentData[i2].injection;
      }
      const fragmentString = "".concat(fragments.join("\n"), "\n");
      switch (key) {
        case "vs:#decl":
          if (isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "vs:#main-start":
          if (isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "vs:#main-end":
          if (isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        case "fs:#decl":
          if (!isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "fs:#main-start":
          if (!isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "fs:#main-end":
          if (!isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        default:
          source = source.replace(key, (match) => match + fragmentString);
      }
    }
    source = source.replace(DECLARATION_INJECT_MARKER, "");
    if (injectStandardStubs) {
      source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[type]);
    }
    return source;
  }
  function combineInjects(injects) {
    const result = {};
    assert7(Array.isArray(injects) && injects.length > 1);
    injects.forEach((inject) => {
      for (const key in inject) {
        result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
      }
    });
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js
  function testVariable(qualifier) {
    return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
  }
  var ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
  var ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("attribute"), "in $1"], [testVariable("varying"), "out $1"]];
  var ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("varying"), "in $1"]];
  var ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
  var ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "attribute $1"], [testVariable("out"), "varying $1"]];
  var ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "varying $1"]];
  var ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
  var ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
  var REGEX_START_OF_MAIN2 = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  function transpileShader(source, targetGLSLVersion, isVertex) {
    switch (targetGLSLVersion) {
      case 300:
        return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
      case 100:
        return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
      default:
        throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
    }
  }
  function convertShader(source, replacements) {
    for (const [pattern, replacement] of replacements) {
      source = source.replace(pattern, replacement);
    }
    return source;
  }
  function convertFragmentShaderTo300(source) {
    source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    } else {
      const outputName = "fragmentColor";
      source = source.replace(REGEX_START_OF_MAIN2, (match) => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    }
    return source;
  }
  function convertFragmentShaderTo100(source) {
    source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), ES100_FRAGMENT_OUTPUT_NAME);
    }
    return source;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js
  var INJECT_SHADER_DECLARATIONS = "\n\n".concat(DECLARATION_INJECT_MARKER, "\n\n");
  var SHADER_TYPE = {
    [VERTEX_SHADER]: "vertex",
    [FRAGMENT_SHADER]: "fragment"
  };
  var FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
  function assembleShaders(gl, opts) {
    const {
      vs: vs7,
      fs: fs4
    } = opts;
    const modules = resolveModules(opts.modules || []);
    return {
      gl,
      vs: assembleShader(gl, Object.assign({}, opts, {
        source: vs7,
        type: VERTEX_SHADER,
        modules
      })),
      fs: assembleShader(gl, Object.assign({}, opts, {
        source: fs4,
        type: FRAGMENT_SHADER,
        modules
      })),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleShader(gl, _ref) {
    let {
      id,
      source,
      type,
      modules,
      defines: defines2 = {},
      hookFunctions = [],
      inject = {},
      transpileToGLSL100 = false,
      prologue = true,
      log: log4
    } = _ref;
    assert7(typeof source === "string", "shader source must be a string");
    const isVertex = type === VERTEX_SHADER;
    const sourceLines = source.split("\n");
    let glslVersion = 100;
    let versionLine = "";
    let coreSource = source;
    if (sourceLines[0].indexOf("#version ") === 0) {
      glslVersion = 300;
      versionLine = sourceLines[0];
      coreSource = sourceLines.slice(1).join("\n");
    } else {
      versionLine = "#version ".concat(glslVersion);
    }
    const allDefines = {};
    modules.forEach((module) => {
      Object.assign(allDefines, module.getDefines());
    });
    Object.assign(allDefines, defines2);
    let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName2({
      id,
      source,
      type
    }), "\n").concat(getShaderType({
      type
    }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
    const hookFunctionMap = normalizeHookFunctions(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject) {
      const injection = typeof inject[key] === "string" ? {
        injection: inject[key],
        order: 0
      } : inject[key];
      const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
      if (match) {
        const hash = match[2];
        const name = match[3];
        if (hash) {
          if (name === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    for (const module of modules) {
      if (log4) {
        module.checkDeprecations(coreSource, log4);
      }
      const moduleSource = module.getModuleSource(type, glslVersion);
      assembledSource += moduleSource;
      const injections = module.injections[type];
      for (const key in injections) {
        const match = key.match(/^(v|f)s:#([\w-]+)$/);
        if (match) {
          const name = match[2];
          const injectionType = name === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, type, declInjections);
    assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, type, mainInjections);
    assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
    return assembledSource;
  }
  function assembleGetUniforms(modules) {
    return function getUniforms5(opts) {
      const uniforms = {};
      for (const module of modules) {
        const moduleUniforms = module.getUniforms(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
      return uniforms;
    };
  }
  function getShaderType(_ref2) {
    let {
      type
    } = _ref2;
    return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
  }
  function getShaderName2(_ref3) {
    let {
      id,
      source,
      type
    } = _ref3;
    const injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : "";
  }
  function getApplicationDefines() {
    let defines2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let count2 = 0;
    let sourceText = "";
    for (const define2 in defines2) {
      if (count2 === 0) {
        sourceText += "\n// APPLICATION DEFINES\n";
      }
      count2++;
      const value = defines2[define2];
      if (value || Number.isFinite(value)) {
        sourceText += "#define ".concat(define2.toUpperCase(), " ").concat(defines2[define2], "\n");
      }
    }
    if (count2 === 0) {
      sourceText += "\n";
    }
    return sourceText;
  }
  function getHookFunctions(hookFunctions, hookInjections) {
    let result = "";
    for (const hookName in hookFunctions) {
      const hookFunction = hookFunctions[hookName];
      result += "void ".concat(hookFunction.signature, " {\n");
      if (hookFunction.header) {
        result += "  ".concat(hookFunction.header);
      }
      if (hookInjections[hookName]) {
        const injections = hookInjections[hookName];
        injections.sort((a2, b2) => a2.order - b2.order);
        for (const injection of injections) {
          result += "  ".concat(injection.injection, "\n");
        }
      }
      if (hookFunction.footer) {
        result += "  ".concat(hookFunction.footer);
      }
      result += "}\n";
    }
    return result;
  }
  function normalizeHookFunctions(hookFunctions) {
    const result = {
      vs: {},
      fs: {}
    };
    hookFunctions.forEach((hook) => {
      let opts;
      if (typeof hook !== "string") {
        opts = hook;
        hook = opts.hook;
      } else {
        opts = {};
      }
      hook = hook.trim();
      const [stage, signature] = hook.split(":");
      const name = hook.replace(/\(.+/, "");
      result[stage][name] = Object.assign(opts, {
        signature
      });
    });
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js
  var FS100 = "void main() {gl_FragColor = vec4(0);}";
  var FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
  var FS300 = "#version 300 es\n".concat(FS_GLES);
  function getQualifierDetails(line, qualifiers) {
    qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
    const words = line.replace(/^\s+/, "").split(/\s+/);
    const [qualifier, type, definition] = words;
    if (!qualifiers.includes(qualifier) || !type || !definition) {
      return null;
    }
    const name = definition.split(";")[0];
    return {
      qualifier,
      type,
      name
    };
  }
  function getPassthroughFS() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      version = 100,
      input,
      inputType,
      output
    } = options;
    if (!input) {
      if (version === 300) {
        return FS300;
      } else if (version > 300) {
        return "#version ".concat(version, "\n").concat(FS_GLES);
      }
      return FS100;
    }
    const outputValue = convertToVec4(input, inputType);
    if (version >= 300) {
      return "#version ".concat(version, " ").concat(version === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
    }
    return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
  }
  function typeToChannelSuffix(type) {
    switch (type) {
      case "float":
        return "x";
      case "vec2":
        return "xy";
      case "vec3":
        return "xyz";
      case "vec4":
        return "xyzw";
      default:
        assert7(false);
        return null;
    }
  }
  function typeToChannelCount(type) {
    switch (type) {
      case "float":
        return 1;
      case "vec2":
        return 2;
      case "vec3":
        return 3;
      case "vec4":
        return 4;
      default:
        assert7(false);
        return null;
    }
  }
  function convertToVec4(variable, type) {
    switch (type) {
      case "float":
        return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
      case "vec2":
        return "vec4(".concat(variable, ", 0.0, 1.0)");
      case "vec3":
        return "vec4(".concat(variable, ", 1.0)");
      case "vec4":
        return variable;
      default:
        assert7(false);
        return null;
    }
  }

  // node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js
  var fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
  var fp32 = {
    name: "fp32",
    vs: fp32shader,
    fs: null
  };

  // node_modules/@math.gl/core/dist/esm/lib/assert.js
  function assert8(condition, message) {
    if (!condition) {
      throw new Error("math.gl assertion ".concat(message));
    }
  }

  // node_modules/@math.gl/core/dist/esm/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var config = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true
  };
  function formatValue2(value, {
    precision = config.precision
  } = {}) {
    value = round(value);
    return "".concat(parseFloat(value.toPrecision(precision)));
  }
  function isArray2(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function clamp(value, min, max) {
    return map(value, (value2) => Math.max(min, Math.min(max, value2)));
  }
  function lerp(a2, b2, t2) {
    if (isArray2(a2)) {
      return a2.map((ai, i2) => lerp(ai, b2[i2], t2));
    }
    return t2 * b2 + (1 - t2) * a2;
  }
  function equals(a2, b2, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a2 === b2) {
        return true;
      }
      if (isArray2(a2) && isArray2(b2)) {
        if (a2.length !== b2.length) {
          return false;
        }
        for (let i2 = 0; i2 < a2.length; ++i2) {
          if (!equals(a2[i2], b2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (a2 && a2.equals) {
        return a2.equals(b2);
      }
      if (b2 && b2.equals) {
        return b2.equals(a2);
      }
      if (typeof a2 === "number" && typeof b2 === "number") {
        return Math.abs(a2 - b2) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }
  function duplicateArray(array) {
    return array.clone ? array.clone() : new Array(array.length);
  }
  function map(value, func, result) {
    if (isArray2(value)) {
      const array = value;
      result = result || duplicateArray(array);
      for (let i2 = 0; i2 < result.length && i2 < array.length; ++i2) {
        result[i2] = func(value[i2], i2, result);
      }
      return result;
    }
    return func(value);
  }

  // node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
  function _extendableBuiltin(cls) {
    function ExtendableBuiltin() {
      var instance = Reflect.construct(cls, Array.from(arguments));
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
      return instance;
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype, {
      constructor: {
        value: cls,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ExtendableBuiltin, cls);
    } else {
      ExtendableBuiltin.__proto__ = cls;
    }
    return ExtendableBuiltin;
  }
  var MathArray = class extends _extendableBuiltin(Array) {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = array[i2 + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        targetArray[offset + i2] = this[i2];
      }
      return targetArray;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
      return target ? this.to(target) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    formatString(opts) {
      let string = "";
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        string += (i2 > 0 ? ", " : "") + formatValue2(this[i2], opts);
      }
      return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        if (!equals(this[i2], array[i2])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        if (this[i2] !== array[i2]) {
          return false;
        }
      }
      return true;
    }
    negate() {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = -this[i2];
      }
      return this.check();
    }
    lerp(a2, b2, t2) {
      if (t2 === void 0) {
        return this.lerp(this, a2, b2);
      }
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        const ai = a2[i2];
        this[i2] = ai + t2 * (b2[i2] - ai);
      }
      return this.check();
    }
    min(vector) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = Math.min(vector[i2], this[i2]);
      }
      return this.check();
    }
    max(vector) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = Math.max(vector[i2], this[i2]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = Math.min(Math.max(this[i2], minVector[i2]), maxVector[i2]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] += vector[i2];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] -= vector[i2];
        }
      }
      return this.check();
    }
    scale(scale3) {
      if (typeof scale3 === "number") {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] *= scale3;
        }
      } else {
        for (let i2 = 0; i2 < this.ELEMENTS && i2 < scale3.length; ++i2) {
          this[i2] *= scale3[i2];
        }
      }
      return this.check();
    }
    multiplyByScalar(scalar) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] *= scalar;
      }
      return this.check();
    }
    check() {
      if (config.debug && !this.validate()) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }
      return this;
    }
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        valid = valid && Number.isFinite(this[i2]);
      }
      return valid;
    }
    sub(a2) {
      return this.subtract(a2);
    }
    setScalar(a2) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = a2;
      }
      return this.check();
    }
    addScalar(a2) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] += a2;
      }
      return this.check();
    }
    subScalar(a2) {
      return this.addScalar(-a2);
    }
    multiplyScalar(scalar) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] *= scalar;
      }
      return this.check();
    }
    divideScalar(a2) {
      return this.multiplyByScalar(1 / a2);
    }
    clampScalar(min, max) {
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        this[i2] = Math.min(Math.max(this[i2], min), max);
      }
      return this.check();
    }
    get elements() {
      return this;
    }
  };

  // node_modules/@math.gl/core/dist/esm/lib/validators.js
  function validateVector(v2, length) {
    if (v2.length !== length) {
      return false;
    }
    for (let i2 = 0; i2 < v2.length; ++i2) {
      if (!Number.isFinite(v2[i2])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error("Invalid number ".concat(value));
    }
    return value;
  }
  function checkVector(v2, length, callerName = "") {
    if (config.debug && !validateVector(v2, length)) {
      throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    }
    return v2;
  }

  // node_modules/@math.gl/core/dist/esm/classes/base/vector.js
  var Vector = class extends MathArray {
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let length = 0;
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        length += this[i2] * this[i2];
      }
      return length;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length = 0;
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        const dist = this[i2] - mathArray[i2];
        length += dist * dist;
      }
      return checkNumber(length);
    }
    dot(mathArray) {
      let product = 0;
      for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
        product += this[i2] * mathArray[i2];
      }
      return checkNumber(product);
    }
    normalize() {
      const length = this.magnitude();
      if (length !== 0) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] /= length;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] *= vector[i2];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          this[i2] /= vector[i2];
        }
      }
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i2) {
      assert8(i2 >= 0 && i2 < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i2]);
    }
    setComponent(i2, value) {
      assert8(i2 >= 0 && i2 < this.ELEMENTS, "index is out of range");
      this[i2] = value;
      return this.check();
    }
    addVectors(a2, b2) {
      return this.copy(a2).add(b2);
    }
    subVectors(a2, b2) {
      return this.copy(a2).subtract(b2);
    }
    multiplyVectors(a2, b2) {
      return this.copy(a2).multiply(b2);
    }
    addScaledVector(a2, b2) {
      return this.add(new this.constructor(a2).multiplyScalar(b2));
    }
  };

  // node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y2 = 0, i2 = arguments.length;
      while (i2--) {
        y2 += arguments[i2] * arguments[i2];
      }
      return Math.sqrt(y2);
    };

  // node_modules/gl-matrix/esm/vec2.js
  function create() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function add(out, a2, b2) {
    out[0] = a2[0] + b2[0];
    out[1] = a2[1] + b2[1];
    return out;
  }
  function negate(out, a2) {
    out[0] = -a2[0];
    out[1] = -a2[1];
    return out;
  }
  function lerp2(out, a2, b2, t2) {
    var ax = a2[0], ay = a2[1];
    out[0] = ax + t2 * (b2[0] - ax);
    out[1] = ay + t2 * (b2[1] - ay);
    return out;
  }
  function transformMat4(out, a2, m) {
    var x2 = a2[0];
    var y2 = a2[1];
    out[0] = m[0] * x2 + m[4] * y2 + m[12];
    out[1] = m[1] * x2 + m[5] * y2 + m[13];
    return out;
  }
  var forEach2 = function() {
    var vec = create();
    return function(a2, stride, offset, count2, fn, arg) {
      var i2, l2;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i2 = offset; i2 < l2; i2 += stride) {
        vec[0] = a2[i2];
        vec[1] = a2[i2 + 1];
        fn(vec, vec, arg);
        a2[i2] = vec[0];
        a2[i2 + 1] = vec[1];
      }
      return a2;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    const w2 = m[3] * x2 + m[7] * y2 || 1;
    out[0] = (m[0] * x2 + m[4] * y2) / w2;
    out[1] = (m[1] * x2 + m[5] * y2) / w2;
    return out;
  }
  function vec3_transformMat4AsVector(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    const z = a2[2];
    const w2 = m[3] * x2 + m[7] * y2 + m[11] * z || 1;
    out[0] = (m[0] * x2 + m[4] * y2 + m[8] * z) / w2;
    out[1] = (m[1] * x2 + m[5] * y2 + m[9] * z) / w2;
    out[2] = (m[2] * x2 + m[6] * y2 + m[10] * z) / w2;
    return out;
  }
  function vec3_transformMat2(out, a2, m) {
    const x2 = a2[0];
    const y2 = a2[1];
    out[0] = m[0] * x2 + m[2] * y2;
    out[1] = m[1] * x2 + m[3] * y2;
    out[2] = a2[2];
    return out;
  }

  // node_modules/gl-matrix/esm/vec3.js
  function create2() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function subtract(out, a2, b2) {
    out[0] = a2[0] - b2[0];
    out[1] = a2[1] - b2[1];
    out[2] = a2[2] - b2[2];
    return out;
  }
  function negate2(out, a2) {
    out[0] = -a2[0];
    out[1] = -a2[1];
    out[2] = -a2[2];
    return out;
  }
  function dot(a2, b2) {
    return a2[0] * b2[0] + a2[1] * b2[1] + a2[2] * b2[2];
  }
  function cross(out, a2, b2) {
    var ax = a2[0], ay = a2[1], az = a2[2];
    var bx = b2[0], by = b2[1], bz = b2[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat42(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    var w2 = m[3] * x2 + m[7] * y2 + m[11] * z + m[15];
    w2 = w2 || 1;
    out[0] = (m[0] * x2 + m[4] * y2 + m[8] * z + m[12]) / w2;
    out[1] = (m[1] * x2 + m[5] * y2 + m[9] * z + m[13]) / w2;
    out[2] = (m[2] * x2 + m[6] * y2 + m[10] * z + m[14]) / w2;
    return out;
  }
  function transformMat3(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    out[0] = x2 * m[0] + y2 * m[3] + z * m[6];
    out[1] = x2 * m[1] + y2 * m[4] + z * m[7];
    out[2] = x2 * m[2] + y2 * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a2, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x2 = a2[0], y2 = a2[1], z = a2[2];
    var uvx = qy * z - qz * y2, uvy = qz * x2 - qx * z, uvz = qx * y2 - qy * x2;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x2 + uvx + uuvx;
    out[1] = y2 + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX(out, a2, b2, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b2[0];
    p2[1] = a2[1] - b2[1];
    p2[2] = a2[2] - b2[2];
    r2[0] = p2[0];
    r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
    r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
    out[0] = r2[0] + b2[0];
    out[1] = r2[1] + b2[1];
    out[2] = r2[2] + b2[2];
    return out;
  }
  function rotateY(out, a2, b2, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b2[0];
    p2[1] = a2[1] - b2[1];
    p2[2] = a2[2] - b2[2];
    r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
    r2[1] = p2[1];
    r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
    out[0] = r2[0] + b2[0];
    out[1] = r2[1] + b2[1];
    out[2] = r2[2] + b2[2];
    return out;
  }
  function rotateZ(out, a2, b2, rad) {
    var p2 = [], r2 = [];
    p2[0] = a2[0] - b2[0];
    p2[1] = a2[1] - b2[1];
    p2[2] = a2[2] - b2[2];
    r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
    r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
    r2[2] = p2[2];
    out[0] = r2[0] + b2[0];
    out[1] = r2[1] + b2[1];
    out[2] = r2[2] + b2[2];
    return out;
  }
  function angle(a2, b2) {
    var ax = a2[0], ay = a2[1], az = a2[2], bx = b2[0], by = b2[1], bz = b2[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a2, b2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var sub = subtract;
  var forEach3 = function() {
    var vec = create2();
    return function(a2, stride, offset, count2, fn, arg) {
      var i2, l2;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i2 = offset; i2 < l2; i2 += stride) {
        vec[0] = a2[i2];
        vec[1] = a2[i2 + 1];
        vec[2] = a2[i2 + 2];
        fn(vec, vec, arg);
        a2[i2] = vec[0];
        a2[i2 + 1] = vec[1];
        a2[i2 + 2] = vec[2];
      }
      return a2;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/classes/vector3.js
  var ORIGIN = [0, 0, 0];
  var ZERO;
  var Vector3 = class _Vector3 extends Vector {
    static get ZERO() {
      if (!ZERO) {
        ZERO = new _Vector3(0, 0, 0);
        Object.freeze(ZERO);
      }
      return ZERO;
    }
    constructor(x2 = 0, y2 = 0, z = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray2(x2)) {
        this.copy(x2);
      } else {
        if (config.debug) {
          checkNumber(x2);
          checkNumber(y2);
          checkNumber(z);
        }
        this[0] = x2;
        this[1] = y2;
        this[2] = z;
      }
    }
    set(x2, y2, z) {
      this[0] = x2;
      this[1] = y2;
      this[2] = z;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
        checkNumber(object.z);
      }
      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value) {
      this[2] = checkNumber(value);
    }
    angle(vector) {
      return angle(this, vector);
    }
    cross(vector) {
      cross(this, this, vector);
      return this.check();
    }
    rotateX({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateX(this, this, origin, radians2);
      return this.check();
    }
    rotateY({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateY(this, this, origin, radians2);
      return this.check();
    }
    rotateZ({
      radians: radians2,
      origin = ORIGIN
    }) {
      rotateZ(this, this, origin, radians2);
      return this.check();
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion) {
      transformQuat(this, this, quaternion);
      return this.check();
    }
  };

  // node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
  var Matrix = class extends MathArray {
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += " ".concat(this[col * this.RANK + row]);
          }
        }
      } else {
        string += "column-major:";
        for (let i2 = 0; i2 < this.ELEMENTS; ++i2) {
          string += " ".concat(this[i2]);
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i2 = 0; i2 < this.RANK; ++i2) {
        result[i2] = this[firstIndex + i2];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i2 = 0; i2 < this.RANK; ++i2) {
        this[firstIndex + i2] = columnVector[i2];
      }
      return this;
    }
  };

  // node_modules/gl-matrix/esm/mat4.js
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose(out, a2) {
    if (out === a2) {
      var a01 = a2[1], a02 = a2[2], a03 = a2[3];
      var a12 = a2[6], a13 = a2[7];
      var a23 = a2[11];
      out[1] = a2[4];
      out[2] = a2[8];
      out[3] = a2[12];
      out[4] = a01;
      out[6] = a2[9];
      out[7] = a2[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a2[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a2[0];
      out[1] = a2[4];
      out[2] = a2[8];
      out[3] = a2[12];
      out[4] = a2[1];
      out[5] = a2[5];
      out[6] = a2[9];
      out[7] = a2[13];
      out[8] = a2[2];
      out[9] = a2[6];
      out[10] = a2[10];
      out[11] = a2[14];
      out[12] = a2[3];
      out[13] = a2[7];
      out[14] = a2[11];
      out[15] = a2[15];
    }
    return out;
  }
  function invert(out, a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant(a2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply(out, a2, b2) {
    var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
    var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
    var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
    var b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3];
    out[0] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[4];
    b1 = b2[5];
    b22 = b2[6];
    b3 = b2[7];
    out[4] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[8];
    b1 = b2[9];
    b22 = b2[10];
    b3 = b2[11];
    out[8] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    b0 = b2[12];
    b1 = b2[13];
    b22 = b2[14];
    b3 = b2[15];
    out[12] = b0 * a00 + b1 * a10 + b22 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b22 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b22 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b22 * a23 + b3 * a33;
    return out;
  }
  function translate(out, a2, v2) {
    var x2 = v2[0], y2 = v2[1], z = v2[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a2 === out) {
      out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z + a2[12];
      out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z + a2[13];
      out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z + a2[14];
      out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z + a2[15];
    } else {
      a00 = a2[0];
      a01 = a2[1];
      a02 = a2[2];
      a03 = a2[3];
      a10 = a2[4];
      a11 = a2[5];
      a12 = a2[6];
      a13 = a2[7];
      a20 = a2[8];
      a21 = a2[9];
      a22 = a2[10];
      a23 = a2[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x2 + a10 * y2 + a20 * z + a2[12];
      out[13] = a01 * x2 + a11 * y2 + a21 * z + a2[13];
      out[14] = a02 * x2 + a12 * y2 + a22 * z + a2[14];
      out[15] = a03 * x2 + a13 * y2 + a23 * z + a2[15];
    }
    return out;
  }
  function scale(out, a2, v2) {
    var x2 = v2[0], y2 = v2[1], z = v2[2];
    out[0] = a2[0] * x2;
    out[1] = a2[1] * x2;
    out[2] = a2[2] * x2;
    out[3] = a2[3] * x2;
    out[4] = a2[4] * y2;
    out[5] = a2[5] * y2;
    out[6] = a2[6] * y2;
    out[7] = a2[7] * y2;
    out[8] = a2[8] * z;
    out[9] = a2[9] * z;
    out[10] = a2[10] * z;
    out[11] = a2[11] * z;
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
    return out;
  }
  function rotate(out, a2, rad, axis) {
    var x2 = axis[0], y2 = axis[1], z = axis[2];
    var len = Math.hypot(x2, y2, z);
    var s, c2, t2;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len < EPSILON) {
      return null;
    }
    len = 1 / len;
    x2 *= len;
    y2 *= len;
    z *= len;
    s = Math.sin(rad);
    c2 = Math.cos(rad);
    t2 = 1 - c2;
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    b00 = x2 * x2 * t2 + c2;
    b01 = y2 * x2 * t2 + z * s;
    b02 = z * x2 * t2 - y2 * s;
    b10 = x2 * y2 * t2 - z * s;
    b11 = y2 * y2 * t2 + c2;
    b12 = z * y2 * t2 + x2 * s;
    b20 = x2 * z * t2 + y2 * s;
    b21 = y2 * z * t2 - x2 * s;
    b22 = z * z * t2 + c2;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a2 !== out) {
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    return out;
  }
  function rotateX2(out, a2, rad) {
    var s = Math.sin(rad);
    var c2 = Math.cos(rad);
    var a10 = a2[4];
    var a11 = a2[5];
    var a12 = a2[6];
    var a13 = a2[7];
    var a20 = a2[8];
    var a21 = a2[9];
    var a22 = a2[10];
    var a23 = a2[11];
    if (a2 !== out) {
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      out[3] = a2[3];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[4] = a10 * c2 + a20 * s;
    out[5] = a11 * c2 + a21 * s;
    out[6] = a12 * c2 + a22 * s;
    out[7] = a13 * c2 + a23 * s;
    out[8] = a20 * c2 - a10 * s;
    out[9] = a21 * c2 - a11 * s;
    out[10] = a22 * c2 - a12 * s;
    out[11] = a23 * c2 - a13 * s;
    return out;
  }
  function rotateY2(out, a2, rad) {
    var s = Math.sin(rad);
    var c2 = Math.cos(rad);
    var a00 = a2[0];
    var a01 = a2[1];
    var a02 = a2[2];
    var a03 = a2[3];
    var a20 = a2[8];
    var a21 = a2[9];
    var a22 = a2[10];
    var a23 = a2[11];
    if (a2 !== out) {
      out[4] = a2[4];
      out[5] = a2[5];
      out[6] = a2[6];
      out[7] = a2[7];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c2 - a20 * s;
    out[1] = a01 * c2 - a21 * s;
    out[2] = a02 * c2 - a22 * s;
    out[3] = a03 * c2 - a23 * s;
    out[8] = a00 * s + a20 * c2;
    out[9] = a01 * s + a21 * c2;
    out[10] = a02 * s + a22 * c2;
    out[11] = a03 * s + a23 * c2;
    return out;
  }
  function rotateZ2(out, a2, rad) {
    var s = Math.sin(rad);
    var c2 = Math.cos(rad);
    var a00 = a2[0];
    var a01 = a2[1];
    var a02 = a2[2];
    var a03 = a2[3];
    var a10 = a2[4];
    var a11 = a2[5];
    var a12 = a2[6];
    var a13 = a2[7];
    if (a2 !== out) {
      out[8] = a2[8];
      out[9] = a2[9];
      out[10] = a2[10];
      out[11] = a2[11];
      out[12] = a2[12];
      out[13] = a2[13];
      out[14] = a2[14];
      out[15] = a2[15];
    }
    out[0] = a00 * c2 + a10 * s;
    out[1] = a01 * c2 + a11 * s;
    out[2] = a02 * c2 + a12 * s;
    out[3] = a03 * c2 + a13 * s;
    out[4] = a10 * c2 - a00 * s;
    out[5] = a11 * c2 - a01 * s;
    out[6] = a12 * c2 - a02 * s;
    out[7] = a13 * c2 - a03 * s;
    return out;
  }
  function fromQuat(out, q) {
    var x2 = q[0], y2 = q[1], z = q[2], w2 = q[3];
    var x22 = x2 + x2;
    var y22 = y2 + y2;
    var z2 = z + z;
    var xx = x2 * x22;
    var yx = y2 * x22;
    var yy = y2 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx = w2 * x22;
    var wy = w2 * y22;
    var wz = w2 * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f2 = 1 / Math.tan(fovy / 2), nf;
    out[0] = f2 / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f2;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);
    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);
    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // node_modules/gl-matrix/esm/vec4.js
  function create3() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function scale2(out, a2, b2) {
    out[0] = a2[0] * b2;
    out[1] = a2[1] * b2;
    out[2] = a2[2] * b2;
    out[3] = a2[3] * b2;
    return out;
  }
  function transformMat43(out, a2, m) {
    var x2 = a2[0], y2 = a2[1], z = a2[2], w2 = a2[3];
    out[0] = m[0] * x2 + m[4] * y2 + m[8] * z + m[12] * w2;
    out[1] = m[1] * x2 + m[5] * y2 + m[9] * z + m[13] * w2;
    out[2] = m[2] * x2 + m[6] * y2 + m[10] * z + m[14] * w2;
    out[3] = m[3] * x2 + m[7] * y2 + m[11] * z + m[15] * w2;
    return out;
  }
  var forEach4 = function() {
    var vec = create3();
    return function(a2, stride, offset, count2, fn, arg) {
      var i2, l2;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l2 = Math.min(count2 * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i2 = offset; i2 < l2; i2 += stride) {
        vec[0] = a2[i2];
        vec[1] = a2[i2 + 1];
        vec[2] = a2[i2 + 2];
        vec[3] = a2[i2 + 3];
        fn(vec, vec, arg);
        a2[i2] = vec[0];
        a2[i2 + 1] = vec[1];
        a2[i2 + 2] = vec[2];
        a2[i2 + 3] = vec[3];
      }
      return a2;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/classes/matrix4.js
  var INDICES;
  (function(INDICES2) {
    INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES2[INDICES2["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES2[INDICES2["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES2[INDICES2["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES2[INDICES2["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES2[INDICES2["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES2[INDICES2["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES2[INDICES2["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES2[INDICES2["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES2[INDICES2["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES2[INDICES2["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES2[INDICES2["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES2[INDICES2["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES2[INDICES2["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES || (INDICES = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    fromObject(object) {
      return this.check();
    }
    fromQuaternion(quaternion) {
      fromQuat(this, quaternion);
      return this.check();
    }
    frustum(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    lookAt(view) {
      const {
        eye,
        center = [0, 0, 0],
        up = [0, 1, 0]
      } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    ortho(view) {
      const {
        left,
        right,
        bottom,
        top,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    orthographic(view) {
      const {
        fovy = DEFAULT_FOVY,
        aspect = DEFAULT_ASPECT,
        focalDistance = 1,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    perspective(view) {
      const {
        fovy = 45 * Math.PI / 180,
        aspect = 1,
        near = 0.1,
        far = 500
      } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    determinant() {
      return determinant(this);
    }
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale3 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale3[0];
      const inverseScale1 = 1 / scale3[1];
      const inverseScale2 = 1 / scale3[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale3 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale3[0];
      const inverseScale1 = 1 / scale3[1];
      const inverseScale2 = 1 / scale3[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    multiplyLeft(a2) {
      multiply(this, a2, this);
      return this.check();
    }
    multiplyRight(a2) {
      multiply(this, this, a2);
      return this.check();
    }
    rotateX(radians2) {
      rotateX2(this, this, radians2);
      return this.check();
    }
    rotateY(radians2) {
      rotateY2(this, this, radians2);
      return this.check();
    }
    rotateZ(radians2) {
      rotateZ2(this, this, radians2);
      return this.check();
    }
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians2, axis) {
      rotate(this, this, radians2, axis);
      return this.check();
    }
    scale(factor) {
      scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    translate(vector) {
      translate(this, this, vector);
      return this.check();
    }
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
      const {
        length
      } = vector;
      let out;
      switch (length) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    makeRotationX(radians2) {
      return this.identity().rotateX(radians2);
    }
    makeTranslation(x2, y2, z) {
      return this.identity().translate([x2, y2, z]);
    }
  };
  var ZERO2;
  var IDENTITY;
  function getZeroMatrix() {
    if (!ZERO2) {
      ZERO2 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO2);
    }
    return ZERO2;
  }
  function getIdentityMatrix() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js
  var lights_glsl_default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";

  // node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js
  var INITIAL_MODULE_OPTIONS = {
    lightSources: {}
  };
  function convertColor() {
    let {
      color = [0, 0, 0],
      intensity = 1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return color.map((component) => component * intensity / 255);
  }
  function getLightSourceUniforms(_ref) {
    let {
      ambientLight,
      pointLights = [],
      directionalLights = []
    } = _ref;
    const lightSourceUniforms = {};
    if (ambientLight) {
      lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
    } else {
      lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
    }
    pointLights.forEach((pointLight, index) => {
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
      lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
    });
    lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
    directionalLights.forEach((directionalLight, index) => {
      lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
      lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
    });
    lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
    return lightSourceUniforms;
  }
  function getUniforms() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS;
    if ("lightSources" in opts) {
      const {
        ambientLight,
        pointLights,
        directionalLights
      } = opts.lightSources || {};
      const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
      if (!hasLights) {
        return {
          lighting_uEnabled: false
        };
      }
      return Object.assign({}, getLightSourceUniforms({
        ambientLight,
        pointLights,
        directionalLights
      }), {
        lighting_uEnabled: true
      });
    }
    if ("lights" in opts) {
      const lightSources = {
        pointLights: [],
        directionalLights: []
      };
      for (const light of opts.lights || []) {
        switch (light.type) {
          case "ambient":
            lightSources.ambientLight = light;
            break;
          case "directional":
            lightSources.directionalLights.push(light);
            break;
          case "point":
            lightSources.pointLights.push(light);
            break;
          default:
        }
      }
      return getUniforms({
        lightSources
      });
    }
    return {};
  }
  var lights = {
    name: "lights",
    vs: lights_glsl_default,
    fs: lights_glsl_default,
    getUniforms,
    defines: {
      MAX_LIGHTS: 3
    }
  };

  // node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js
  var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
  var DEFAULT_MODULE_OPTIONS = {
    pickingSelectedColor: null,
    pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
    pickingActive: false,
    pickingAttribute: false
  };
  function getUniforms2() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS;
    const uniforms = {};
    if (opts.pickingSelectedColor !== void 0) {
      if (!opts.pickingSelectedColor) {
        uniforms.picking_uSelectedColorValid = 0;
      } else {
        const selectedColor = opts.pickingSelectedColor.slice(0, 3);
        uniforms.picking_uSelectedColorValid = 1;
        uniforms.picking_uSelectedColor = selectedColor;
      }
    }
    if (opts.pickingHighlightColor) {
      const color = Array.from(opts.pickingHighlightColor, (x2) => x2 / 255);
      if (!Number.isFinite(color[3])) {
        color[3] = 1;
      }
      uniforms.picking_uHighlightColor = color;
    }
    if (opts.pickingActive !== void 0) {
      uniforms.picking_uActive = Boolean(opts.pickingActive);
      uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
    }
    return uniforms;
  }
  var vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
  var fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
  var picking = {
    name: "picking",
    vs,
    fs,
    getUniforms: getUniforms2
  };

  // node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js
  var phong_lighting_glsl_default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";

  // node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js
  var INITIAL_MODULE_OPTIONS2 = {};
  function getMaterialUniforms(material) {
    const {
      ambient = 0.35,
      diffuse = 0.6,
      shininess = 32,
      specularColor = [30, 30, 30]
    } = material;
    return {
      lighting_uAmbient: ambient,
      lighting_uDiffuse: diffuse,
      lighting_uShininess: shininess,
      lighting_uSpecularColor: specularColor.map((x2) => x2 / 255)
    };
  }
  function getUniforms3() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS2;
    if (!("material" in opts)) {
      return {};
    }
    const {
      material
    } = opts;
    if (!material) {
      return {
        lighting_uEnabled: false
      };
    }
    return getMaterialUniforms(material);
  }
  var gouraudLighting = {
    name: "gouraud-lighting",
    dependencies: [lights],
    vs: phong_lighting_glsl_default,
    defines: {
      LIGHTING_VERTEX: 1
    },
    getUniforms: getUniforms3
  };

  // node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js
  var vs2 = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
  var transform = {
    name: "transform",
    vs: vs2,
    fs: null
  };

  // node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js
  var ProgramManager = class _ProgramManager {
    static getDefaultProgramManager(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new _ProgramManager(gl);
      return gl.luma.defaultProgramManager;
    }
    constructor(gl) {
      this.gl = gl;
      this._programCache = {};
      this._getUniforms = {};
      this._registeredModules = {};
      this._hookFunctions = [];
      this._defaultModules = [];
      this._hashes = {};
      this._hashCounter = 0;
      this.stateHash = 0;
      this._useCounts = {};
    }
    addDefaultModule(module) {
      if (!this._defaultModules.find((m) => m.name === module.name)) {
        this._defaultModules.push(module);
      }
      this.stateHash++;
    }
    removeDefaultModule(module) {
      const moduleName = typeof module === "string" ? module : module.name;
      this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
      this.stateHash++;
    }
    addShaderHook(hook, opts) {
      if (opts) {
        hook = Object.assign(opts, {
          hook
        });
      }
      this._hookFunctions.push(hook);
      this.stateHash++;
    }
    get() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        vs: vs7 = "",
        fs: fs4 = "",
        defines: defines2 = {},
        inject = {},
        varyings = [],
        bufferMode = 35981,
        transpileToGLSL100 = false
      } = props;
      const modules = this._getModuleList(props.modules);
      const vsHash = this._getHash(vs7);
      const fsHash = this._getHash(fs4);
      const moduleHashes = modules.map((m) => this._getHash(m.name)).sort();
      const varyingHashes = varyings.map((v2) => this._getHash(v2));
      const defineKeys = Object.keys(defines2).sort();
      const injectKeys = Object.keys(inject).sort();
      const defineHashes = [];
      const injectHashes = [];
      for (const key of defineKeys) {
        defineHashes.push(this._getHash(key));
        defineHashes.push(this._getHash(defines2[key]));
      }
      for (const key of injectKeys) {
        injectHashes.push(this._getHash(key));
        injectHashes.push(this._getHash(inject[key]));
      }
      const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
      if (!this._programCache[hash]) {
        const assembled = assembleShaders(this.gl, {
          vs: vs7,
          fs: fs4,
          modules,
          inject,
          defines: defines2,
          hookFunctions: this._hookFunctions,
          transpileToGLSL100
        });
        this._programCache[hash] = new Program(this.gl, {
          hash,
          vs: assembled.vs,
          fs: assembled.fs,
          varyings,
          bufferMode
        });
        this._getUniforms[hash] = assembled.getUniforms || ((x2) => {
        });
        this._useCounts[hash] = 0;
      }
      this._useCounts[hash]++;
      return this._programCache[hash];
    }
    getUniforms(program) {
      return this._getUniforms[program.hash] || null;
    }
    release(program) {
      const hash = program.hash;
      this._useCounts[hash]--;
      if (this._useCounts[hash] === 0) {
        this._programCache[hash].delete();
        delete this._programCache[hash];
        delete this._getUniforms[hash];
        delete this._useCounts[hash];
      }
    }
    _getHash(key) {
      if (this._hashes[key] === void 0) {
        this._hashes[key] = this._hashCounter++;
      }
      return this._hashes[key];
    }
    _getModuleList() {
      let appModules = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const modules = new Array(this._defaultModules.length + appModules.length);
      const seen = {};
      let count2 = 0;
      for (let i2 = 0, len = this._defaultModules.length; i2 < len; ++i2) {
        const module = this._defaultModules[i2];
        const name = module.name;
        modules[count2++] = module;
        seen[name] = true;
      }
      for (let i2 = 0, len = appModules.length; i2 < len; ++i2) {
        const module = appModules[i2];
        const name = module.name;
        if (!seen[name]) {
          modules[count2++] = module;
          seen[name] = true;
        }
      }
      modules.length = count2;
      return modules;
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js
  var GLTF_TO_LUMA_ATTRIBUTE_MAP = {
    POSITION: "positions",
    NORMAL: "normals",
    COLOR_0: "colors",
    TEXCOORD_0: "texCoords",
    TEXCOORD_1: "texCoords1",
    TEXCOORD_2: "texCoords2"
  };
  function getBuffersFromGeometry(gl, geometry, options) {
    const buffers = {};
    let indices = geometry.indices;
    for (const name in geometry.attributes) {
      const attribute = geometry.attributes[name];
      const remappedName = mapAttributeName(name, options);
      if (name === "indices") {
        indices = attribute;
      } else if (attribute.constant) {
        buffers[remappedName] = attribute.value;
      } else {
        const typedArray = attribute.value;
        const accessor = {
          ...attribute
        };
        delete accessor.value;
        buffers[remappedName] = [new Buffer2(gl, typedArray), accessor];
        inferAttributeAccessor(name, accessor);
      }
    }
    if (indices) {
      const data = indices.value || indices;
      assert6(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
      const accessor = {
        size: 1,
        isIndexed: indices.isIndexed === void 0 ? true : indices.isIndexed
      };
      buffers.indices = [new Buffer2(gl, {
        data,
        target: 34963
      }), accessor];
    }
    return buffers;
  }
  function mapAttributeName(name, options) {
    const {
      attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
    } = options || {};
    return attributeMap && attributeMap[name] || name;
  }
  function inferAttributeAccessor(attributeName, attribute) {
    let category;
    switch (attributeName) {
      case "texCoords":
      case "texCoord1":
      case "texCoord2":
      case "texCoord3":
        category = "uvs";
        break;
      case "vertices":
      case "positions":
      case "normals":
      case "pickingColors":
        category = "vectors";
        break;
      default:
    }
    switch (category) {
      case "vectors":
        attribute.size = attribute.size || 3;
        break;
      case "uvs":
        attribute.size = attribute.size || 2;
        break;
      default:
    }
    assert6(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
  }

  // node_modules/@luma.gl/engine/dist/esm/lib/model.js
  var LOG_DRAW_PRIORITY = 2;
  var LOG_DRAW_TIMEOUT = 1e4;
  var ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
  var NOOP2 = () => {
  };
  var DRAW_PARAMS = {};
  var Model = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        id = uid("model")
      } = props;
      assert6(isWebGL(gl));
      this.id = id;
      this.gl = gl;
      this.id = props.id || uid("Model");
      this.lastLogTime = 0;
      this.animated = false;
      this.initialize(props);
    }
    initialize(props) {
      this.props = {};
      this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);
      this._programManagerState = -1;
      this._managedProgram = false;
      const {
        program = null,
        vs: vs7,
        fs: fs4,
        modules,
        defines: defines2,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = props;
      this.programProps = {
        program,
        vs: vs7,
        fs: fs4,
        modules,
        defines: defines2,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      };
      this.program = null;
      this.vertexArray = null;
      this._programDirty = true;
      this.userData = {};
      this.needsRedraw = true;
      this._attributes = {};
      this.attributes = {};
      this.uniforms = {};
      this.pickable = true;
      this._checkProgram();
      this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
      this.drawMode = props.drawMode !== void 0 ? props.drawMode : 4;
      this.vertexCount = props.vertexCount || 0;
      this.geometryBuffers = {};
      this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
      this._setModelProps(props);
      this.geometry = {};
      assert6(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
    }
    setProps(props) {
      this._setModelProps(props);
    }
    delete() {
      for (const key in this._attributes) {
        if (this._attributes[key] !== this.attributes[key]) {
          this._attributes[key].delete();
        }
      }
      if (this._managedProgram) {
        this.programManager.release(this.program);
        this._managedProgram = false;
      }
      this.vertexArray.delete();
      this._deleteGeometryBuffers();
    }
    getDrawMode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getInstanceCount() {
      return this.instanceCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getProgram() {
      return this.program;
    }
    setProgram(props) {
      const {
        program,
        vs: vs7,
        fs: fs4,
        modules,
        defines: defines2,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = props;
      this.programProps = {
        program,
        vs: vs7,
        fs: fs4,
        modules,
        defines: defines2,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      };
      this._programDirty = true;
    }
    getUniforms() {
      return this.uniforms;
    }
    setDrawMode(drawMode) {
      this.drawMode = drawMode;
      return this;
    }
    setVertexCount(vertexCount) {
      assert6(Number.isFinite(vertexCount));
      this.vertexCount = vertexCount;
      return this;
    }
    setInstanceCount(instanceCount) {
      assert6(Number.isFinite(instanceCount));
      this.instanceCount = instanceCount;
      return this;
    }
    setGeometry(geometry) {
      this.drawMode = geometry.drawMode;
      this.vertexCount = geometry.getVertexCount();
      this._deleteGeometryBuffers();
      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);
      this.vertexArray.setAttributes(this.geometryBuffers);
      return this;
    }
    setAttributes() {
      let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (isObjectEmpty2(attributes)) {
        return this;
      }
      const normalizedAttributes = {};
      for (const name in attributes) {
        const attribute = attributes[name];
        normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
      }
      this.vertexArray.setAttributes(normalizedAttributes);
      return this;
    }
    setUniforms() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Object.assign(this.uniforms, uniforms);
      return this;
    }
    getModuleUniforms(opts) {
      this._checkProgram();
      const getUniforms5 = this.programManager.getUniforms(this.program);
      if (getUniforms5) {
        return getUniforms5(opts);
      }
      return {};
    }
    updateModuleSettings(opts) {
      const uniforms = this.getModuleUniforms(opts || {});
      return this.setUniforms(uniforms);
    }
    clear(opts) {
      clear(this.program.gl, opts);
      return this;
    }
    draw() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._checkProgram();
      const {
        moduleSettings = null,
        framebuffer,
        uniforms = {},
        attributes = {},
        transformFeedback = this.transformFeedback,
        parameters = {},
        vertexArray = this.vertexArray
      } = opts;
      this.setAttributes(attributes);
      this.updateModuleSettings(moduleSettings);
      this.setUniforms(uniforms);
      let logPriority;
      if (log2.priority >= LOG_DRAW_PRIORITY) {
        logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
      }
      const drawParams = this.vertexArray.getDrawParams();
      const {
        isIndexed = drawParams.isIndexed,
        indexType = drawParams.indexType,
        indexOffset = drawParams.indexOffset,
        vertexArrayInstanced = drawParams.isInstanced
      } = this.props;
      if (vertexArrayInstanced && !this.isInstanced) {
        log2.warn("Found instanced attributes on non-instanced model", this.id)();
      }
      const {
        isInstanced,
        instanceCount
      } = this;
      const {
        onBeforeRender = NOOP2,
        onAfterRender = NOOP2
      } = this.props;
      onBeforeRender();
      this.program.setUniforms(this.uniforms);
      const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
        logPriority,
        uniforms: null,
        framebuffer,
        parameters,
        drawMode: this.getDrawMode(),
        vertexCount: this.getVertexCount(),
        vertexArray,
        transformFeedback,
        isIndexed,
        indexType,
        isInstanced,
        instanceCount,
        offset: isIndexed ? indexOffset : 0
      }));
      onAfterRender();
      if (log2.priority >= LOG_DRAW_PRIORITY) {
        this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
      }
      return didDraw;
    }
    transform() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        discard = true,
        feedbackBuffers,
        unbindModels = []
      } = opts;
      let {
        parameters
      } = opts;
      if (feedbackBuffers) {
        this._setFeedbackBuffers(feedbackBuffers);
      }
      if (discard) {
        parameters = Object.assign({}, parameters, {
          [35977]: discard
        });
      }
      unbindModels.forEach((model) => model.vertexArray.unbindBuffers());
      try {
        this.draw(Object.assign({}, opts, {
          parameters
        }));
      } finally {
        unbindModels.forEach((model) => model.vertexArray.bindBuffers());
      }
      return this;
    }
    render() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log2.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
      return this.setUniforms(uniforms).draw();
    }
    _setModelProps(props) {
      Object.assign(this.props, props);
      if ("uniforms" in props) {
        this.setUniforms(props.uniforms);
      }
      if ("pickable" in props) {
        this.pickable = props.pickable;
      }
      if ("instanceCount" in props) {
        this.instanceCount = props.instanceCount;
      }
      if ("geometry" in props) {
        this.setGeometry(props.geometry);
      }
      if ("attributes" in props) {
        this.setAttributes(props.attributes);
      }
      if ("_feedbackBuffers" in props) {
        this._setFeedbackBuffers(props._feedbackBuffers);
      }
    }
    _checkProgram() {
      const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
      if (!needsUpdate) {
        return;
      }
      let {
        program
      } = this.programProps;
      if (program) {
        this._managedProgram = false;
      } else {
        const {
          vs: vs7,
          fs: fs4,
          modules,
          inject,
          defines: defines2,
          varyings,
          bufferMode,
          transpileToGLSL100
        } = this.programProps;
        program = this.programManager.get({
          vs: vs7,
          fs: fs4,
          modules,
          inject,
          defines: defines2,
          varyings,
          bufferMode,
          transpileToGLSL100
        });
        if (this.program && this._managedProgram) {
          this.programManager.release(this.program);
        }
        this._programManagerState = this.programManager.stateHash;
        this._managedProgram = true;
      }
      assert6(program instanceof Program, "Model needs a program");
      this._programDirty = false;
      if (program === this.program) {
        return;
      }
      this.program = program;
      if (this.vertexArray) {
        this.vertexArray.setProps({
          program: this.program,
          attributes: this.vertexArray.attributes
        });
      } else {
        this.vertexArray = new VertexArray(this.gl, {
          program: this.program
        });
      }
      this.setUniforms(Object.assign({}, this.getModuleUniforms()));
    }
    _deleteGeometryBuffers() {
      for (const name in this.geometryBuffers) {
        const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
        if (buffer instanceof Buffer2) {
          buffer.delete();
        }
      }
    }
    _setAnimationProps(animationProps) {
      if (this.animated) {
        assert6(animationProps, "Model.draw(): animated uniforms but no animationProps");
      }
    }
    _setFeedbackBuffers() {
      let feedbackBuffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (isObjectEmpty2(feedbackBuffers)) {
        return this;
      }
      const {
        gl
      } = this.program;
      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {
        program: this.program
      });
      this.transformFeedback.setBuffers(feedbackBuffers);
      return this;
    }
    _logDrawCallStart(logLevel) {
      const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
      if (Date.now() - this.lastLogTime < logDrawTimeout) {
        return void 0;
      }
      this.lastLogTime = Date.now();
      log2.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: log2.level <= 2
      })();
      return logLevel;
    }
    _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
      if (logLevel === void 0) {
        return;
      }
      const attributeTable = getDebugTableForVertexArray({
        vertexArray,
        header: "".concat(this.id, " attributes"),
        attributes: this._attributes
      });
      const {
        table: uniformTable,
        unusedTable,
        unusedCount
      } = getDebugTableForUniforms({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms)
      });
      const {
        table: missingTable,
        count: missingCount
      } = getDebugTableForUniforms({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms),
        undefinedOnly: true
      });
      if (missingCount > 0) {
        log2.log("MISSING UNIFORMS", Object.keys(missingTable))();
      }
      if (unusedCount > 0) {
        log2.log("UNUSED UNIFORMS", Object.keys(unusedTable))();
      }
      const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);
      log2.table(logLevel, attributeTable)();
      log2.table(logLevel, uniformTable)();
      log2.table(logLevel + 1, configTable)();
      if (framebuffer) {
        framebuffer.log({
          logLevel: LOG_DRAW_PRIORITY,
          message: "Rendered to ".concat(framebuffer.id)
        });
      }
      log2.groupEnd(LOG_DRAW_PRIORITY)();
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js
  var BufferTransform = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.currentIndex = 0;
      this.feedbackMap = {};
      this.varyings = null;
      this.bindings = [];
      this.resources = {};
      this._initialize(props);
      Object.seal(this);
    }
    setupResources(opts) {
      for (const binding of this.bindings) {
        this._setupTransformFeedback(binding, opts);
      }
    }
    updateModelProps() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        varyings
      } = this;
      if (varyings.length > 0) {
        props = Object.assign({}, props, {
          varyings
        });
      }
      return props;
    }
    getDrawOptions() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const binding = this.bindings[this.currentIndex];
      const {
        sourceBuffers,
        transformFeedback
      } = binding;
      const attributes = Object.assign({}, sourceBuffers, opts.attributes);
      return {
        attributes,
        transformFeedback
      };
    }
    swap() {
      if (this.feedbackMap) {
        this.currentIndex = this._getNextIndex();
        return true;
      }
      return false;
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupBuffers(opts);
    }
    getBuffer(varyingName) {
      const {
        feedbackBuffers
      } = this.bindings[this.currentIndex];
      const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
      if (!bufferOrParams) {
        return null;
      }
      return bufferOrParams instanceof Buffer2 ? bufferOrParams : bufferOrParams.buffer;
    }
    getData() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        varyingName
      } = options;
      const buffer = this.getBuffer(varyingName);
      if (buffer) {
        return buffer.getData();
      }
      return null;
    }
    delete() {
      for (const name in this.resources) {
        this.resources[name].delete();
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupBuffers(props);
      this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
      if (this.varyings.length > 0) {
        assert6(isWebGL2(this.gl));
      }
    }
    _getFeedbackBuffers(props) {
      const {
        sourceBuffers = {}
      } = props;
      const feedbackBuffers = {};
      if (this.bindings[this.currentIndex]) {
        Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
      }
      if (this.feedbackMap) {
        for (const sourceName in this.feedbackMap) {
          const feedbackName = this.feedbackMap[sourceName];
          if (sourceName in sourceBuffers) {
            feedbackBuffers[feedbackName] = sourceName;
          }
        }
      }
      Object.assign(feedbackBuffers, props.feedbackBuffers);
      for (const bufferName in feedbackBuffers) {
        const bufferOrRef = feedbackBuffers[bufferName];
        if (typeof bufferOrRef === "string") {
          const sourceBuffer = sourceBuffers[bufferOrRef];
          const {
            byteLength,
            usage,
            accessor
          } = sourceBuffer;
          feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
            byteLength,
            usage,
            accessor
          });
        }
      }
      return feedbackBuffers;
    }
    _setupBuffers() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers = null
      } = props;
      Object.assign(this.feedbackMap, props.feedbackMap);
      const feedbackBuffers = this._getFeedbackBuffers(props);
      this._updateBindings({
        sourceBuffers,
        feedbackBuffers
      });
    }
    _setupTransformFeedback(binding, _ref) {
      let {
        model
      } = _ref;
      const {
        program
      } = model;
      binding.transformFeedback = new TransformFeedback(this.gl, {
        program,
        buffers: binding.feedbackBuffers
      });
    }
    _updateBindings(opts) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
      if (this.feedbackMap) {
        const {
          sourceBuffers,
          feedbackBuffers
        } = this._swapBuffers(this.bindings[this.currentIndex]);
        const nextIndex = this._getNextIndex();
        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
          sourceBuffers,
          feedbackBuffers
        });
      }
    }
    _updateBinding(binding, opts) {
      if (!binding) {
        return {
          sourceBuffers: Object.assign({}, opts.sourceBuffers),
          feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
        };
      }
      Object.assign(binding.sourceBuffers, opts.sourceBuffers);
      Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
      if (binding.transformFeedback) {
        binding.transformFeedback.setBuffers(binding.feedbackBuffers);
      }
      return binding;
    }
    _swapBuffers(opts) {
      if (!this.feedbackMap) {
        return null;
      }
      const sourceBuffers = Object.assign({}, opts.sourceBuffers);
      const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
      for (const srcName in this.feedbackMap) {
        const dstName = this.feedbackMap[srcName];
        sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
        feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
        assert6(feedbackBuffers[dstName] instanceof Buffer2);
      }
      return {
        sourceBuffers,
        feedbackBuffers
      };
    }
    _createNewBuffer(name, opts) {
      const buffer = new Buffer2(this.gl, opts);
      if (this.resources[name]) {
        this.resources[name].delete();
      }
      this.resources[name] = buffer;
      return buffer;
    }
    _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js
  var SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
  var SIZE_UNIFORM_PREFIX = "transform_uSize_";
  var VS_POS_VARIABLE = "transform_position";
  function updateForTextures(_ref) {
    let {
      vs: vs7,
      sourceTextureMap,
      targetTextureVarying,
      targetTexture
    } = _ref;
    const texAttributeNames = Object.keys(sourceTextureMap);
    let sourceCount = texAttributeNames.length;
    let targetTextureType = null;
    const samplerTextureMap = {};
    let updatedVs = vs7;
    let finalInject = {};
    if (sourceCount > 0 || targetTextureVarying) {
      const vsLines = updatedVs.split("\n");
      const updateVsLines = vsLines.slice();
      vsLines.forEach((line, index, lines) => {
        if (sourceCount > 0) {
          const updated = processAttributeDefinition(line, sourceTextureMap);
          if (updated) {
            const {
              updatedLine,
              inject
            } = updated;
            updateVsLines[index] = updatedLine;
            finalInject = combineInjects([finalInject, inject]);
            Object.assign(samplerTextureMap, updated.samplerTextureMap);
            sourceCount--;
          }
        }
        if (targetTextureVarying && !targetTextureType) {
          targetTextureType = getVaryingType(line, targetTextureVarying);
        }
      });
      if (targetTextureVarying) {
        assert6(targetTexture);
        const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
        const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
        const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
        const inject = {
          "vs:#decl": uniformDeclaration,
          "vs:#main-start": posInstructions
        };
        finalInject = combineInjects([finalInject, inject]);
      }
      updatedVs = updateVsLines.join("\n");
    }
    return {
      vs: updatedVs,
      targetTextureType,
      inject: finalInject,
      samplerTextureMap
    };
  }
  function getSizeUniforms(_ref2) {
    let {
      sourceTextureMap,
      targetTextureVarying,
      targetTexture
    } = _ref2;
    const uniforms = {};
    let width;
    let height;
    if (targetTextureVarying) {
      ({
        width,
        height
      } = targetTexture);
      uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
    }
    for (const textureName in sourceTextureMap) {
      ({
        width,
        height
      } = sourceTextureMap[textureName]);
      uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
    }
    return uniforms;
  }
  function getAttributeDefinition(line) {
    return getQualifierDetails(line, ["attribute", "in"]);
  }
  function getSamplerDeclerations(textureName) {
    const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
    const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
    const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
    return {
      samplerName,
      sizeName,
      uniformDeclerations
    };
  }
  function getVaryingType(line, varying) {
    const qualaiferDetails = getQualifierDetails(line, ["varying", "out"]);
    if (!qualaiferDetails) {
      return null;
    }
    return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
  }
  function processAttributeDefinition(line, textureMap) {
    const samplerTextureMap = {};
    const attributeData = getAttributeDefinition(line);
    if (!attributeData) {
      return null;
    }
    const {
      type,
      name
    } = attributeData;
    if (name && textureMap[name]) {
      const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
      const {
        samplerName,
        sizeName,
        uniformDeclerations
      } = getSamplerDeclerations(name);
      const channels = typeToChannelSuffix(type);
      const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
      samplerTextureMap[samplerName] = name;
      const inject = {
        "vs:#decl": uniformDeclerations,
        "vs:#main-start": sampleInstruction
      };
      return {
        updatedLine,
        inject,
        samplerTextureMap
      };
    }
    return null;
  }

  // node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js
  var SRC_TEX_PARAMETER_OVERRIDES = {
    [10241]: 9728,
    [10240]: 9728,
    [10242]: 33071,
    [10243]: 33071
  };
  var FS_OUTPUT_VARIABLE = "transform_output";
  var TextureTransform = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.id = this.currentIndex = 0;
      this._swapTexture = null;
      this.targetTextureVarying = null;
      this.targetTextureType = null;
      this.samplerTextureMap = null;
      this.bindings = [];
      this.resources = {};
      this._initialize(props);
      Object.seal(this);
    }
    updateModelProps() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const updatedModelProps = this._processVertexShader(props);
      return Object.assign({}, props, updatedModelProps);
    }
    getDrawOptions() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers,
        sourceTextures,
        framebuffer,
        targetTexture
      } = this.bindings[this.currentIndex];
      const attributes = Object.assign({}, sourceBuffers, opts.attributes);
      const uniforms = Object.assign({}, opts.uniforms);
      const parameters = Object.assign({}, opts.parameters);
      let discard = opts.discard;
      if (this.hasSourceTextures || this.hasTargetTexture) {
        attributes.transform_elementID = this.elementIDBuffer;
        for (const sampler in this.samplerTextureMap) {
          const textureName = this.samplerTextureMap[sampler];
          uniforms[sampler] = sourceTextures[textureName];
        }
        this._setSourceTextureParameters();
        const sizeUniforms = getSizeUniforms({
          sourceTextureMap: sourceTextures,
          targetTextureVarying: this.targetTextureVarying,
          targetTexture
        });
        Object.assign(uniforms, sizeUniforms);
      }
      if (this.hasTargetTexture) {
        discard = false;
        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
      }
      return {
        attributes,
        framebuffer,
        uniforms,
        discard,
        parameters
      };
    }
    swap() {
      if (this._swapTexture) {
        this.currentIndex = this._getNextIndex();
        return true;
      }
      return false;
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupTextures(opts);
    }
    getTargetTexture() {
      const {
        targetTexture
      } = this.bindings[this.currentIndex];
      return targetTexture;
    }
    getData() {
      let {
        packed = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        framebuffer
      } = this.bindings[this.currentIndex];
      const pixels = readPixelsToArray(framebuffer);
      if (!packed) {
        return pixels;
      }
      const ArrayType = pixels.constructor;
      const channelCount = typeToChannelCount(this.targetTextureType);
      const packedPixels = new ArrayType(pixels.length * channelCount / 4);
      let packCount = 0;
      for (let i2 = 0; i2 < pixels.length; i2 += 4) {
        for (let j = 0; j < channelCount; j++) {
          packedPixels[packCount++] = pixels[i2 + j];
        }
      }
      return packedPixels;
    }
    getFramebuffer() {
      const currentResources = this.bindings[this.currentIndex];
      return currentResources.framebuffer;
    }
    delete() {
      if (this.ownTexture) {
        this.ownTexture.delete();
      }
      if (this.elementIDBuffer) {
        this.elementIDBuffer.delete();
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        _targetTextureVarying,
        _swapTexture
      } = props;
      this._swapTexture = _swapTexture;
      this.targetTextureVarying = _targetTextureVarying;
      this.hasTargetTexture = _targetTextureVarying;
      this._setupTextures(props);
    }
    _createTargetTexture(props) {
      const {
        sourceTextures,
        textureOrReference
      } = props;
      if (textureOrReference instanceof Texture2D) {
        return textureOrReference;
      }
      const refTexture = sourceTextures[textureOrReference];
      if (!refTexture) {
        return null;
      }
      this._targetRefTexName = textureOrReference;
      return this._createNewTexture(refTexture);
    }
    _setupTextures() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers,
        _sourceTextures = {},
        _targetTexture
      } = props;
      const targetTexture = this._createTargetTexture({
        sourceTextures: _sourceTextures,
        textureOrReference: _targetTexture
      });
      this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
      this._updateBindings({
        sourceBuffers,
        sourceTextures: _sourceTextures,
        targetTexture
      });
      if ("elementCount" in props) {
        this._updateElementIDBuffer(props.elementCount);
      }
    }
    _updateElementIDBuffer(elementCount) {
      if (typeof elementCount !== "number" || this.elementCount >= elementCount) {
        return;
      }
      const elementIds = new Float32Array(elementCount);
      elementIds.forEach((_2, index, array) => {
        array[index] = index;
      });
      if (!this.elementIDBuffer) {
        this.elementIDBuffer = new Buffer2(this.gl, {
          data: elementIds,
          accessor: {
            size: 1
          }
        });
      } else {
        this.elementIDBuffer.setData({
          data: elementIds
        });
      }
      this.elementCount = elementCount;
    }
    _updateBindings(opts) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
      if (this._swapTexture) {
        const {
          sourceTextures,
          targetTexture
        } = this._swapTextures(this.bindings[this.currentIndex]);
        const nextIndex = this._getNextIndex();
        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
          sourceTextures,
          targetTexture
        });
      }
    }
    _updateBinding(binding, opts) {
      const {
        sourceBuffers,
        sourceTextures,
        targetTexture
      } = opts;
      if (!binding) {
        binding = {
          sourceBuffers: {},
          sourceTextures: {},
          targetTexture: null
        };
      }
      Object.assign(binding.sourceTextures, sourceTextures);
      Object.assign(binding.sourceBuffers, sourceBuffers);
      if (targetTexture) {
        binding.targetTexture = targetTexture;
        const {
          width,
          height
        } = targetTexture;
        const {
          framebuffer
        } = binding;
        if (framebuffer) {
          framebuffer.update({
            attachments: {
              [36064]: targetTexture
            },
            resizeAttachments: false
          });
          framebuffer.resize({
            width,
            height
          });
        } else {
          binding.framebuffer = new Framebuffer(this.gl, {
            id: "transform-framebuffer",
            width,
            height,
            attachments: {
              [36064]: targetTexture
            }
          });
        }
      }
      return binding;
    }
    _setSourceTextureParameters() {
      const index = this.currentIndex;
      const {
        sourceTextures
      } = this.bindings[index];
      for (const name in sourceTextures) {
        sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
      }
    }
    _swapTextures(opts) {
      if (!this._swapTexture) {
        return null;
      }
      const sourceTextures = Object.assign({}, opts.sourceTextures);
      sourceTextures[this._swapTexture] = opts.targetTexture;
      const targetTexture = opts.sourceTextures[this._swapTexture];
      return {
        sourceTextures,
        targetTexture
      };
    }
    _createNewTexture(refTexture) {
      const texture = cloneTextureFrom(refTexture, {
        parameters: {
          [10241]: 9728,
          [10240]: 9728,
          [10242]: 33071,
          [10243]: 33071
        },
        pixelStore: {
          [37440]: false
        }
      });
      if (this.ownTexture) {
        this.ownTexture.delete();
      }
      this.ownTexture = texture;
      return texture;
    }
    _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
    _processVertexShader() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceTextures,
        targetTexture
      } = this.bindings[this.currentIndex];
      const {
        vs: vs7,
        uniforms,
        targetTextureType,
        inject,
        samplerTextureMap
      } = updateForTextures({
        vs: props.vs,
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      const combinedInject = combineInjects([props.inject || {}, inject]);
      this.targetTextureType = targetTextureType;
      this.samplerTextureMap = samplerTextureMap;
      const fs4 = props._fs || getPassthroughFS({
        version: getShaderVersion(vs7),
        input: this.targetTextureVarying,
        inputType: targetTextureType,
        output: FS_OUTPUT_VARIABLE
      });
      const modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;
      return {
        vs: vs7,
        fs: fs4,
        modules,
        uniforms,
        inject: combinedInject
      };
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/transform/transform.js
  var Transform = class {
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.model = null;
      this.elementCount = 0;
      this.bufferTransform = null;
      this.textureTransform = null;
      this.elementIDBuffer = null;
      this._initialize(props);
      Object.seal(this);
    }
    delete() {
      const {
        model,
        bufferTransform,
        textureTransform
      } = this;
      if (model) {
        model.delete();
      }
      if (bufferTransform) {
        bufferTransform.delete();
      }
      if (textureTransform) {
        textureTransform.delete();
      }
    }
    run() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        clearRenderTarget = true
      } = opts;
      const updatedOpts = this._updateDrawOptions(opts);
      if (clearRenderTarget && updatedOpts.framebuffer) {
        updatedOpts.framebuffer.clear({
          color: true
        });
      }
      this.model.transform(updatedOpts);
    }
    swap() {
      let swapped = false;
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        swapped = swapped || resourceTransform.swap();
      }
      assert6(swapped, "Nothing to swap");
    }
    getBuffer() {
      let varyingName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
    }
    getData() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        const data = resourceTransform.getData(opts);
        if (data) {
          return data;
        }
      }
      return null;
    }
    getFramebuffer() {
      return this.textureTransform && this.textureTransform.getFramebuffer();
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if ("elementCount" in opts) {
        this.model.setVertexCount(opts.elementCount);
      }
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        resourceTransform.update(opts);
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        gl
      } = this;
      this._buildResourceTransforms(gl, props);
      props = this._updateModelProps(props);
      this.model = new Model(gl, Object.assign({}, props, {
        fs: props.fs || getPassthroughFS({
          version: getShaderVersion(props.vs)
        }),
        id: props.id || "transform-model",
        drawMode: props.drawMode || 0,
        vertexCount: props.elementCount
      }));
      this.bufferTransform && this.bufferTransform.setupResources({
        model: this.model
      });
    }
    _updateModelProps(props) {
      let updatedProps = Object.assign({}, props);
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        updatedProps = resourceTransform.updateModelProps(updatedProps);
      }
      return updatedProps;
    }
    _buildResourceTransforms(gl, props) {
      if (canCreateBufferTransform(props)) {
        this.bufferTransform = new BufferTransform(gl, props);
      }
      if (canCreateTextureTransform(props)) {
        this.textureTransform = new TextureTransform(gl, props);
      }
      assert6(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
    }
    _updateDrawOptions(opts) {
      let updatedOpts = Object.assign({}, opts);
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
      }
      return updatedOpts;
    }
  };
  function canCreateBufferTransform(props) {
    if (!isObjectEmpty2(props.feedbackBuffers) || !isObjectEmpty2(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
      return true;
    }
    return false;
  }
  function canCreateTextureTransform(props) {
    if (!isObjectEmpty2(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
      return true;
    }
    return false;
  }

  // node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js
  var DRAW_MODE = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  var Geometry = class {
    static get DRAW_MODE() {
      return DRAW_MODE;
    }
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id = uid("geometry"),
        drawMode = DRAW_MODE.TRIANGLES,
        attributes = {},
        indices = null,
        vertexCount = null
      } = props;
      this.id = id;
      this.drawMode = drawMode | 0;
      this.attributes = {};
      this.userData = {};
      this._setAttributes(attributes, indices);
      this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    get mode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.indices ? {
        indices: this.indices,
        ...this.attributes
      } : this.attributes;
    }
    _print(attributeName) {
      return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
    }
    _setAttributes(attributes, indices) {
      if (indices) {
        this.indices = ArrayBuffer.isView(indices) ? {
          value: indices,
          size: 1
        } : indices;
      }
      for (const attributeName in attributes) {
        let attribute = attributes[attributeName];
        attribute = ArrayBuffer.isView(attribute) ? {
          value: attribute
        } : attribute;
        assert6(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
        if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
          attribute.size = 3;
        }
        if (attributeName === "indices") {
          assert6(!this.indices);
          this.indices = attribute;
        } else {
          this.attributes[attributeName] = attribute;
        }
      }
      if (this.indices && this.indices.isIndexed !== void 0) {
        this.indices = Object.assign({}, this.indices);
        delete this.indices.isIndexed;
      }
      return this;
    }
    _calculateVertexCount(attributes, indices) {
      if (indices) {
        return indices.value.length;
      }
      let vertexCount = Infinity;
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const {
          value,
          size,
          constant
        } = attribute;
        if (!constant && value && size >= 1) {
          vertexCount = Math.min(vertexCount, value.length / size);
        }
      }
      assert6(Number.isFinite(vertexCount));
      return vertexCount;
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/animation/timeline.js
  var channelHandles = 1;
  var animationHandles = 1;
  var Timeline = class {
    constructor() {
      this.time = 0;
      this.channels = /* @__PURE__ */ new Map();
      this.animations = /* @__PURE__ */ new Map();
      this.playing = false;
      this.lastEngineTime = -1;
    }
    addChannel(props) {
      const {
        delay: delay2 = 0,
        duration = Number.POSITIVE_INFINITY,
        rate = 1,
        repeat = 1
      } = props;
      const handle = channelHandles++;
      const channel = {
        time: 0,
        delay: delay2,
        duration,
        rate,
        repeat
      };
      this._setChannelTime(channel, this.time);
      this.channels.set(handle, channel);
      return handle;
    }
    removeChannel(handle) {
      this.channels.delete(handle);
      for (const [animationHandle, animation] of this.animations) {
        if (animation.channel === handle) {
          this.detachAnimation(animationHandle);
        }
      }
    }
    isFinished(handle) {
      const channel = this.channels.get(handle);
      if (channel === void 0) {
        return false;
      }
      return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(handle) {
      if (handle === void 0) {
        return this.time;
      }
      const channel = this.channels.get(handle);
      if (channel === void 0) {
        return -1;
      }
      return channel.time;
    }
    setTime(time) {
      this.time = Math.max(0, time);
      const channels = this.channels.values();
      for (const channel of channels) {
        this._setChannelTime(channel, this.time);
      }
      const animations = this.animations.values();
      for (const animationData of animations) {
        const {
          animation,
          channel
        } = animationData;
        animation.setTime(this.getTime(channel));
      }
    }
    play() {
      this.playing = true;
    }
    pause() {
      this.playing = false;
      this.lastEngineTime = -1;
    }
    reset() {
      this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
      const animationHandle = animationHandles++;
      this.animations.set(animationHandle, {
        animation,
        channel: channelHandle
      });
      animation.setTime(this.getTime(channelHandle));
      return animationHandle;
    }
    detachAnimation(handle) {
      this.animations.delete(handle);
    }
    update(engineTime) {
      if (this.playing) {
        if (this.lastEngineTime === -1) {
          this.lastEngineTime = engineTime;
        }
        this.setTime(this.time + (engineTime - this.lastEngineTime));
        this.lastEngineTime = engineTime;
      }
    }
    _setChannelTime(channel, time) {
      const offsetTime = time - channel.delay;
      const totalDuration = channel.duration * channel.repeat;
      if (offsetTime >= totalDuration) {
        channel.time = channel.duration * channel.rate;
      } else {
        channel.time = Math.max(0, offsetTime) % channel.duration;
        channel.time *= channel.rate;
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js
  var DEFAULT_LIGHT_COLOR = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY = 1;
  var idCount = 0;
  var AmbientLight = class {
    constructor(props = {}) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "color", void 0);
      _defineProperty(this, "intensity", void 0);
      _defineProperty(this, "type", "ambient");
      const {
        color = DEFAULT_LIGHT_COLOR
      } = props;
      const {
        intensity = DEFAULT_LIGHT_INTENSITY
      } = props;
      this.id = props.id || "ambient-".concat(idCount++);
      this.color = color;
      this.intensity = intensity;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js
  var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY2 = 1;
  var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
  var idCount2 = 0;
  var DirectionalLight = class {
    constructor(props = {}) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "color", void 0);
      _defineProperty(this, "intensity", void 0);
      _defineProperty(this, "type", "directional");
      _defineProperty(this, "direction", void 0);
      _defineProperty(this, "shadow", void 0);
      const {
        color = DEFAULT_LIGHT_COLOR2
      } = props;
      const {
        intensity = DEFAULT_LIGHT_INTENSITY2
      } = props;
      const {
        direction = DEFAULT_LIGHT_DIRECTION
      } = props;
      const {
        _shadow = false
      } = props;
      this.id = props.id || "directional-".concat(idCount2++);
      this.color = color;
      this.intensity = intensity;
      this.type = "directional";
      this.direction = new Vector3(direction).normalize().toArray();
      this.shadow = _shadow;
    }
    getProjectedLight(opts) {
      return this;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/passes/pass.js
  var Pass = class {
    constructor(gl, props = {
      id: "pass"
    }) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "props", void 0);
      const {
        id
      } = props;
      this.id = id;
      this.gl = gl;
      this.props = {
        ...props
      };
    }
    setProps(props) {
      Object.assign(this.props, props);
    }
    render(params) {
    }
    cleanup() {
    }
  };

  // node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js
  var LayersPass = class extends Pass {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "_lastRenderIndex", -1);
    }
    render(options) {
      const gl = this.gl;
      setParameters(gl, {
        framebuffer: options.target
      });
      return this._drawLayers(options);
    }
    _drawLayers(options) {
      const {
        target,
        moduleParameters,
        viewports,
        views,
        onViewportActive,
        clearStack = true,
        clearCanvas = true
      } = options;
      options.pass = options.pass || "unknown";
      const gl = this.gl;
      if (clearCanvas) {
        clearGLCanvas(gl, target);
      }
      if (clearStack) {
        this._lastRenderIndex = -1;
      }
      const renderStats = [];
      for (const viewport of viewports) {
        const view = views && views[viewport.id];
        onViewportActive === null || onViewportActive === void 0 ? void 0 : onViewportActive(viewport);
        const drawLayerParams = this._getDrawLayerParams(viewport, options);
        const subViewports = viewport.subViewports || [viewport];
        for (const subViewport of subViewports) {
          const stats = this._drawLayersInViewport(gl, {
            target,
            moduleParameters,
            viewport: subViewport,
            view,
            pass: options.pass,
            layers: options.layers
          }, drawLayerParams);
          renderStats.push(stats);
        }
      }
      return renderStats;
    }
    _getDrawLayerParams(viewport, {
      layers,
      pass,
      isPicking = false,
      layerFilter,
      cullRect,
      effects,
      moduleParameters
    }, evaluateShouldDrawOnly = false) {
      const drawLayerParams = [];
      const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
      const drawContext = {
        layer: layers[0],
        viewport,
        isPicking,
        renderPass: pass,
        cullRect
      };
      const layerFilterCache = {};
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
        const layerParam = {
          shouldDrawLayer
        };
        if (shouldDrawLayer && !evaluateShouldDrawOnly) {
          layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
          layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
          layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
        }
        drawLayerParams[layerIndex] = layerParam;
      }
      return drawLayerParams;
    }
    _drawLayersInViewport(gl, {
      layers,
      moduleParameters: globalModuleParameters,
      pass,
      target,
      viewport,
      view
    }, drawLayerParams) {
      const glViewport = getGLViewport(gl, {
        moduleParameters: globalModuleParameters,
        target,
        viewport
      });
      if (view && view.props.clear) {
        const clearOpts = view.props.clear === true ? {
          color: true,
          depth: true
        } : view.props.clear;
        withParameters(gl, {
          scissorTest: true,
          scissor: glViewport
        }, () => clear(gl, clearOpts));
      }
      const renderStatus = {
        totalCount: layers.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      setParameters(gl, {
        viewport: glViewport
      });
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const {
          shouldDrawLayer,
          layerRenderIndex,
          moduleParameters,
          layerParameters
        } = drawLayerParams[layerIndex];
        if (shouldDrawLayer && layer.props.pickable) {
          renderStatus.pickableCount++;
        }
        if (layer.isComposite) {
          renderStatus.compositeCount++;
        } else if (shouldDrawLayer) {
          renderStatus.visibleCount++;
          this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
          moduleParameters.viewport = viewport;
          try {
            layer._drawLayer({
              moduleParameters,
              uniforms: {
                layerIndex: layerRenderIndex
              },
              parameters: layerParameters
            });
          } catch (err) {
            layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
          }
        }
      }
      return renderStatus;
    }
    shouldDrawLayer(layer) {
      return true;
    }
    getModuleParameters(layer, effects) {
      return null;
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return layer.props.parameters;
    }
    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
      const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
      if (!shouldDrawLayer) {
        return false;
      }
      drawContext.layer = layer;
      let parent = layer.parent;
      while (parent) {
        if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
          return false;
        }
        drawContext.layer = parent;
        parent = parent.parent;
      }
      if (layerFilter) {
        const rootLayerId = drawContext.layer.id;
        if (!(rootLayerId in layerFilterCache)) {
          layerFilterCache[rootLayerId] = layerFilter(drawContext);
        }
        if (!layerFilterCache[rootLayerId]) {
          return false;
        }
      }
      layer.activateViewport(drawContext.viewport);
      return true;
    }
    _getModuleParameters(layer, effects, pass, overrides) {
      var _layer$internalState;
      const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
        autoWrapLongitude: layer.wrapLongitude,
        viewport: layer.context.viewport,
        mousePosition: layer.context.mousePosition,
        pickingActive: 0,
        devicePixelRatio: cssToDeviceRatio(this.gl)
      });
      if (effects) {
        for (const effect of effects) {
          var _effect$getModulePara;
          Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));
        }
      }
      return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
    }
  };
  function layerIndexResolver(startIndex = 0, layerIndices = {}) {
    const resolvers = {};
    const resolveLayerIndex = (layer, isDrawn) => {
      const indexOverride = layer.props._offset;
      const layerId = layer.id;
      const parentId = layer.parent && layer.parent.id;
      let index;
      if (parentId && !(parentId in layerIndices)) {
        resolveLayerIndex(layer.parent, false);
      }
      if (parentId in resolvers) {
        const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
        index = resolver(layer, isDrawn);
        resolvers[layerId] = resolver;
      } else if (Number.isFinite(indexOverride)) {
        index = indexOverride + (layerIndices[parentId] || 0);
        resolvers[layerId] = null;
      } else {
        index = startIndex;
      }
      if (isDrawn && index >= startIndex) {
        startIndex = index + 1;
      }
      layerIndices[layerId] = index;
      return index;
    };
    return resolveLayerIndex;
  }
  function getGLViewport(gl, {
    moduleParameters,
    target,
    viewport
  }) {
    const useTarget = target && target.id !== "default-framebuffer";
    const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || cssToDeviceRatio(gl);
    const height = useTarget ? target.height : gl.drawingBufferHeight;
    const dimensions = viewport;
    return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
  }
  function clearGLCanvas(gl, targetFramebuffer) {
    const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;
    const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;
    setParameters(gl, {
      viewport: [0, 0, width, height]
    });
    gl.clear(16384 | 256);
  }

  // node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js
  var ShadowPass = class extends LayersPass {
    constructor(gl, props) {
      super(gl, props);
      _defineProperty(this, "shadowMap", void 0);
      _defineProperty(this, "depthBuffer", void 0);
      _defineProperty(this, "fbo", void 0);
      this.shadowMap = new Texture2D(gl, {
        width: 1,
        height: 1,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      });
      this.depthBuffer = new Renderbuffer(gl, {
        format: 33189,
        width: 1,
        height: 1
      });
      this.fbo = new Framebuffer(gl, {
        id: "shadowmap",
        width: 1,
        height: 1,
        attachments: {
          [36064]: this.shadowMap,
          [36096]: this.depthBuffer
        }
      });
    }
    render(params) {
      const target = this.fbo;
      withParameters(this.gl, {
        depthRange: [0, 1],
        depthTest: true,
        blend: false,
        clearColor: [1, 1, 1, 1]
      }, () => {
        const viewport = params.viewports[0];
        const pixelRatio = cssToDeviceRatio(this.gl);
        const width = viewport.width * pixelRatio;
        const height = viewport.height * pixelRatio;
        if (width !== target.width || height !== target.height) {
          target.resize({
            width,
            height
          });
        }
        super.render({
          ...params,
          target,
          pass: "shadow"
        });
      });
    }
    shouldDrawLayer(layer) {
      return layer.props.shadowEnabled !== false;
    }
    getModuleParameters() {
      return {
        drawToShadowMap: true
      };
    }
    delete() {
      if (this.fbo) {
        this.fbo.delete();
        this.fbo = null;
      }
      if (this.shadowMap) {
        this.shadowMap.delete();
        this.shadowMap = null;
      }
      if (this.depthBuffer) {
        this.depthBuffer.delete();
        this.depthBuffer = null;
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js
  var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
  var vs3 = "\n".concat(defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
  var fs2 = "\n".concat(defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
  var geometry_default = {
    name: "geometry",
    vs: vs3,
    fs: fs2
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js
  var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(COORDINATE_SYSTEM[key], ";")).join("");
  var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => "const int PROJECTION_MODE_".concat(key, " = ").concat(PROJECTION_MODE[key], ";")).join("");
  var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => "const int UNIT_".concat(key.toUpperCase(), " = ").concat(UNIT[key], ";")).join("");
  var project_glsl_default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat(UNIT_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");

  // node_modules/@deck.gl/core/dist/esm/utils/memoize.js
  function isEqual(a2, b2) {
    if (a2 === b2) {
      return true;
    }
    if (Array.isArray(a2)) {
      const len = a2.length;
      if (!b2 || b2.length !== len) {
        return false;
      }
      for (let i2 = 0; i2 < len; i2++) {
        if (a2[i2] !== b2[i2]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function memoize(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js
  var ZERO_VECTOR = [0, 0, 0, 0];
  var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  var IDENTITY_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
  var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
  var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
  function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
    if (coordinateOrigin.length < 3) {
      coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
    }
    let shaderCoordinateOrigin = coordinateOrigin;
    let geospatialOrigin;
    let offsetMode = true;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
      geospatialOrigin = coordinateOrigin;
    } else {
      geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
    }
    switch (viewport.projectionMode) {
      case PROJECTION_MODE.WEB_MERCATOR:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          geospatialOrigin = [0, 0, 0];
          offsetMode = false;
        }
        break;
      case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          shaderCoordinateOrigin = geospatialOrigin;
        } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
          geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
          shaderCoordinateOrigin[0] -= coordinateOrigin[0];
          shaderCoordinateOrigin[1] -= coordinateOrigin[1];
          shaderCoordinateOrigin[2] -= coordinateOrigin[2];
        }
        break;
      case PROJECTION_MODE.IDENTITY:
        shaderCoordinateOrigin = viewport.position.map(Math.fround);
        shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
        break;
      case PROJECTION_MODE.GLOBE:
        offsetMode = false;
        geospatialOrigin = null;
        break;
      default:
        offsetMode = false;
    }
    return {
      geospatialOrigin,
      shaderCoordinateOrigin,
      offsetMode
    };
  }
  function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
    const {
      viewMatrixUncentered,
      projectionMatrix
    } = viewport;
    let {
      viewMatrix,
      viewProjectionMatrix
    } = viewport;
    let projectionCenter = ZERO_VECTOR;
    let originCommon = ZERO_VECTOR;
    let cameraPosCommon = viewport.cameraPosition;
    const {
      geospatialOrigin,
      shaderCoordinateOrigin,
      offsetMode
    } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
    if (offsetMode) {
      originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
      originCommon[3] = 1;
      projectionCenter = transformMat43([], originCommon, viewProjectionMatrix);
      viewMatrix = viewMatrixUncentered || viewMatrix;
      viewProjectionMatrix = multiply([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
    }
    return {
      viewMatrix,
      viewProjectionMatrix,
      projectionCenter,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    };
  }
  function getUniformsFromViewport({
    viewport,
    devicePixelRatio = 1,
    modelMatrix = null,
    coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
    autoWrapLongitude = false
  }) {
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    const uniforms = getMemoizedViewportUniforms({
      viewport,
      devicePixelRatio,
      coordinateSystem,
      coordinateOrigin
    });
    uniforms.project_uWrapLongitude = autoWrapLongitude;
    uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX2;
    return uniforms;
  }
  function calculateViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  }) {
    const {
      projectionCenter,
      viewProjectionMatrix,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
    const distanceScales = viewport.getDistanceScales();
    const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
    const focalDistance = transformMat43([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
    const uniforms = {
      project_uCoordinateSystem: coordinateSystem,
      project_uProjectionMode: viewport.projectionMode,
      project_uCoordinateOrigin: shaderCoordinateOrigin,
      project_uCommonOrigin: originCommon.slice(0, 3),
      project_uCenter: projectionCenter,
      project_uPseudoMeters: Boolean(viewport._pseudoMeters),
      project_uViewportSize: viewportSize,
      project_uDevicePixelRatio: devicePixelRatio,
      project_uFocalDistance: focalDistance,
      project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
      project_uScale: viewport.scale,
      project_uWrapLongitude: false,
      project_uViewProjectionMatrix: viewProjectionMatrix,
      project_uModelMatrix: IDENTITY_MATRIX2,
      project_uCameraPosition: cameraPosCommon
    };
    if (geospatialOrigin) {
      const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
      switch (coordinateSystem) {
        case COORDINATE_SYSTEM.METER_OFFSETS:
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
          break;
        case COORDINATE_SYSTEM.LNGLAT:
        case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
          if (!viewport._pseudoMeters) {
            uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
          }
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
          break;
        case COORDINATE_SYSTEM.CARTESIAN:
          uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
          uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
          break;
        default:
          break;
      }
    }
    return uniforms;
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js
  var INITIAL_MODULE_OPTIONS3 = {};
  function getUniforms4(opts = INITIAL_MODULE_OPTIONS3) {
    if ("viewport" in opts) {
      return getUniformsFromViewport(opts);
    }
    return {};
  }
  var project_default = {
    name: "project",
    dependencies: [fp32, geometry_default],
    vs: project_glsl_default,
    getUniforms: getUniforms4
  };

  // node_modules/@math.gl/web-mercator/dist/esm/math-utils.js
  function createMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function transformVector(matrix, vector) {
    const result = transformMat43([], vector, matrix);
    scale2(result, result, 1 / result[3]);
    return result;
  }
  function mod(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function clamp2(x2, min, max) {
    return x2 < min ? min : x2 > max ? max : x2;
  }
  function ieLog2(x2) {
    return Math.log(x2) * Math.LOG2E;
  }
  var log22 = Math.log2 || ieLog2;

  // node_modules/@math.gl/web-mercator/dist/esm/assert.js
  function assert9(condition, message) {
    if (!condition) {
      throw new Error(message || "@math.gl/web-mercator: assertion failed.");
    }
  }

  // node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS2 = PI / 180;
  var RADIANS_TO_DEGREES2 = 180 / PI;
  var TILE_SIZE = 512;
  var EARTH_CIRCUMFERENCE = 4003e4;
  var MAX_LATITUDE = 85.051129;
  var DEFAULT_ALTITUDE = 1.5;
  function scaleToZoom(scale3) {
    return log22(scale3);
  }
  function lngLatToWorld(lngLat) {
    const [lng, lat] = lngLat;
    assert9(Number.isFinite(lng));
    assert9(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * DEGREES_TO_RADIANS2;
    const phi2 = lat * DEGREES_TO_RADIANS2;
    const x2 = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y2 = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [x2, y2];
  }
  function worldToLngLat(xy) {
    const [x2, y2] = xy;
    const lambda2 = x2 / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y2 / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
  }
  function getMeterZoom(options) {
    const {
      latitude
    } = options;
    assert9(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
  }
  function unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
  }
  function getDistanceScales(options) {
    const {
      latitude,
      longitude,
      highPrecision = false
    } = options;
    assert9(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = TILE_SIZE;
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
    const result = {
      unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
      metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
      unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
      degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
    };
    if (highPrecision) {
      const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
      const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
      const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
      const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
      result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
      result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
    }
    return result;
  }
  function addMetersToLngLat(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x2, y2, z] = xyz;
    const {
      unitsPerMeter: unitsPerMeter2,
      unitsPerMeter2: unitsPerMeter22
    } = getDistanceScales({
      longitude,
      latitude,
      highPrecision: true
    });
    const worldspace = lngLatToWorld(lngLatZ);
    worldspace[0] += x2 * (unitsPerMeter2[0] + unitsPerMeter22[0] * y2);
    worldspace[1] += y2 * (unitsPerMeter2[1] + unitsPerMeter22[1] * y2);
    const newLngLat = worldToLngLat(worldspace);
    const newZ = (z0 || 0) + (z || 0);
    return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
  }
  function getViewMatrix(options) {
    const {
      height,
      pitch,
      bearing,
      altitude,
      scale: scale3,
      center
    } = options;
    const vm = createMat4();
    translate(vm, vm, [0, 0, -altitude]);
    rotateX2(vm, vm, -pitch * DEGREES_TO_RADIANS2);
    rotateZ2(vm, vm, bearing * DEGREES_TO_RADIANS2);
    const relativeScale = scale3 / height;
    scale(vm, vm, [relativeScale, relativeScale, relativeScale]);
    if (center) {
      translate(vm, vm, negate2([], center));
    }
    return vm;
  }
  function getProjectionParameters(options) {
    const {
      width,
      height,
      altitude,
      pitch = 0,
      offset,
      center,
      scale: scale3,
      nearZMultiplier = 1,
      farZMultiplier = 1
    } = options;
    let {
      fovy = altitudeToFovy(DEFAULT_ALTITUDE)
    } = options;
    if (altitude !== void 0) {
      fovy = altitudeToFovy(altitude);
    }
    const fovRadians = fovy * DEGREES_TO_RADIANS2;
    const pitchRadians = pitch * DEGREES_TO_RADIANS2;
    const focalDistance = fovyToAltitude(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) {
      cameraToSeaLevelDistance += center[2] * scale3 / Math.cos(pitchRadians) / height;
    }
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    const horizonDistance = cameraToSeaLevelDistance * 10;
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
      fov: fovRadians,
      aspect: width / height,
      focalDistance,
      near: nearZMultiplier,
      far: farZ
    };
  }
  function altitudeToFovy(altitude) {
    return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
  }
  function fovyToAltitude(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
  }
  function worldToPixels(xyz, pixelProjectionMatrix) {
    const [x2, y2, z = 0] = xyz;
    assert9(Number.isFinite(x2) && Number.isFinite(y2) && Number.isFinite(z));
    return transformVector(pixelProjectionMatrix, [x2, y2, z, 1]);
  }
  function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x2, y2, z] = xyz;
    assert9(Number.isFinite(x2) && Number.isFinite(y2), "invalid pixel coordinate");
    if (Number.isFinite(z)) {
      const coord = transformVector(pixelUnprojectionMatrix, [x2, y2, z, 1]);
      return coord;
    }
    const coord0 = transformVector(pixelUnprojectionMatrix, [x2, y2, 0, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x2, y2, 1, 1]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t2 = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return lerp2([], coord0, coord1, t2);
  }

  // node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js
  function fitBounds(options) {
    const {
      width,
      height,
      bounds,
      minExtent = 0,
      maxZoom = 24,
      offset = [0, 0]
    } = options;
    const [[west, south], [east, north]] = bounds;
    const padding = getPaddingObject(options.padding);
    const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
    const se = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
    const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
    const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
    assert9(targetSize[0] > 0 && targetSize[1] > 0);
    const scaleX2 = targetSize[0] / size[0];
    const scaleY2 = targetSize[1] / size[1];
    const offsetX = (padding.right - padding.left) / 2 / scaleX2;
    const offsetY = (padding.top - padding.bottom) / 2 / scaleY2;
    const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
    const centerLngLat = worldToLngLat(center);
    const zoom = Math.min(maxZoom, log22(Math.abs(Math.min(scaleX2, scaleY2))));
    assert9(Number.isFinite(zoom));
    return {
      longitude: centerLngLat[0],
      latitude: centerLngLat[1],
      zoom
    };
  }
  function getPaddingObject(padding = 0) {
    if (typeof padding === "number") {
      return {
        top: padding,
        bottom: padding,
        left: padding,
        right: padding
      };
    }
    assert9(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
  }

  // node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js
  var DEGREES_TO_RADIANS3 = Math.PI / 180;
  function getBounds(viewport, z = 0) {
    const {
      width,
      height,
      unproject
    } = viewport;
    const unprojectOps = {
      targetZ: z
    };
    const bottomLeft = unproject([0, height], unprojectOps);
    const bottomRight = unproject([width, height], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
    if (halfFov > angleToGround - 0.01) {
      topLeft = unprojectOnFarPlane(viewport, 0, z);
      topRight = unprojectOnFarPlane(viewport, width, z);
    } else {
      topLeft = unproject([0, 0], unprojectOps);
      topRight = unproject([width, 0], unprojectOps);
    }
    return [bottomLeft, bottomRight, topRight, topLeft];
  }
  function unprojectOnFarPlane(viewport, x2, targetZ) {
    const {
      pixelUnprojectionMatrix
    } = viewport;
    const coord0 = transformVector(pixelUnprojectionMatrix, [x2, 0, 1, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x2, viewport.height, 1, 1]);
    const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t2 = (z - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = lerp2([], coord0, coord1, t2);
    const result = worldToLngLat(coord);
    result.push(targetZ);
    return result;
  }

  // node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js
  var TILE_SIZE2 = 512;
  function normalizeViewportProps(props) {
    const {
      width,
      height,
      pitch = 0
    } = props;
    let {
      longitude,
      latitude,
      zoom,
      bearing = 0
    } = props;
    if (longitude < -180 || longitude > 180) {
      longitude = mod(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      bearing = mod(bearing + 180, 360) - 180;
    }
    const minZoom = log22(height / TILE_SIZE2);
    if (zoom <= minZoom) {
      zoom = minZoom;
      latitude = 0;
    } else {
      const halfHeightPixels = height / 2 / Math.pow(2, zoom);
      const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
      if (latitude < minLatitude) {
        latitude = minLatitude;
      } else {
        const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
        if (latitude > maxLatitude) {
          latitude = maxLatitude;
        }
      }
    }
    return {
      width,
      height,
      longitude,
      latitude,
      zoom,
      pitch,
      bearing
    };
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js
  var vs4 = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
  var fs3 = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
  var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
  var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
  var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
  var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
    const [x2, y2, z] = xyz;
    const coord = pixelsToWorld([x2, y2, z], pixelUnprojectionMatrix);
    if (Number.isFinite(z)) {
      return coord;
    }
    return [coord[0], coord[1], 0];
  }
  function getViewportCenterPosition({
    viewport,
    center
  }) {
    return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
  }
  function getViewProjectionMatrices({
    viewport,
    shadowMatrices
  }) {
    const projectionMatrices = [];
    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
    const farZ = viewport.isGeospatial ? void 0 : 1;
    const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map((pixel) => screenToCommonSpace(pixel, pixelUnprojectionMatrix));
    for (const shadowMatrix of shadowMatrices) {
      const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
      const positions = corners.map((corner) => viewMatrix.transform(corner));
      const projectionMatrix = new Matrix4().ortho({
        left: Math.min(...positions.map((position) => position[0])),
        right: Math.max(...positions.map((position) => position[0])),
        bottom: Math.min(...positions.map((position) => position[1])),
        top: Math.max(...positions.map((position) => position[1])),
        near: Math.min(...positions.map((position) => -position[2])),
        far: Math.max(...positions.map((position) => -position[2]))
      });
      projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    }
    return projectionMatrices;
  }
  function createShadowUniforms(opts, context) {
    const {
      shadowEnabled = true
    } = opts;
    if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
      return {
        shadow_uDrawShadowMap: false,
        shadow_uUseShadowMap: false
      };
    }
    const uniforms = {
      shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
      shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
      shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
      shadow_uLightId: opts.shadowLightId || 0,
      shadow_uLightCount: opts.shadowMatrices.length
    };
    const center = getMemoizedViewportCenterPosition({
      viewport: opts.viewport,
      center: context.project_uCenter
    });
    const projectCenters = [];
    const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
      shadowMatrices: opts.shadowMatrices,
      viewport: opts.viewport
    }).slice();
    for (let i2 = 0; i2 < opts.shadowMatrices.length; i2++) {
      const viewProjectionMatrix = viewProjectionMatrices[i2];
      const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
      if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
        viewProjectionMatrices[i2] = viewProjectionMatrixCentered;
        projectCenters[i2] = center;
      } else {
        viewProjectionMatrices[i2] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
        projectCenters[i2] = viewProjectionMatrixCentered.transform(center);
      }
    }
    for (let i2 = 0; i2 < viewProjectionMatrices.length; i2++) {
      uniforms["shadow_uViewProjectionMatrices[".concat(i2, "]")] = viewProjectionMatrices[i2];
      uniforms["shadow_uProjectCenters[".concat(i2, "]")] = projectCenters[i2];
      if (opts.shadowMaps && opts.shadowMaps.length > 0) {
        uniforms["shadow_uShadowMap".concat(i2)] = opts.shadowMaps[i2];
      } else {
        uniforms["shadow_uShadowMap".concat(i2)] = opts.dummyShadowMap;
      }
    }
    return uniforms;
  }
  var shadow_default = {
    name: "shadow",
    dependencies: [project_default],
    vs: vs4,
    fs: fs3,
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
      "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
    },
    getUniforms: (opts = {}, context = {}) => {
      if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
        return createShadowUniforms(opts, context);
      }
      return {};
    }
  };

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js
  var DEFAULT_AMBIENT_LIGHT_PROPS = {
    color: [255, 255, 255],
    intensity: 1
  };
  var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  }, {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }];
  var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
  var LightingEffect = class {
    constructor(props = {}) {
      _defineProperty(this, "id", "lighting-effect");
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "shadowColor", DEFAULT_SHADOW_COLOR2);
      _defineProperty(this, "shadow", void 0);
      _defineProperty(this, "ambientLight", void 0);
      _defineProperty(this, "directionalLights", void 0);
      _defineProperty(this, "pointLights", void 0);
      _defineProperty(this, "shadowPasses", []);
      _defineProperty(this, "shadowMaps", []);
      _defineProperty(this, "dummyShadowMap", null);
      _defineProperty(this, "programManager", void 0);
      _defineProperty(this, "shadowMatrices", void 0);
      this.setProps(props);
    }
    setProps(props) {
      this.ambientLight = null;
      this.directionalLights = [];
      this.pointLights = [];
      for (const key in props) {
        const lightSource = props[key];
        switch (lightSource.type) {
          case "ambient":
            this.ambientLight = lightSource;
            break;
          case "directional":
            this.directionalLights.push(lightSource);
            break;
          case "point":
            this.pointLights.push(lightSource);
            break;
          default:
        }
      }
      this._applyDefaultLights();
      this.shadow = this.directionalLights.some((light) => light.shadow);
      this.props = props;
    }
    preRender(gl, {
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views
    }) {
      if (!this.shadow)
        return;
      this.shadowMatrices = this._calculateMatrices();
      if (this.shadowPasses.length === 0) {
        this._createShadowPasses(gl);
      }
      if (!this.programManager) {
        this.programManager = ProgramManager.getDefaultProgramManager(gl);
        if (shadow_default) {
          this.programManager.addDefaultModule(shadow_default);
        }
      }
      if (!this.dummyShadowMap) {
        this.dummyShadowMap = new Texture2D(gl, {
          width: 1,
          height: 1
        });
      }
      for (let i2 = 0; i2 < this.shadowPasses.length; i2++) {
        const shadowPass = this.shadowPasses[i2];
        shadowPass.render({
          layers,
          layerFilter,
          viewports,
          onViewportActive,
          views,
          moduleParameters: {
            shadowLightId: i2,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
      }
    }
    getModuleParameters(layer) {
      const parameters = this.shadow ? {
        shadowMaps: this.shadowMaps,
        dummyShadowMap: this.dummyShadowMap,
        shadowColor: this.shadowColor,
        shadowMatrices: this.shadowMatrices
      } : {};
      parameters.lightSources = {
        ambientLight: this.ambientLight,
        directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({
          layer
        })),
        pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({
          layer
        }))
      };
      return parameters;
    }
    cleanup() {
      for (const shadowPass of this.shadowPasses) {
        shadowPass.delete();
      }
      this.shadowPasses.length = 0;
      this.shadowMaps.length = 0;
      if (this.dummyShadowMap) {
        this.dummyShadowMap.delete();
        this.dummyShadowMap = null;
      }
      if (this.shadow && this.programManager) {
        this.programManager.removeDefaultModule(shadow_default);
        this.programManager = null;
      }
    }
    _calculateMatrices() {
      const lightMatrices = [];
      for (const light of this.directionalLights) {
        const viewMatrix = new Matrix4().lookAt({
          eye: new Vector3(light.direction).negate()
        });
        lightMatrices.push(viewMatrix);
      }
      return lightMatrices;
    }
    _createShadowPasses(gl) {
      for (let i2 = 0; i2 < this.directionalLights.length; i2++) {
        const shadowPass = new ShadowPass(gl);
        this.shadowPasses[i2] = shadowPass;
        this.shadowMaps[i2] = shadowPass.shadowMap;
      }
    }
    _applyDefaultLights() {
      const {
        ambientLight,
        pointLights,
        directionalLights
      } = this;
      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
        this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
        this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js
  var TypedArrayManager = class {
    constructor(options = {}) {
      _defineProperty(this, "_pool", []);
      _defineProperty(this, "opts", {
        overAlloc: 2,
        poolSize: 100
      });
      this.setOptions(options);
    }
    setOptions(options) {
      Object.assign(this.opts, options);
    }
    allocate(typedArray, count2, {
      size = 1,
      type,
      padding = 0,
      copy = false,
      initialize = false,
      maxCount
    }) {
      const Type = type || typedArray && typedArray.constructor || Float32Array;
      const newSize = count2 * size + padding;
      if (ArrayBuffer.isView(typedArray)) {
        if (newSize <= typedArray.length) {
          return typedArray;
        }
        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
          return new Type(typedArray.buffer, 0, newSize);
        }
      }
      let maxSize = Infinity;
      if (maxCount) {
        maxSize = maxCount * size + padding;
      }
      const newArray = this._allocate(Type, newSize, initialize, maxSize);
      if (typedArray && copy) {
        newArray.set(typedArray);
      } else if (!initialize) {
        newArray.fill(0, 0, 4);
      }
      this._release(typedArray);
      return newArray;
    }
    release(typedArray) {
      this._release(typedArray);
    }
    _allocate(Type, size, initialize, maxSize) {
      let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);
      if (sizeToAllocate > maxSize) {
        sizeToAllocate = maxSize;
      }
      const pool = this._pool;
      const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
      const i2 = pool.findIndex((b2) => b2.byteLength >= byteLength);
      if (i2 >= 0) {
        const array = new Type(pool.splice(i2, 1)[0], 0, sizeToAllocate);
        if (initialize) {
          array.fill(0);
        }
        return array;
      }
      return new Type(sizeToAllocate);
    }
    _release(typedArray) {
      if (!ArrayBuffer.isView(typedArray)) {
        return;
      }
      const pool = this._pool;
      const {
        buffer
      } = typedArray;
      const {
        byteLength
      } = buffer;
      const i2 = pool.findIndex((b2) => b2.byteLength >= byteLength);
      if (i2 < 0) {
        pool.push(buffer);
      } else if (i2 > 0 || pool.length < this.opts.poolSize) {
        pool.splice(i2, 0, buffer);
      }
      if (pool.length > this.opts.poolSize) {
        pool.shift();
      }
    }
  };
  var typed_array_manager_default = new TypedArrayManager();

  // node_modules/@deck.gl/core/dist/esm/utils/math-utils.js
  function createMat42() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function mod2(value, divisor) {
    const modulus = value % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function getCameraPosition(viewMatrixInverse) {
    return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
  }
  function getFrustumPlanes(viewProjectionMatrix) {
    return {
      left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
      right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
      bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
      top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
      near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
      far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
    };
  }
  var scratchVector = new Vector3();
  function getFrustumPlane(a2, b2, c2, d2) {
    scratchVector.set(a2, b2, c2);
    const L = scratchVector.len();
    return {
      distance: d2 / L,
      normal: new Vector3(-a2 / L, -b2 / L, -c2 / L)
    };
  }
  function fp64LowPart(x2) {
    return x2 - Math.fround(x2);
  }
  var scratchArray;
  function toDoublePrecisionArray(typedArray, options) {
    const {
      size = 1,
      startIndex = 0
    } = options;
    const endIndex = options.endIndex !== void 0 ? options.endIndex : typedArray.length;
    const count2 = (endIndex - startIndex) / size;
    scratchArray = typed_array_manager_default.allocate(scratchArray, count2, {
      type: Float32Array,
      size: size * 2
    });
    let sourceIndex = startIndex;
    let targetIndex = 0;
    while (sourceIndex < endIndex) {
      for (let j = 0; j < size; j++) {
        const value = typedArray[sourceIndex++];
        scratchArray[targetIndex + j] = value;
        scratchArray[targetIndex + j + size] = fp64LowPart(value);
      }
      targetIndex += size * 2;
    }
    return scratchArray.subarray(0, count2 * size * 2);
  }
  function mergeBounds(boundsList) {
    let mergedBounds = null;
    let isMerged = false;
    for (const bounds of boundsList) {
      if (!bounds)
        continue;
      if (!mergedBounds) {
        mergedBounds = bounds;
      } else {
        if (!isMerged) {
          mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
          isMerged = true;
        }
        mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
        mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
        mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
        mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
      }
    }
    return mergedBounds;
  }

  // node_modules/@deck.gl/core/dist/esm/viewports/viewport.js
  var DEGREES_TO_RADIANS4 = Math.PI / 180;
  var IDENTITY2 = createMat42();
  var ZERO_VECTOR2 = [0, 0, 0];
  var DEFAULT_DISTANCE_SCALES = {
    unitsPerMeter: [1, 1, 1],
    metersPerUnit: [1, 1, 1]
  };
  function createProjectionMatrix({
    width,
    height,
    orthographic,
    fovyRadians,
    focalDistance,
    padding,
    near,
    far
  }) {
    const aspect = width / height;
    const matrix = orthographic ? new Matrix4().orthographic({
      fovy: fovyRadians,
      aspect,
      focalDistance,
      near,
      far
    }) : new Matrix4().perspective({
      fovy: fovyRadians,
      aspect,
      near,
      far
    });
    if (padding) {
      const {
        left = 0,
        right = 0,
        top = 0,
        bottom = 0
      } = padding;
      const offsetX = clamp((left + width - right) / 2, 0, width) - width / 2;
      const offsetY = clamp((top + height - bottom) / 2, 0, height) - height / 2;
      matrix[8] -= offsetX * 2 / width;
      matrix[9] += offsetY * 2 / height;
    }
    return matrix;
  }
  var Viewport = class _Viewport {
    constructor(opts = {}) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "x", void 0);
      _defineProperty(this, "y", void 0);
      _defineProperty(this, "width", void 0);
      _defineProperty(this, "height", void 0);
      _defineProperty(this, "padding", void 0);
      _defineProperty(this, "isGeospatial", void 0);
      _defineProperty(this, "zoom", void 0);
      _defineProperty(this, "focalDistance", void 0);
      _defineProperty(this, "position", void 0);
      _defineProperty(this, "modelMatrix", void 0);
      _defineProperty(this, "distanceScales", void 0);
      _defineProperty(this, "scale", void 0);
      _defineProperty(this, "center", void 0);
      _defineProperty(this, "cameraPosition", void 0);
      _defineProperty(this, "projectionMatrix", void 0);
      _defineProperty(this, "viewMatrix", void 0);
      _defineProperty(this, "viewMatrixUncentered", void 0);
      _defineProperty(this, "viewMatrixInverse", void 0);
      _defineProperty(this, "viewProjectionMatrix", void 0);
      _defineProperty(this, "pixelProjectionMatrix", void 0);
      _defineProperty(this, "pixelUnprojectionMatrix", void 0);
      _defineProperty(this, "resolution", void 0);
      _defineProperty(this, "_frustumPlanes", {});
      this.id = opts.id || this.constructor.displayName || "viewport";
      this.x = opts.x || 0;
      this.y = opts.y || 0;
      this.width = opts.width || 1;
      this.height = opts.height || 1;
      this.zoom = opts.zoom || 0;
      this.padding = opts.padding;
      this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
      this.focalDistance = opts.focalDistance || 1;
      this.position = opts.position || ZERO_VECTOR2;
      this.modelMatrix = opts.modelMatrix || null;
      const {
        longitude,
        latitude
      } = opts;
      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
      this._initProps(opts);
      this._initMatrices(opts);
      this.equals = this.equals.bind(this);
      this.project = this.project.bind(this);
      this.unproject = this.unproject.bind(this);
      this.projectPosition = this.projectPosition.bind(this);
      this.unprojectPosition = this.unprojectPosition.bind(this);
      this.projectFlat = this.projectFlat.bind(this);
      this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get subViewports() {
      return null;
    }
    get metersPerPixel() {
      return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
      if (this.isGeospatial) {
        return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
      }
      return PROJECTION_MODE.IDENTITY;
    }
    equals(viewport) {
      if (!(viewport instanceof _Viewport)) {
        return false;
      }
      if (this === viewport) {
        return true;
      }
      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
    }
    project(xyz, {
      topLeft = true
    } = {}) {
      const worldPosition = this.projectPosition(xyz);
      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
      const [x2, y2] = coord;
      const y22 = topLeft ? y2 : this.height - y2;
      return xyz.length === 2 ? [x2, y22] : [x2, y22, coord[2]];
    }
    unproject(xyz, {
      topLeft = true,
      targetZ
    } = {}) {
      const [x2, y2, z] = xyz;
      const y22 = topLeft ? y2 : this.height - y2;
      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
      const coord = pixelsToWorld([x2, y22, z], this.pixelUnprojectionMatrix, targetZWorld);
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
    projectPosition(xyz) {
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [X, Y, Z];
    }
    projectFlat(xyz) {
      if (this.isGeospatial) {
        const result = lngLatToWorld(xyz);
        result[1] = clamp(result[1], -318, 830);
        return result;
      }
      return xyz;
    }
    unprojectFlat(xyz) {
      if (this.isGeospatial) {
        return worldToLngLat(xyz);
      }
      return xyz;
    }
    getBounds(options = {}) {
      const unprojectOption = {
        targetZ: options.z || 0
      };
      const topLeft = this.unproject([0, 0], unprojectOption);
      const topRight = this.unproject([this.width, 0], unprojectOption);
      const bottomLeft = this.unproject([0, this.height], unprojectOption);
      const bottomRight = this.unproject([this.width, this.height], unprojectOption);
      return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
    }
    getDistanceScales(coordinateOrigin) {
      if (coordinateOrigin) {
        return getDistanceScales({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          highPrecision: true
        });
      }
      return this.distanceScales;
    }
    containsPixel({
      x: x2,
      y: y2,
      width = 1,
      height = 1
    }) {
      return x2 < this.x + this.width && this.x < x2 + width && y2 < this.y + this.height && this.y < y2 + height;
    }
    getFrustumPlanes() {
      if (this._frustumPlanes.near) {
        return this._frustumPlanes;
      }
      Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
      return this._frustumPlanes;
    }
    panByPosition(coords, pixel) {
      return null;
    }
    _initProps(opts) {
      const longitude = opts.longitude;
      const latitude = opts.latitude;
      if (this.isGeospatial) {
        if (!Number.isFinite(opts.zoom)) {
          this.zoom = getMeterZoom({
            latitude
          }) + Math.log2(this.focalDistance);
        }
        this.distanceScales = opts.distanceScales || getDistanceScales({
          latitude,
          longitude
        });
      }
      const scale3 = Math.pow(2, this.zoom);
      this.scale = scale3;
      const {
        position,
        modelMatrix
      } = opts;
      let meterOffset = ZERO_VECTOR2;
      if (position) {
        meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position, []) : position;
      }
      if (this.isGeospatial) {
        const center = this.projectPosition([longitude, latitude, 0]);
        this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
      } else {
        this.center = this.projectPosition(meterOffset);
      }
    }
    _initMatrices(opts) {
      const {
        viewMatrix = IDENTITY2,
        projectionMatrix = null,
        orthographic = false,
        fovyRadians,
        fovy = 75,
        near = 0.1,
        far = 1e3,
        padding = null,
        focalDistance = 1
      } = opts;
      this.viewMatrixUncentered = viewMatrix;
      this.viewMatrix = new Matrix4().multiplyRight(viewMatrix).translate(new Vector3(this.center).negate());
      this.projectionMatrix = projectionMatrix || createProjectionMatrix({
        width: this.width,
        height: this.height,
        orthographic,
        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
        focalDistance,
        padding,
        near,
        far
      });
      const vpm = createMat42();
      multiply(vpm, vpm, this.projectionMatrix);
      multiply(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;
      this.viewMatrixInverse = invert([], this.viewMatrix) || this.viewMatrix;
      this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
      const viewportMatrix = createMat42();
      const pixelProjectionMatrix = createMat42();
      scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
      translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
      multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = pixelProjectionMatrix;
      this.pixelUnprojectionMatrix = invert(createMat42(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        log_default.warn("Pixel project matrix not invertible")();
      }
    }
  };
  _defineProperty(Viewport, "displayName", "Viewport");

  // node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js
  var WebMercatorViewport2 = class _WebMercatorViewport extends Viewport {
    constructor(opts = {}) {
      const {
        latitude = 0,
        longitude = 0,
        zoom = 0,
        pitch = 0,
        bearing = 0,
        nearZMultiplier = 0.1,
        farZMultiplier = 1.01,
        nearZ,
        farZ,
        orthographic = false,
        projectionMatrix,
        repeat = false,
        worldOffset = 0,
        position,
        padding,
        legacyMeterSizes = false
      } = opts;
      let {
        width,
        height,
        altitude = 1.5
      } = opts;
      const scale3 = Math.pow(2, zoom);
      width = width || 1;
      height = height || 1;
      let fovy;
      let projectionParameters = null;
      if (projectionMatrix) {
        altitude = projectionMatrix[5] / 2;
        fovy = altitudeToFovy(altitude);
      } else {
        if (opts.fovy) {
          fovy = opts.fovy;
          altitude = fovyToAltitude(fovy);
        } else {
          fovy = altitudeToFovy(altitude);
        }
        let offset;
        if (padding) {
          const {
            top = 0,
            bottom = 0
          } = padding;
          offset = [0, clamp((top + height - bottom) / 2, 0, height) - height / 2];
        }
        projectionParameters = getProjectionParameters({
          width,
          height,
          scale: scale3,
          center: position && [0, 0, position[2] * unitsPerMeter(latitude)],
          offset,
          pitch,
          fovy,
          nearZMultiplier,
          farZMultiplier
        });
        if (Number.isFinite(nearZ)) {
          projectionParameters.near = nearZ;
        }
        if (Number.isFinite(farZ)) {
          projectionParameters.far = farZ;
        }
      }
      let viewMatrixUncentered = getViewMatrix({
        height,
        pitch,
        bearing,
        scale: scale3,
        altitude
      });
      if (worldOffset) {
        const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
        viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
      }
      super({
        ...opts,
        width,
        height,
        viewMatrix: viewMatrixUncentered,
        longitude,
        latitude,
        zoom,
        ...projectionParameters,
        fovy,
        focalDistance: altitude
      });
      _defineProperty(this, "longitude", void 0);
      _defineProperty(this, "latitude", void 0);
      _defineProperty(this, "pitch", void 0);
      _defineProperty(this, "bearing", void 0);
      _defineProperty(this, "altitude", void 0);
      _defineProperty(this, "fovy", void 0);
      _defineProperty(this, "orthographic", void 0);
      _defineProperty(this, "_subViewports", void 0);
      _defineProperty(this, "_pseudoMeters", void 0);
      this.latitude = latitude;
      this.longitude = longitude;
      this.zoom = zoom;
      this.pitch = pitch;
      this.bearing = bearing;
      this.altitude = altitude;
      this.fovy = fovy;
      this.orthographic = orthographic;
      this._subViewports = repeat ? [] : null;
      this._pseudoMeters = legacyMeterSizes;
      Object.freeze(this);
    }
    get subViewports() {
      if (this._subViewports && !this._subViewports.length) {
        const bounds = this.getBounds();
        const minOffset = Math.floor((bounds[0] + 180) / 360);
        const maxOffset = Math.ceil((bounds[2] - 180) / 360);
        for (let x2 = minOffset; x2 <= maxOffset; x2++) {
          const offsetViewport = x2 ? new _WebMercatorViewport({
            ...this,
            worldOffset: x2
          }) : this;
          this._subViewports.push(offsetViewport);
        }
      }
      return this._subViewports;
    }
    projectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.projectPosition(xyz);
      }
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.unprojectPosition(xyz);
      }
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) / unitsPerMeter(Y);
      return [X, Y, Z];
    }
    addMetersToLngLat(lngLatZ, xyz) {
      return addMetersToLngLat(lngLatZ, xyz);
    }
    panByPosition(coords, pixel) {
      const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
      const toLocation = this.projectFlat(coords);
      const translate2 = add([], toLocation, negate([], fromLocation));
      const newCenter = add([], this.center, translate2);
      const [longitude, latitude] = this.unprojectFlat(newCenter);
      return {
        longitude,
        latitude
      };
    }
    getBounds(options = {}) {
      const corners = getBounds(this, options.z || 0);
      return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
    }
    fitBounds(bounds, options = {}) {
      const {
        width,
        height
      } = this;
      const {
        longitude,
        latitude,
        zoom
      } = fitBounds({
        width,
        height,
        bounds,
        ...options
      });
      return new _WebMercatorViewport({
        width,
        height,
        longitude,
        latitude,
        zoom
      });
    }
  };
  _defineProperty(WebMercatorViewport2, "displayName", "WebMercatorViewport");

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js
  var DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
  function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
    const p2 = viewport.projectPosition(lngLatZ);
    if (offsetMode && viewport instanceof WebMercatorViewport2) {
      const [longitude, latitude, z = 0] = lngLatZ;
      const distanceScales = viewport.getDistanceScales([longitude, latitude]);
      p2[2] = z * distanceScales.unitsPerMeter[2];
    }
    return p2;
  }
  function normalizeParameters(opts) {
    const {
      viewport,
      modelMatrix,
      coordinateOrigin
    } = opts;
    let {
      coordinateSystem,
      fromCoordinateSystem,
      fromCoordinateOrigin
    } = opts;
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    if (fromCoordinateSystem === void 0) {
      fromCoordinateSystem = coordinateSystem;
    }
    if (fromCoordinateOrigin === void 0) {
      fromCoordinateOrigin = coordinateOrigin;
    }
    return {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix,
      fromCoordinateSystem,
      fromCoordinateOrigin
    };
  }
  function getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem,
    coordinateOrigin,
    offsetMode
  }) {
    let [x2, y2, z = 0] = position;
    if (modelMatrix) {
      [x2, y2, z] = transformMat43([], [x2, y2, z, 1], modelMatrix);
    }
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.LNGLAT:
        return lngLatZToWorldPosition([x2, y2, z], viewport, offsetMode);
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        return lngLatZToWorldPosition([x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
      case COORDINATE_SYSTEM.METER_OFFSETS:
        return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x2, y2, z]), viewport, offsetMode);
      case COORDINATE_SYSTEM.CARTESIAN:
      default:
        return viewport.isGeospatial ? [x2 + coordinateOrigin[0], y2 + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x2, y2, z]);
    }
  }
  function projectPosition(position, params) {
    const {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix,
      fromCoordinateSystem,
      fromCoordinateOrigin
    } = normalizeParameters(params);
    const {
      autoOffset = true
    } = params;
    const {
      geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2,
      shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2,
      offsetMode = false
    } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
    const worldPosition = getWorldPosition(position, {
      viewport,
      modelMatrix,
      coordinateSystem: fromCoordinateSystem,
      coordinateOrigin: fromCoordinateOrigin,
      offsetMode
    });
    if (offsetMode) {
      const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      sub(worldPosition, worldPosition, positionCommonSpace);
    }
    return worldPosition;
  }

  // node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js
  var PICKING_PARAMETERS = {
    blendFunc: [1, 0, 32771, 0],
    blendEquation: 32774
  };
  var PickLayersPass = class extends LayersPass {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "pickZ", void 0);
      _defineProperty(this, "_colorEncoderState", null);
    }
    render(props) {
      if ("pickingFBO" in props) {
        return this._drawPickingBuffer(props);
      }
      return super.render(props);
    }
    _drawPickingBuffer({
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect: {
        x: x2,
        y: y2,
        width,
        height
      },
      cullRect,
      effects,
      pass = "picking",
      pickZ,
      moduleParameters
    }) {
      const gl = this.gl;
      this.pickZ = pickZ;
      const colorEncoderState = this._resetColorEncoder(pickZ);
      const renderStatus = withParameters(gl, {
        scissorTest: true,
        scissor: [x2, y2, width, height],
        clearColor: [0, 0, 0, 0],
        depthMask: true,
        depthTest: true,
        depthRange: [0, 1],
        colorMask: [true, true, true, true],
        ...PICKING_PARAMETERS,
        blend: !pickZ
      }, () => super.render({
        target: pickingFBO,
        layers,
        layerFilter,
        views,
        viewports,
        onViewportActive,
        cullRect,
        effects: effects === null || effects === void 0 ? void 0 : effects.filter((e2) => e2.useInPicking),
        pass,
        isPicking: true,
        moduleParameters
      }));
      this._colorEncoderState = null;
      const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
      return {
        decodePickingColor,
        stats: renderStatus
      };
    }
    shouldDrawLayer(layer) {
      const {
        pickable,
        operation
      } = layer.props;
      return pickable && operation.includes("draw") || operation.includes("terrain") || operation.includes("mask");
    }
    getModuleParameters() {
      return {
        pickingActive: 1,
        pickingAttribute: this.pickZ,
        lightSources: {}
      };
    }
    getLayerParameters(layer, layerIndex, viewport) {
      const pickParameters = {
        ...layer.props.parameters
      };
      const {
        pickable,
        operation
      } = layer.props;
      if (!this._colorEncoderState) {
        pickParameters.blend = false;
      } else if (pickable && operation.includes("draw")) {
        Object.assign(pickParameters, PICKING_PARAMETERS);
        pickParameters.blend = true;
        pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
      }
      if (operation.includes("terrain")) {
        pickParameters.blend = false;
      }
      return pickParameters;
    }
    _resetColorEncoder(pickZ) {
      this._colorEncoderState = pickZ ? null : {
        byLayer: /* @__PURE__ */ new Map(),
        byAlpha: []
      };
      return this._colorEncoderState;
    }
  };
  function encodeColor(encoded, layer, viewport) {
    const {
      byLayer,
      byAlpha
    } = encoded;
    let a2;
    let entry = byLayer.get(layer);
    if (entry) {
      entry.viewports.push(viewport);
      a2 = entry.a;
    } else {
      a2 = byLayer.size + 1;
      if (a2 <= 255) {
        entry = {
          a: a2,
          layer,
          viewports: [viewport]
        };
        byLayer.set(layer, entry);
        byAlpha[a2] = entry;
      } else {
        log_default.warn("Too many pickable layers, only picking the first 255")();
        a2 = 0;
      }
    }
    return [0, 0, 0, a2 / 255];
  }
  function decodeColor(encoded, pickedColor) {
    const entry = encoded.byAlpha[pickedColor[3]];
    return entry && {
      pickedLayer: entry.layer,
      pickedViewports: entry.viewports,
      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
    };
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js
  var LIFECYCLE = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
  };
  var COMPONENT_SYMBOL = Symbol.for("component");
  var PROP_TYPES_SYMBOL = Symbol.for("propTypes");
  var DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
  var ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
  var ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
  var ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

  // node_modules/@deck.gl/core/dist/esm/utils/flatten.js
  function flatten(array, filter = () => true) {
    if (!Array.isArray(array)) {
      return filter(array) ? [array] : [];
    }
    return flattenArray(array, filter, []);
  }
  function flattenArray(array, filter, result) {
    let index = -1;
    while (++index < array.length) {
      const value = array[index];
      if (Array.isArray(value)) {
        flattenArray(value, filter, result);
      } else if (filter(value)) {
        result.push(value);
      }
    }
    return result;
  }
  function fillArray2({
    target,
    source,
    start = 0,
    count: count2 = 1
  }) {
    const length = source.length;
    const total = count2 * length;
    let copied = 0;
    for (let i2 = start; copied < length; copied++) {
      target[i2++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return target;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js
  var Resource2 = class {
    constructor(id, data, context) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "context", void 0);
      _defineProperty(this, "isLoaded", void 0);
      _defineProperty(this, "persistent", void 0);
      _defineProperty(this, "_loadCount", 0);
      _defineProperty(this, "_subscribers", /* @__PURE__ */ new Set());
      _defineProperty(this, "_data", void 0);
      _defineProperty(this, "_loader", void 0);
      _defineProperty(this, "_error", void 0);
      _defineProperty(this, "_content", void 0);
      this.id = id;
      this.context = context;
      this.setData(data);
    }
    subscribe(consumer) {
      this._subscribers.add(consumer);
    }
    unsubscribe(consumer) {
      this._subscribers.delete(consumer);
    }
    inUse() {
      return this._subscribers.size > 0;
    }
    delete() {
    }
    getData() {
      return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
    }
    setData(data, forceUpdate) {
      if (data === this._data && !forceUpdate) {
        return;
      }
      this._data = data;
      const loadCount = ++this._loadCount;
      let loader = data;
      if (typeof data === "string") {
        loader = load(data);
      }
      if (loader instanceof Promise) {
        this.isLoaded = false;
        this._loader = loader.then((result) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = void 0;
            this._content = result;
          }
        }).catch((error2) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = error2 || true;
          }
        });
      } else {
        this.isLoaded = true;
        this._error = void 0;
        this._content = data;
      }
      for (const subscriber of this._subscribers) {
        subscriber.onChange(this.getData());
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js
  var ResourceManager = class {
    constructor({
      gl,
      protocol
    }) {
      _defineProperty(this, "protocol", void 0);
      _defineProperty(this, "_context", void 0);
      _defineProperty(this, "_resources", void 0);
      _defineProperty(this, "_consumers", void 0);
      _defineProperty(this, "_pruneRequest", void 0);
      this.protocol = protocol || "resource://";
      this._context = {
        gl,
        resourceManager: this
      };
      this._resources = {};
      this._consumers = {};
      this._pruneRequest = null;
    }
    contains(resourceId) {
      if (resourceId.startsWith(this.protocol)) {
        return true;
      }
      return resourceId in this._resources;
    }
    add({
      resourceId,
      data,
      forceUpdate = false,
      persistent = true
    }) {
      let res = this._resources[resourceId];
      if (res) {
        res.setData(data, forceUpdate);
      } else {
        res = new Resource2(resourceId, data, this._context);
        this._resources[resourceId] = res;
      }
      res.persistent = persistent;
    }
    remove(resourceId) {
      const res = this._resources[resourceId];
      if (res) {
        res.delete();
        delete this._resources[resourceId];
      }
    }
    unsubscribe({
      consumerId
    }) {
      const consumer = this._consumers[consumerId];
      if (consumer) {
        for (const requestId in consumer) {
          const request = consumer[requestId];
          const resource = this._resources[request.resourceId];
          if (resource) {
            resource.unsubscribe(request);
          }
        }
        delete this._consumers[consumerId];
        this.prune();
      }
    }
    subscribe({
      resourceId,
      onChange,
      consumerId,
      requestId = "default"
    }) {
      const {
        _resources: resources,
        protocol
      } = this;
      if (resourceId.startsWith(protocol)) {
        resourceId = resourceId.replace(protocol, "");
        if (!resources[resourceId]) {
          this.add({
            resourceId,
            data: null,
            persistent: false
          });
        }
      }
      const res = resources[resourceId];
      this._track(consumerId, requestId, res, onChange);
      if (res) {
        return res.getData();
      }
      return void 0;
    }
    prune() {
      if (!this._pruneRequest) {
        this._pruneRequest = setTimeout(() => this._prune(), 0);
      }
    }
    finalize() {
      for (const key in this._resources) {
        this._resources[key].delete();
      }
    }
    _track(consumerId, requestId, resource, onChange) {
      const consumers = this._consumers;
      const consumer = consumers[consumerId] = consumers[consumerId] || {};
      const request = consumer[requestId] || {};
      const oldResource = request.resourceId && this._resources[request.resourceId];
      if (oldResource) {
        oldResource.unsubscribe(request);
        this.prune();
      }
      if (resource) {
        consumer[requestId] = request;
        request.onChange = onChange;
        request.resourceId = resource.id;
        resource.subscribe(request);
      }
    }
    _prune() {
      this._pruneRequest = null;
      for (const key of Object.keys(this._resources)) {
        const res = this._resources[key];
        if (!res.persistent && !res.inUse()) {
          res.delete();
          delete this._resources[key];
        }
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js
  var vs5 = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
  var project32_default = {
    name: "project32",
    dependencies: [project_default],
    vs: vs5
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js
  var picking_default = {
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
      "fs:#decl": "\nuniform bool picking_uAttribute;\n  ",
      "fs:DECKGL_FILTER_COLOR": {
        order: 99,
        injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
      }
    },
    ...picking
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/index.js
  var DEFAULT_MODULES = [project_default];
  var SHADER_HOOKS = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
  function createProgramManager(gl) {
    const programManager = ProgramManager.getDefaultProgramManager(gl);
    for (const shaderModule of DEFAULT_MODULES) {
      programManager.addDefaultModule(shaderModule);
    }
    for (const shaderHook of SHADER_HOOKS) {
      programManager.addShaderHook(shaderHook);
    }
    return programManager;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js
  var TRACE_SET_LAYERS = "layerManager.setLayers";
  var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
  var LayerManager = class {
    constructor(gl, {
      deck,
      stats,
      viewport: _viewport,
      timeline
    } = {}) {
      _defineProperty(this, "layers", void 0);
      _defineProperty(this, "context", void 0);
      _defineProperty(this, "resourceManager", void 0);
      _defineProperty(this, "_lastRenderedLayers", []);
      _defineProperty(this, "_needsRedraw", false);
      _defineProperty(this, "_needsUpdate", false);
      _defineProperty(this, "_nextLayers", null);
      _defineProperty(this, "_debug", false);
      _defineProperty(this, "activateViewport", (viewport) => {
        debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);
        if (viewport) {
          this.context.viewport = viewport;
        }
      });
      this.layers = [];
      this.resourceManager = new ResourceManager({
        gl,
        protocol: "deck://"
      });
      this.context = {
        mousePosition: null,
        userData: {},
        layerManager: this,
        gl,
        deck,
        programManager: gl && createProgramManager(gl),
        stats: stats || new Stats({
          id: "deck.gl"
        }),
        viewport: _viewport || new Viewport({
          id: "DEFAULT-INITIAL-VIEWPORT"
        }),
        timeline: timeline || new Timeline(),
        resourceManager: this.resourceManager,
        onError: void 0
      };
      Object.seal(this);
    }
    finalize() {
      this.resourceManager.finalize();
      for (const layer of this.layers) {
        this._finalizeLayer(layer);
      }
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      for (const layer of this.layers) {
        const layerNeedsRedraw = layer.getNeedsRedraw(opts);
        redraw = redraw || layerNeedsRedraw;
      }
      return redraw;
    }
    needsUpdate() {
      if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
        return "layers changed";
      }
      return this._needsUpdate;
    }
    setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
    }
    getLayers({
      layerIds
    } = {}) {
      return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
    }
    setProps(props) {
      if ("debug" in props) {
        this._debug = props.debug;
      }
      if ("userData" in props) {
        this.context.userData = props.userData;
      }
      if ("layers" in props) {
        this._nextLayers = props.layers;
      }
      if ("onError" in props) {
        this.context.onError = props.onError;
      }
    }
    setLayers(newLayers, reason) {
      debug(TRACE_SET_LAYERS, this, reason, newLayers);
      this._lastRenderedLayers = newLayers;
      const flatLayers = flatten(newLayers, Boolean);
      for (const layer of flatLayers) {
        layer.context = this.context;
      }
      this._updateLayers(this.layers, flatLayers);
    }
    updateLayers() {
      const reason = this.needsUpdate();
      if (reason) {
        this.setNeedsRedraw("updating layers: ".concat(reason));
        this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
      }
      this._nextLayers = null;
    }
    _handleError(stage, error2, layer) {
      layer.raiseError(error2, "".concat(stage, " of ").concat(layer));
    }
    _updateLayers(oldLayers, newLayers) {
      const oldLayerMap = {};
      for (const oldLayer of oldLayers) {
        if (oldLayerMap[oldLayer.id]) {
          log_default.warn("Multiple old layers with same id ".concat(oldLayer.id))();
        } else {
          oldLayerMap[oldLayer.id] = oldLayer;
        }
      }
      const generatedLayers = [];
      this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
      this._finalizeOldLayers(oldLayerMap);
      let needsUpdate = false;
      for (const layer of generatedLayers) {
        if (layer.hasUniformTransition()) {
          needsUpdate = "Uniform transition in ".concat(layer);
          break;
        }
      }
      this._needsUpdate = needsUpdate;
      this.layers = generatedLayers;
    }
    _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
      for (const newLayer of newLayers) {
        newLayer.context = this.context;
        const oldLayer = oldLayerMap[newLayer.id];
        if (oldLayer === null) {
          log_default.warn("Multiple new layers with same id ".concat(newLayer.id))();
        }
        oldLayerMap[newLayer.id] = null;
        let sublayers = null;
        try {
          if (this._debug && oldLayer !== newLayer) {
            newLayer.validateProps();
          }
          if (!oldLayer) {
            this._initializeLayer(newLayer);
          } else {
            this._transferLayerState(oldLayer, newLayer);
            this._updateLayer(newLayer);
          }
          generatedLayers.push(newLayer);
          sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
        } catch (err) {
          this._handleError("matching", err, newLayer);
        }
        if (sublayers) {
          this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
        }
      }
    }
    _finalizeOldLayers(oldLayerMap) {
      for (const layerId in oldLayerMap) {
        const layer = oldLayerMap[layerId];
        if (layer) {
          this._finalizeLayer(layer);
        }
      }
    }
    _initializeLayer(layer) {
      try {
        layer._initialize();
        layer.lifecycle = LIFECYCLE.INITIALIZED;
      } catch (err) {
        this._handleError("initialization", err, layer);
      }
    }
    _transferLayerState(oldLayer, newLayer) {
      newLayer._transferState(oldLayer);
      newLayer.lifecycle = LIFECYCLE.MATCHED;
      if (newLayer !== oldLayer) {
        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
      }
    }
    _updateLayer(layer) {
      try {
        layer._update();
      } catch (err) {
        this._handleError("update", err, layer);
      }
    }
    _finalizeLayer(layer) {
      this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
      try {
        layer._finalize();
        layer.lifecycle = LIFECYCLE.FINALIZED;
      } catch (err) {
        this._handleError("finalization", err, layer);
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js
  function deepEqual(a2, b2, depth) {
    if (a2 === b2) {
      return true;
    }
    if (!depth || !a2 || !b2) {
      return false;
    }
    if (Array.isArray(a2)) {
      if (!Array.isArray(b2) || a2.length !== b2.length) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (!deepEqual(a2[i2], b2[i2], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b2)) {
      return false;
    }
    if (typeof a2 === "object" && typeof b2 === "object") {
      const aKeys = Object.keys(a2);
      const bKeys = Object.keys(b2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b2.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual(a2[key], b2[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/view-manager.js
  var ViewManager = class {
    constructor(props) {
      _defineProperty(this, "width", void 0);
      _defineProperty(this, "height", void 0);
      _defineProperty(this, "views", void 0);
      _defineProperty(this, "viewState", void 0);
      _defineProperty(this, "controllers", void 0);
      _defineProperty(this, "timeline", void 0);
      _defineProperty(this, "_viewports", void 0);
      _defineProperty(this, "_viewportMap", void 0);
      _defineProperty(this, "_isUpdating", void 0);
      _defineProperty(this, "_needsRedraw", void 0);
      _defineProperty(this, "_needsUpdate", void 0);
      _defineProperty(this, "_eventManager", void 0);
      _defineProperty(this, "_eventCallbacks", void 0);
      this.views = [];
      this.width = 100;
      this.height = 100;
      this.viewState = {};
      this.controllers = {};
      this.timeline = props.timeline;
      this._viewports = [];
      this._viewportMap = {};
      this._isUpdating = false;
      this._needsRedraw = "First render";
      this._needsUpdate = "Initialize";
      this._eventManager = props.eventManager;
      this._eventCallbacks = {
        onViewStateChange: props.onViewStateChange,
        onInteractionStateChange: props.onInteractionStateChange
      };
      Object.seal(this);
      this.setProps(props);
    }
    finalize() {
      for (const key in this.controllers) {
        const controller = this.controllers[key];
        if (controller) {
          controller.finalize();
        }
      }
      this.controllers = {};
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
      this._needsRedraw = this._needsRedraw || reason;
    }
    updateViewStates() {
      for (const viewId in this.controllers) {
        const controller = this.controllers[viewId];
        if (controller) {
          controller.updateTransition();
        }
      }
    }
    getViewports(rect) {
      if (rect) {
        return this._viewports.filter((viewport) => viewport.containsPixel(rect));
      }
      return this._viewports;
    }
    getViews() {
      const viewMap = {};
      this.views.forEach((view) => {
        viewMap[view.id] = view;
      });
      return viewMap;
    }
    getView(viewId) {
      return this.views.find((view) => view.id === viewId);
    }
    getViewState(viewOrViewId) {
      const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
      const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
      return view ? view.filterViewState(viewState) : viewState;
    }
    getViewport(viewId) {
      return this._viewportMap[viewId];
    }
    unproject(xyz, opts) {
      const viewports = this.getViewports();
      const pixel = {
        x: xyz[0],
        y: xyz[1]
      };
      for (let i2 = viewports.length - 1; i2 >= 0; --i2) {
        const viewport = viewports[i2];
        if (viewport.containsPixel(pixel)) {
          const p2 = xyz.slice();
          p2[0] -= viewport.x;
          p2[1] -= viewport.y;
          return viewport.unproject(p2, opts);
        }
      }
      return null;
    }
    setProps(props) {
      if (props.views) {
        this._setViews(props.views);
      }
      if (props.viewState) {
        this._setViewState(props.viewState);
      }
      if ("width" in props || "height" in props) {
        this._setSize(props.width, props.height);
      }
      if (!this._isUpdating) {
        this._update();
      }
    }
    _update() {
      this._isUpdating = true;
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      this._isUpdating = false;
    }
    _setSize(width, height) {
      if (width !== this.width || height !== this.height) {
        this.width = width;
        this.height = height;
        this.setNeedsUpdate("Size changed");
      }
    }
    _setViews(views) {
      views = flatten(views, Boolean);
      const viewsChanged = this._diffViews(views, this.views);
      if (viewsChanged) {
        this.setNeedsUpdate("views changed");
      }
      this.views = views;
    }
    _setViewState(viewState) {
      if (viewState) {
        const viewStateChanged = !deepEqual(viewState, this.viewState, 3);
        if (viewStateChanged) {
          this.setNeedsUpdate("viewState changed");
        }
        this.viewState = viewState;
      } else {
        log_default.warn("missing `viewState` or `initialViewState`")();
      }
    }
    _onViewStateChange(viewId, event) {
      if (this._eventCallbacks.onViewStateChange) {
        this._eventCallbacks.onViewStateChange({
          ...event,
          viewId
        });
      }
    }
    _createController(view, props) {
      const Controller2 = props.type;
      const controller = new Controller2({
        timeline: this.timeline,
        eventManager: this._eventManager,
        onViewStateChange: this._onViewStateChange.bind(this, props.id),
        onStateChange: this._eventCallbacks.onInteractionStateChange,
        makeViewport: (viewState) => {
          var _this$getView;
          return (_this$getView = this.getView(view.id)) === null || _this$getView === void 0 ? void 0 : _this$getView.makeViewport({
            viewState,
            width: this.width,
            height: this.height
          });
        }
      });
      return controller;
    }
    _updateController(view, viewState, viewport, controller) {
      const controllerProps = view.controller;
      if (controllerProps && viewport) {
        const resolvedProps = {
          ...viewState,
          ...controllerProps,
          id: view.id,
          x: viewport.x,
          y: viewport.y,
          width: viewport.width,
          height: viewport.height
        };
        if (!controller || controller.constructor !== controllerProps.type) {
          controller = this._createController(view, resolvedProps);
        }
        if (controller) {
          controller.setProps(resolvedProps);
        }
        return controller;
      }
      return null;
    }
    _rebuildViewports() {
      const {
        views
      } = this;
      const oldControllers = this.controllers;
      this._viewports = [];
      this.controllers = {};
      let invalidateControllers = false;
      for (let i2 = views.length; i2--; ) {
        const view = views[i2];
        const viewState = this.getViewState(view);
        const viewport = view.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        });
        let oldController = oldControllers[view.id];
        const hasController = Boolean(view.controller);
        if (hasController && !oldController) {
          invalidateControllers = true;
        }
        if ((invalidateControllers || !hasController) && oldController) {
          oldController.finalize();
          oldController = null;
        }
        this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
        if (viewport) {
          this._viewports.unshift(viewport);
        }
      }
      for (const id in oldControllers) {
        const oldController = oldControllers[id];
        if (oldController && !this.controllers[id]) {
          oldController.finalize();
        }
      }
      this._buildViewportMap();
    }
    _buildViewportMap() {
      this._viewportMap = {};
      this._viewports.forEach((viewport) => {
        if (viewport.id) {
          this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
        }
      });
    }
    _diffViews(newViews, oldViews) {
      if (newViews.length !== oldViews.length) {
        return true;
      }
      return newViews.some((_2, i2) => !newViews[i2].equals(oldViews[i2]));
    }
  };

  // node_modules/@deck.gl/core/dist/esm/utils/positions.js
  var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
  function parsePosition(value) {
    switch (typeof value) {
      case "number":
        return {
          position: value,
          relative: false
        };
      case "string":
        const match = PERCENT_OR_PIXELS_REGEX.exec(value);
        if (match && match.length >= 3) {
          const relative = match[2] === "%";
          const position = parseFloat(match[1]);
          return {
            position: relative ? position / 100 : position,
            relative
          };
        }
      default:
        throw new Error("Could not parse position string ".concat(value));
    }
  }
  function getPosition(position, extent) {
    return position.relative ? Math.round(position.position * extent) : position.position;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/assert.js
  function assert10(condition, message) {
    if (!condition) {
      throw new Error(message || "deck.gl: assertion failed.");
    }
  }

  // node_modules/@deck.gl/core/dist/esm/views/view.js
  var View = class {
    constructor(props) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "viewportInstance", void 0);
      _defineProperty(this, "_x", void 0);
      _defineProperty(this, "_y", void 0);
      _defineProperty(this, "_width", void 0);
      _defineProperty(this, "_height", void 0);
      _defineProperty(this, "_padding", void 0);
      _defineProperty(this, "props", void 0);
      const {
        id,
        x: x2 = 0,
        y: y2 = 0,
        width = "100%",
        height = "100%",
        padding = null,
        viewportInstance
      } = props || {};
      assert10(!viewportInstance || viewportInstance instanceof Viewport);
      this.viewportInstance = viewportInstance;
      this.id = id || this.constructor.displayName || "view";
      this.props = {
        ...props,
        id: this.id
      };
      this._x = parsePosition(x2);
      this._y = parsePosition(y2);
      this._width = parsePosition(width);
      this._height = parsePosition(height);
      this._padding = padding && {
        left: parsePosition(padding.left || 0),
        right: parsePosition(padding.right || 0),
        top: parsePosition(padding.top || 0),
        bottom: parsePosition(padding.bottom || 0)
      };
      this.equals = this.equals.bind(this);
      Object.seal(this);
    }
    equals(view) {
      if (this === view) {
        return true;
      }
      if (this.viewportInstance) {
        return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
      }
      return this.ViewportType === view.ViewportType && deepEqual(this.props, view.props, 2);
    }
    makeViewport({
      width,
      height,
      viewState
    }) {
      if (this.viewportInstance) {
        return this.viewportInstance;
      }
      viewState = this.filterViewState(viewState);
      const viewportDimensions = this.getDimensions({
        width,
        height
      });
      if (!viewportDimensions.height || !viewportDimensions.width) {
        return null;
      }
      return new this.ViewportType({
        ...viewState,
        ...this.props,
        ...viewportDimensions
      });
    }
    getViewStateId() {
      const {
        viewState
      } = this.props;
      if (typeof viewState === "string") {
        return viewState;
      }
      return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
    }
    filterViewState(viewState) {
      if (this.props.viewState && typeof this.props.viewState === "object") {
        if (!this.props.viewState.id) {
          return this.props.viewState;
        }
        const newViewState = {
          ...viewState
        };
        for (const key in this.props.viewState) {
          if (key !== "id") {
            newViewState[key] = this.props.viewState[key];
          }
        }
        return newViewState;
      }
      return viewState;
    }
    getDimensions({
      width,
      height
    }) {
      const dimensions = {
        x: getPosition(this._x, width),
        y: getPosition(this._y, height),
        width: getPosition(this._width, width),
        height: getPosition(this._height, height)
      };
      if (this._padding) {
        dimensions.padding = {
          left: getPosition(this._padding.left, width),
          top: getPosition(this._padding.top, height),
          right: getPosition(this._padding.right, width),
          bottom: getPosition(this._padding.bottom, height)
        };
      }
      return dimensions;
    }
    get controller() {
      const opts = this.props.controller;
      if (!opts) {
        return null;
      }
      if (opts === true) {
        return {
          type: this.ControllerType
        };
      }
      if (typeof opts === "function") {
        return {
          type: opts
        };
      }
      return {
        type: this.ControllerType,
        ...opts
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/transition.js
  var Transition = class {
    constructor(timeline) {
      _defineProperty(this, "_inProgress", void 0);
      _defineProperty(this, "_handle", void 0);
      _defineProperty(this, "_timeline", void 0);
      _defineProperty(this, "time", void 0);
      _defineProperty(this, "settings", void 0);
      this._inProgress = false;
      this._handle = null;
      this._timeline = timeline;
      this.time = 0;
      this.settings = {
        duration: 0
      };
    }
    get inProgress() {
      return this._inProgress;
    }
    start(settings) {
      var _this$settings$onStar, _this$settings;
      this.cancel();
      this.settings = settings;
      this._inProgress = true;
      (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 ? void 0 : _this$settings$onStar.call(_this$settings, this);
    }
    end() {
      if (this._inProgress) {
        var _this$settings$onEnd, _this$settings2;
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
        (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 ? void 0 : _this$settings$onEnd.call(_this$settings2, this);
      }
    }
    cancel() {
      if (this._inProgress) {
        var _this$settings$onInte, _this$settings3;
        (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 ? void 0 : _this$settings$onInte.call(_this$settings3, this);
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
      }
    }
    update() {
      var _this$settings$onUpda, _this$settings4;
      if (!this._inProgress) {
        return false;
      }
      if (this._handle === null) {
        const {
          _timeline: timeline,
          settings
        } = this;
        this._handle = timeline.addChannel({
          delay: timeline.getTime(),
          duration: settings.duration
        });
      }
      this.time = this._timeline.getTime(this._handle);
      this._onUpdate();
      (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 ? void 0 : _this$settings$onUpda.call(_this$settings4, this);
      if (this._timeline.isFinished(this._handle)) {
        this.end();
      }
      return true;
    }
    _onUpdate() {
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js
  var noop3 = () => {
  };
  var TRANSITION_EVENTS = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
  };
  var DEFAULT_EASING = (t2) => t2;
  var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
  var TransitionManager = class {
    constructor(opts) {
      _defineProperty(this, "getControllerState", void 0);
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "propsInTransition", void 0);
      _defineProperty(this, "transition", void 0);
      _defineProperty(this, "onViewStateChange", void 0);
      _defineProperty(this, "onStateChange", void 0);
      _defineProperty(this, "_onTransitionUpdate", (transition) => {
        const {
          time,
          settings: {
            interpolator,
            startProps,
            endProps,
            duration,
            easing
          }
        } = transition;
        const t2 = easing(time / duration);
        const viewport = interpolator.interpolateProps(startProps, endProps, t2);
        this.propsInTransition = this.getControllerState({
          ...this.props,
          ...viewport
        }).getViewportProps();
        this.onViewStateChange({
          viewState: this.propsInTransition,
          oldViewState: this.props
        });
      });
      this.getControllerState = opts.getControllerState;
      this.propsInTransition = null;
      this.transition = new Transition(opts.timeline);
      this.onViewStateChange = opts.onViewStateChange || noop3;
      this.onStateChange = opts.onStateChange || noop3;
    }
    finalize() {
      this.transition.cancel();
    }
    getViewportInTransition() {
      return this.propsInTransition;
    }
    processViewStateChange(nextProps) {
      let transitionTriggered = false;
      const currentProps = this.props;
      this.props = nextProps;
      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return false;
      }
      if (this._isTransitionEnabled(nextProps)) {
        let startProps = currentProps;
        if (this.transition.inProgress) {
          const {
            interruption,
            endProps
          } = this.transition.settings;
          startProps = {
            ...currentProps,
            ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
          };
        }
        this._triggerTransition(startProps, nextProps);
        transitionTriggered = true;
      } else {
        this.transition.cancel();
      }
      return transitionTriggered;
    }
    updateTransition() {
      this.transition.update();
    }
    _isTransitionEnabled(props) {
      const {
        transitionDuration,
        transitionInterpolator
      } = props;
      return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
    }
    _isUpdateDueToCurrentTransition(props) {
      if (this.transition.inProgress && this.propsInTransition) {
        return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
      }
      return false;
    }
    _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (this.transition.inProgress) {
        return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
      }
      if (this._isTransitionEnabled(nextProps)) {
        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
      }
      return true;
    }
    _triggerTransition(startProps, endProps) {
      const startViewstate = this.getControllerState(startProps);
      const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
      const transitionInterpolator = endProps.transitionInterpolator;
      const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
      if (duration === 0) {
        return;
      }
      const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
      this.propsInTransition = {};
      const transitionSettings = {
        duration,
        easing: endProps.transitionEasing || DEFAULT_EASING,
        interpolator: transitionInterpolator,
        interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
        startProps: initialProps.start,
        endProps: initialProps.end,
        onStart: endProps.onTransitionStart,
        onUpdate: this._onTransitionUpdate,
        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
      };
      this.transition.start(transitionSettings);
      this.onStateChange({
        inTransition: true
      });
      this.updateTransition();
    }
    _onTransitionEnd(callback) {
      return (transition) => {
        this.propsInTransition = null;
        this.onStateChange({
          inTransition: false,
          isZooming: false,
          isPanning: false,
          isRotating: false
        });
        callback === null || callback === void 0 ? void 0 : callback(transition);
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js
  var TransitionInterpolator = class {
    constructor(opts) {
      _defineProperty(this, "_propsToCompare", void 0);
      _defineProperty(this, "_propsToExtract", void 0);
      _defineProperty(this, "_requiredProps", void 0);
      const {
        compare,
        extract,
        required
      } = opts;
      this._propsToCompare = compare;
      this._propsToExtract = extract || compare;
      this._requiredProps = required;
    }
    arePropsEqual(currentProps, nextProps) {
      for (const key of this._propsToCompare) {
        if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
          return false;
        }
      }
      return true;
    }
    initializeProps(startProps, endProps) {
      const startViewStateProps = {};
      const endViewStateProps = {};
      for (const key of this._propsToExtract) {
        if (key in startProps || key in endProps) {
          startViewStateProps[key] = startProps[key];
          endViewStateProps[key] = endProps[key];
        }
      }
      this._checkRequiredProps(startViewStateProps);
      this._checkRequiredProps(endViewStateProps);
      return {
        start: startViewStateProps,
        end: endViewStateProps
      };
    }
    getDuration(startProps, endProps) {
      return endProps.transitionDuration;
    }
    _checkRequiredProps(props) {
      if (!this._requiredProps) {
        return;
      }
      this._requiredProps.forEach((propName) => {
        const value = props[propName];
        assert10(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
      });
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js
  var DEFAULT_PROPS2 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
  var LinearInterpolator = class extends TransitionInterpolator {
    constructor(opts = {}) {
      const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
      const normalizedOpts = Array.isArray(opts) ? {} : opts;
      normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
        compare: transitionProps,
        required: transitionProps
      } : transitionProps || {
        compare: DEFAULT_PROPS2,
        required: DEFAULT_REQUIRED_PROPS
      };
      super(normalizedOpts.transitionProps);
      _defineProperty(this, "opts", void 0);
      this.opts = normalizedOpts;
    }
    initializeProps(startProps, endProps) {
      const result = super.initializeProps(startProps, endProps);
      const {
        makeViewport,
        around
      } = this.opts;
      if (makeViewport && around) {
        const startViewport = makeViewport(startProps);
        const endViewport = makeViewport(endProps);
        const aroundPosition = startViewport.unproject(around);
        result.start.around = around;
        Object.assign(result.end, {
          around: endViewport.project(aroundPosition),
          aroundPosition,
          width: endProps.width,
          height: endProps.height
        });
      }
      return result;
    }
    interpolateProps(startProps, endProps, t2) {
      const propsInTransition = {};
      for (const key of this._propsToExtract) {
        propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t2);
      }
      if (endProps.aroundPosition && this.opts.makeViewport) {
        const viewport = this.opts.makeViewport({
          ...endProps,
          ...propsInTransition
        });
        Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, lerp(startProps.around, endProps.around, t2)));
      }
      return propsInTransition;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/controller.js
  var NO_TRANSITION_PROPS = {
    transitionDuration: 0
  };
  var DEFAULT_INERTIA = 300;
  var INERTIA_EASING = (t2) => 1 - (1 - t2) * (1 - t2);
  var EVENT_TYPES = {
    WHEEL: ["wheel"],
    PAN: ["panstart", "panmove", "panend"],
    PINCH: ["pinchstart", "pinchmove", "pinchend"],
    TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
    DOUBLE_TAP: ["doubletap"],
    KEYBOARD: ["keydown"]
  };
  var pinchEventWorkaround = {};
  var Controller = class {
    constructor(opts) {
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "state", {});
      _defineProperty(this, "transitionManager", void 0);
      _defineProperty(this, "eventManager", void 0);
      _defineProperty(this, "onViewStateChange", void 0);
      _defineProperty(this, "onStateChange", void 0);
      _defineProperty(this, "makeViewport", void 0);
      _defineProperty(this, "_controllerState", void 0);
      _defineProperty(this, "_events", {});
      _defineProperty(this, "_interactionState", {
        isDragging: false
      });
      _defineProperty(this, "_customEvents", []);
      _defineProperty(this, "_eventStartBlocked", null);
      _defineProperty(this, "_panMove", false);
      _defineProperty(this, "invertPan", false);
      _defineProperty(this, "dragMode", "rotate");
      _defineProperty(this, "inertia", 0);
      _defineProperty(this, "scrollZoom", true);
      _defineProperty(this, "dragPan", true);
      _defineProperty(this, "dragRotate", true);
      _defineProperty(this, "doubleClickZoom", true);
      _defineProperty(this, "touchZoom", true);
      _defineProperty(this, "touchRotate", false);
      _defineProperty(this, "keyboard", true);
      this.transitionManager = new TransitionManager({
        ...opts,
        getControllerState: (props) => new this.ControllerState(props),
        onViewStateChange: this._onTransition.bind(this),
        onStateChange: this._setInteractionState.bind(this)
      });
      this.handleEvent = this.handleEvent.bind(this);
      this.eventManager = opts.eventManager;
      this.onViewStateChange = opts.onViewStateChange || (() => {
      });
      this.onStateChange = opts.onStateChange || (() => {
      });
      this.makeViewport = opts.makeViewport;
    }
    set events(customEvents) {
      this.toggleEvents(this._customEvents, false);
      this.toggleEvents(customEvents, true);
      this._customEvents = customEvents;
      if (this.props) {
        this.setProps(this.props);
      }
    }
    finalize() {
      for (const eventName in this._events) {
        if (this._events[eventName]) {
          var _this$eventManager;
          (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.off(eventName, this.handleEvent);
        }
      }
      this.transitionManager.finalize();
    }
    handleEvent(event) {
      this._controllerState = void 0;
      const eventStartBlocked = this._eventStartBlocked;
      switch (event.type) {
        case "panstart":
          return eventStartBlocked ? false : this._onPanStart(event);
        case "panmove":
          return this._onPan(event);
        case "panend":
          return this._onPanEnd(event);
        case "pinchstart":
          return eventStartBlocked ? false : this._onPinchStart(event);
        case "pinchmove":
          return this._onPinch(event);
        case "pinchend":
          return this._onPinchEnd(event);
        case "tripanstart":
          return eventStartBlocked ? false : this._onTriplePanStart(event);
        case "tripanmove":
          return this._onTriplePan(event);
        case "tripanend":
          return this._onTriplePanEnd(event);
        case "doubletap":
          return this._onDoubleTap(event);
        case "wheel":
          return this._onWheel(event);
        case "keydown":
          return this._onKeyDown(event);
        default:
          return false;
      }
    }
    get controllerState() {
      this._controllerState = this._controllerState || new this.ControllerState({
        makeViewport: this.makeViewport,
        ...this.props,
        ...this.state
      });
      return this._controllerState;
    }
    getCenter(event) {
      const {
        x: x2,
        y: y2
      } = this.props;
      const {
        offsetCenter
      } = event;
      return [offsetCenter.x - x2, offsetCenter.y - y2];
    }
    isPointInBounds(pos, event) {
      const {
        width,
        height
      } = this.props;
      if (event && event.handled) {
        return false;
      }
      const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
      if (inside && event) {
        event.stopPropagation();
      }
      return inside;
    }
    isFunctionKeyPressed(event) {
      const {
        srcEvent
      } = event;
      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
    isDragging() {
      return this._interactionState.isDragging || false;
    }
    blockEvents(timeout) {
      const timer = setTimeout(() => {
        if (this._eventStartBlocked === timer) {
          this._eventStartBlocked = null;
        }
      }, timeout);
      this._eventStartBlocked = timer;
    }
    setProps(props) {
      if (props.dragMode) {
        this.dragMode = props.dragMode;
      }
      this.props = props;
      if (!("transitionInterpolator" in props)) {
        props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
      }
      this.transitionManager.processViewStateChange(props);
      const {
        inertia
      } = props;
      this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
      const {
        scrollZoom = true,
        dragPan = true,
        dragRotate = true,
        doubleClickZoom = true,
        touchZoom = true,
        touchRotate = false,
        keyboard = true
      } = props;
      const isInteractive = Boolean(this.onViewStateChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoom = touchZoom;
      this.touchRotate = touchRotate;
      this.keyboard = keyboard;
    }
    updateTransition() {
      this.transitionManager.updateTransition();
    }
    toggleEvents(eventNames, enabled) {
      if (this.eventManager) {
        eventNames.forEach((eventName) => {
          if (this._events[eventName] !== enabled) {
            this._events[eventName] = enabled;
            if (enabled) {
              this.eventManager.on(eventName, this.handleEvent);
            } else {
              this.eventManager.off(eventName, this.handleEvent);
            }
          }
        });
      }
    }
    updateViewport(newControllerState, extraProps = null, interactionState = {}) {
      const viewState = {
        ...newControllerState.getViewportProps(),
        ...extraProps
      };
      const changed = this.controllerState !== newControllerState;
      this.state = newControllerState.getState();
      this._setInteractionState(interactionState);
      if (changed) {
        const oldViewState = this.controllerState && this.controllerState.getViewportProps();
        if (this.onViewStateChange) {
          this.onViewStateChange({
            viewState,
            interactionState: this._interactionState,
            oldViewState
          });
        }
      }
    }
    _onTransition(params) {
      this.onViewStateChange({
        ...params,
        interactionState: this._interactionState
      });
    }
    _setInteractionState(newStates) {
      Object.assign(this._interactionState, newStates);
      this.onStateChange(this._interactionState);
    }
    _onPanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
      if (this.invertPan || this.dragMode === "pan") {
        alternateMode = !alternateMode;
      }
      const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
        pos
      });
      this._panMove = alternateMode;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onPan(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
    }
    _onPanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
    }
    _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.pan({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: true
      });
      return true;
    }
    _onPanMoveEnd(event) {
      const {
        inertia
      } = this;
      if (this.dragPan && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.pan({
          pos: endPos
        }).panEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isPanning: true
        });
      } else {
        const newControllerState = this.controllerState.panEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false
        });
      }
      return true;
    }
    _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.rotate({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onPanRotateEnd(event) {
      const {
        inertia
      } = this;
      if (this.dragRotate && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.rotate({
          pos: endPos
        }).rotateEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isRotating: true
        });
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      event.srcEvent.preventDefault();
      const {
        speed = 0.01,
        smooth = false
      } = this.scrollZoom === true ? {} : this.scrollZoom;
      const {
        delta
      } = event;
      let scale3 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
      if (delta < 0 && scale3 !== 0) {
        scale3 = 1 / scale3;
      }
      const newControllerState = this.controllerState.zoom({
        pos,
        scale: scale3
      });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({
          around: pos
        }),
        transitionDuration: smooth ? 250 : 1
      }, {
        isZooming: true,
        isPanning: true
      });
      return true;
    }
    _onTriplePanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.rotateStart({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onTriplePan(event) {
      if (!this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      const pos = this.getCenter(event);
      pos[0] -= event.deltaX;
      const newControllerState = this.controllerState.rotate({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onTriplePanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const {
        inertia
      } = this;
      if (this.touchRotate && inertia && event.velocityY) {
        const pos = this.getCenter(event);
        const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.rotate({
          pos: endPos
        });
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isRotating: true
        });
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onPinchStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.zoomStart({
        pos
      }).rotateStart({
        pos
      });
      pinchEventWorkaround._startPinchRotation = event.rotation;
      pinchEventWorkaround._lastPinchEvent = event;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onPinch(event) {
      if (!this.touchZoom && !this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      let newControllerState = this.controllerState;
      if (this.touchZoom) {
        const {
          scale: scale3
        } = event;
        const pos = this.getCenter(event);
        newControllerState = newControllerState.zoom({
          pos,
          scale: scale3
        });
      }
      if (this.touchRotate) {
        const {
          rotation
        } = event;
        newControllerState = newControllerState.rotate({
          deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
        });
      }
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: this.touchRotate
      });
      pinchEventWorkaround._lastPinchEvent = event;
      return true;
    }
    _onPinchEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const {
        inertia
      } = this;
      const {
        _lastPinchEvent
      } = pinchEventWorkaround;
      if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
        const pos = this.getCenter(event);
        let newControllerState = this.controllerState.rotateEnd();
        const z = Math.log2(event.scale);
        const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
        const endScale = Math.pow(2, z + velocityZ * inertia / 2);
        newControllerState = newControllerState.zoom({
          pos,
          scale: endScale
        }).zoomEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps({
            around: pos
          }),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isPanning: this.touchZoom,
          isZooming: this.touchZoom,
          isRotating: false
        });
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.zoomEnd().rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false,
          isZooming: false,
          isRotating: false
        });
      }
      pinchEventWorkaround._startPinchRotation = null;
      pinchEventWorkaround._lastPinchEvent = null;
      return true;
    }
    _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const isZoomOut = this.isFunctionKeyPressed(event);
      const newControllerState = this.controllerState.zoom({
        pos,
        scale: isZoomOut ? 0.5 : 2
      });
      this.updateViewport(newControllerState, this._getTransitionProps({
        around: pos
      }), {
        isZooming: true,
        isPanning: true
      });
      this.blockEvents(100);
      return true;
    }
    _onKeyDown(event) {
      if (!this.keyboard) {
        return false;
      }
      const funcKey = this.isFunctionKeyPressed(event);
      const {
        zoomSpeed,
        moveSpeed,
        rotateSpeedX,
        rotateSpeedY
      } = this.keyboard === true ? {} : this.keyboard;
      const {
        controllerState
      } = this;
      let newControllerState;
      const interactionState = {};
      switch (event.srcEvent.code) {
        case "Minus":
          newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "Equal":
          newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "ArrowLeft":
          if (funcKey) {
            newControllerState = controllerState.rotateLeft(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveLeft(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowRight":
          if (funcKey) {
            newControllerState = controllerState.rotateRight(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveRight(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowUp":
          if (funcKey) {
            newControllerState = controllerState.rotateUp(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveUp(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowDown":
          if (funcKey) {
            newControllerState = controllerState.rotateDown(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveDown(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        default:
          return false;
      }
      this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
      return true;
    }
    _getTransitionProps(opts) {
      const {
        transition
      } = this;
      if (!transition || !transition.transitionInterpolator) {
        return NO_TRANSITION_PROPS;
      }
      return opts ? {
        ...transition,
        transitionInterpolator: new LinearInterpolator({
          ...opts,
          ...transition.transitionInterpolator.opts,
          makeViewport: this.controllerState.makeViewport
        })
      } : transition;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/view-state.js
  var ViewState = class {
    constructor(props, state) {
      _defineProperty(this, "_viewportProps", void 0);
      _defineProperty(this, "_state", void 0);
      this._viewportProps = this.applyConstraints(props);
      this._state = state;
    }
    getViewportProps() {
      return this._viewportProps;
    }
    getState() {
      return this._state;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js
  var PITCH_MOUSE_THRESHOLD = 5;
  var PITCH_ACCEL = 1.2;
  var MapState = class extends ViewState {
    constructor(options) {
      const {
        width,
        height,
        latitude,
        longitude,
        zoom,
        bearing = 0,
        pitch = 0,
        altitude = 1.5,
        position = [0, 0, 0],
        maxZoom = 20,
        minZoom = 0,
        maxPitch = 60,
        minPitch = 0,
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom,
        normalize = true
      } = options;
      assert10(Number.isFinite(longitude));
      assert10(Number.isFinite(latitude));
      assert10(Number.isFinite(zoom));
      super({
        width,
        height,
        latitude,
        longitude,
        zoom,
        bearing,
        pitch,
        altitude,
        maxZoom,
        minZoom,
        maxPitch,
        minPitch,
        normalize,
        position
      }, {
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom
      });
      _defineProperty(this, "makeViewport", void 0);
      this.makeViewport = options.makeViewport;
    }
    panStart({
      pos
    }) {
      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }
    pan({
      pos,
      startPos
    }) {
      const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
      if (!startPanLngLat) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanLngLat, pos);
      return this._getUpdatedState(newProps);
    }
    panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }
    rotateStart({
      pos
    }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const {
        startRotatePos,
        startBearing,
        startPitch
      } = this.getState();
      if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
      } else {
        newRotation = {
          bearing: startBearing + deltaAngleX,
          pitch: startPitch + deltaAngleY
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }
    zoomStart({
      pos
    }) {
      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    zoom({
      pos,
      startPos,
      scale: scale3
    }) {
      let {
        startZoom,
        startZoomLngLat
      } = this.getState();
      if (!startZoomLngLat) {
        startZoom = this.getViewportProps().zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomLngLat) {
        return this;
      }
      const {
        maxZoom,
        minZoom
      } = this.getViewportProps();
      let zoom = startZoom + Math.log2(scale3);
      zoom = clamp(zoom, minZoom, maxZoom);
      const zoomedViewport = this.makeViewport({
        ...this.getViewportProps(),
        zoom
      });
      return this._getUpdatedState({
        zoom,
        ...zoomedViewport.panByPosition(startZoomLngLat, pos)
      });
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._zoomFromCenter(speed);
    }
    zoomOut(speed = 2) {
      return this._zoomFromCenter(1 / speed);
    }
    moveLeft(speed = 100) {
      return this._panFromCenter([speed, 0]);
    }
    moveRight(speed = 100) {
      return this._panFromCenter([-speed, 0]);
    }
    moveUp(speed = 100) {
      return this._panFromCenter([0, speed]);
    }
    moveDown(speed = 100) {
      return this._panFromCenter([0, -speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - speed
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = {
        ...this.getViewportProps()
      };
      const {
        bearing,
        longitude
      } = props;
      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }
      if (Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }
      return props;
    }
    applyConstraints(props) {
      const {
        maxZoom,
        minZoom,
        zoom
      } = props;
      props.zoom = clamp(zoom, minZoom, maxZoom);
      const {
        maxPitch,
        minPitch,
        pitch
      } = props;
      props.pitch = clamp(pitch, minPitch, maxPitch);
      const {
        normalize = true
      } = props;
      if (normalize) {
        Object.assign(props, normalizeViewportProps(props));
      }
      return props;
    }
    _zoomFromCenter(scale3) {
      const {
        width,
        height
      } = this.getViewportProps();
      return this.zoom({
        pos: [width / 2, height / 2],
        scale: scale3
      });
    }
    _panFromCenter(offset) {
      const {
        width,
        height
      } = this.getViewportProps();
      return this.pan({
        startPos: [width / 2, height / 2],
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    _getNewRotation(pos, startPos, startPitch, startBearing) {
      const deltaX = pos[0] - startPos[0];
      const deltaY = pos[1] - startPos[1];
      const centerY = pos[1];
      const startY = startPos[1];
      const {
        width,
        height
      } = this.getViewportProps();
      const deltaScaleX = deltaX / width;
      let deltaScaleY = 0;
      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = clamp(deltaScaleY, -1, 1);
      const {
        minPitch,
        maxPitch
      } = this.getViewportProps();
      const bearing = startBearing + 180 * deltaScaleX;
      let pitch = startPitch;
      if (deltaScaleY > 0) {
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }
      return {
        pitch,
        bearing
      };
    }
  };
  var MapController = class extends Controller {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ControllerState", MapState);
      _defineProperty(this, "transition", {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator({
          transitionProps: {
            compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
            required: ["longitude", "latitude", "zoom"]
          }
        })
      });
      _defineProperty(this, "dragMode", "pan");
    }
    setProps(props) {
      props.position = props.position || [0, 0, 0];
      const oldProps = this.props;
      super.setProps(props);
      const dimensionChanged = !oldProps || oldProps.height !== props.height;
      if (dimensionChanged) {
        this.updateViewport(new this.ControllerState({
          makeViewport: this.makeViewport,
          ...props,
          ...this.state
        }));
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/views/map-view.js
  var MapView = class extends View {
    get ViewportType() {
      return WebMercatorViewport2;
    }
    get ControllerType() {
      return MapController;
    }
  };
  _defineProperty(MapView, "displayName", "MapView");

  // node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js
  var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
  function compareEffects(e1, e2) {
    var _e1$order, _e2$order;
    const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;
    const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;
    return o1 - o2;
  }
  var EffectManager = class {
    constructor() {
      _defineProperty(this, "effects", void 0);
      _defineProperty(this, "_resolvedEffects", []);
      _defineProperty(this, "_defaultEffects", []);
      _defineProperty(this, "_needsRedraw", void 0);
      this.effects = [];
      this._needsRedraw = "Initial render";
      this._setEffects([]);
    }
    addDefaultEffect(effect) {
      const defaultEffects = this._defaultEffects;
      if (!defaultEffects.find((e2) => e2.id === effect.id)) {
        const index = defaultEffects.findIndex((e2) => compareEffects(e2, effect) > 0);
        if (index < 0) {
          defaultEffects.push(effect);
        } else {
          defaultEffects.splice(index, 0, effect);
        }
        this._setEffects(this.effects);
      }
    }
    setProps(props) {
      if ("effects" in props) {
        if (!deepEqual(props.effects, this.effects, 1)) {
          this._setEffects(props.effects);
        }
      }
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    getEffects() {
      return this._resolvedEffects;
    }
    _setEffects(effects) {
      const oldEffectsMap = {};
      for (const effect of this.effects) {
        oldEffectsMap[effect.id] = effect;
      }
      const nextEffects = [];
      for (const effect of effects) {
        const oldEffect = oldEffectsMap[effect.id];
        if (oldEffect && oldEffect !== effect) {
          if (oldEffect.setProps) {
            oldEffect.setProps(effect.props);
            nextEffects.push(oldEffect);
          } else {
            oldEffect.cleanup();
            nextEffects.push(effect);
          }
        } else {
          nextEffects.push(effect);
        }
        delete oldEffectsMap[effect.id];
      }
      for (const removedEffectId in oldEffectsMap) {
        oldEffectsMap[removedEffectId].cleanup();
      }
      this.effects = nextEffects;
      this._resolvedEffects = nextEffects.concat(this._defaultEffects);
      if (!effects.some((effect) => effect instanceof LightingEffect)) {
        this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
      }
      this._needsRedraw = "effects changed";
    }
    finalize() {
      for (const effect of this._resolvedEffects) {
        effect.cleanup();
      }
      this.effects.length = 0;
      this._resolvedEffects.length = 0;
      this._defaultEffects.length = 0;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js
  var DrawLayersPass = class extends LayersPass {
    shouldDrawLayer(layer) {
      const {
        operation
      } = layer.props;
      return operation.includes("draw") || operation.includes("terrain");
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js
  var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
  var DeckRenderer = class {
    constructor(gl) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "layerFilter", void 0);
      _defineProperty(this, "drawPickingColors", void 0);
      _defineProperty(this, "drawLayersPass", void 0);
      _defineProperty(this, "pickLayersPass", void 0);
      _defineProperty(this, "renderCount", void 0);
      _defineProperty(this, "_needsRedraw", void 0);
      _defineProperty(this, "renderBuffers", void 0);
      _defineProperty(this, "lastPostProcessEffect", void 0);
      this.gl = gl;
      this.layerFilter = null;
      this.drawPickingColors = false;
      this.drawLayersPass = new DrawLayersPass(gl);
      this.pickLayersPass = new PickLayersPass(gl);
      this.renderCount = 0;
      this._needsRedraw = "Initial render";
      this.renderBuffers = [];
      this.lastPostProcessEffect = null;
    }
    setProps(props) {
      if (this.layerFilter !== props.layerFilter) {
        this.layerFilter = props.layerFilter;
        this._needsRedraw = "layerFilter changed";
      }
      if (this.drawPickingColors !== props.drawPickingColors) {
        this.drawPickingColors = props.drawPickingColors;
        this._needsRedraw = "drawPickingColors changed";
      }
    }
    renderLayers(opts) {
      if (!opts.viewports.length) {
        return;
      }
      const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
      const renderOpts = {
        layerFilter: this.layerFilter,
        isPicking: this.drawPickingColors,
        ...opts,
        target: opts.target || Framebuffer.getDefaultFramebuffer(this.gl)
      };
      if (renderOpts.effects) {
        this._preRender(renderOpts.effects, renderOpts);
      }
      const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
      const renderStats = layerPass.render({
        ...renderOpts,
        target: outputBuffer
      });
      if (renderOpts.effects) {
        this._postRender(renderOpts.effects, renderOpts);
      }
      this.renderCount++;
      debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    finalize() {
      const {
        renderBuffers
      } = this;
      for (const buffer of renderBuffers) {
        buffer.delete();
      }
      renderBuffers.length = 0;
    }
    _preRender(effects, opts) {
      this.lastPostProcessEffect = null;
      opts.preRenderStats = opts.preRenderStats || {};
      for (const effect of effects) {
        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
        if (effect.postRender) {
          this.lastPostProcessEffect = effect.id;
        }
      }
      if (this.lastPostProcessEffect) {
        this._resizeRenderBuffers();
      }
    }
    _resizeRenderBuffers() {
      const {
        renderBuffers
      } = this;
      if (renderBuffers.length === 0) {
        renderBuffers.push(new Framebuffer(this.gl), new Framebuffer(this.gl));
      }
      for (const buffer of renderBuffers) {
        buffer.resize();
      }
    }
    _postRender(effects, opts) {
      const {
        renderBuffers
      } = this;
      const params = {
        ...opts,
        inputBuffer: renderBuffers[0],
        swapBuffer: renderBuffers[1],
        target: null
      };
      for (const effect of effects) {
        if (effect.postRender) {
          if (effect.id === this.lastPostProcessEffect) {
            params.target = opts.target;
            effect.postRender(this.gl, params);
            break;
          }
          const buffer = effect.postRender(this.gl, params);
          params.inputBuffer = buffer;
          params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
        }
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js
  var NO_PICKED_OBJECT = {
    pickedColor: null,
    pickedObjectIndex: -1
  };
  function getClosestObject({
    pickedColors,
    decodePickingColor,
    deviceX,
    deviceY,
    deviceRadius,
    deviceRect
  }) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = deviceRect;
    let minSquareDistanceToCenter = deviceRadius * deviceRadius;
    let closestPixelIndex = -1;
    let i2 = 0;
    for (let row = 0; row < height; row++) {
      const dy = row + y2 - deviceY;
      const dy2 = dy * dy;
      if (dy2 > minSquareDistanceToCenter) {
        i2 += 4 * width;
      } else {
        for (let col = 0; col < width; col++) {
          const pickedLayerIndex = pickedColors[i2 + 3] - 1;
          if (pickedLayerIndex >= 0) {
            const dx = col + x2 - deviceX;
            const d2 = dx * dx + dy2;
            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i2;
            }
          }
          i2 += 4;
        }
      }
    }
    if (closestPixelIndex >= 0) {
      const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      const pickedObject = decodePickingColor(pickedColor);
      if (pickedObject) {
        const dy = Math.floor(closestPixelIndex / 4 / width);
        const dx = closestPixelIndex / 4 - dy * width;
        return {
          ...pickedObject,
          pickedColor,
          pickedX: x2 + dx,
          pickedY: y2 + dy
        };
      }
      log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
    return NO_PICKED_OBJECT;
  }
  function getUniqueObjects({
    pickedColors,
    decodePickingColor
  }) {
    const uniqueColors = /* @__PURE__ */ new Map();
    if (pickedColors) {
      for (let i2 = 0; i2 < pickedColors.length; i2 += 4) {
        const pickedLayerIndex = pickedColors[i2 + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const pickedColor = pickedColors.slice(i2, i2 + 4);
          const colorKey = pickedColor.join(",");
          if (!uniqueColors.has(colorKey)) {
            const pickedObject = decodePickingColor(pickedColor);
            if (pickedObject) {
              uniqueColors.set(colorKey, {
                ...pickedObject,
                color: pickedColor
              });
            } else {
              log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
            }
          }
        }
      }
    }
    return Array.from(uniqueColors.values());
  }

  // node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js
  function getEmptyPickingInfo({
    pickInfo,
    viewports,
    pixelRatio,
    x: x2,
    y: y2,
    z
  }) {
    let pickedViewport = viewports[0];
    if (viewports.length > 1) {
      pickedViewport = getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
        x: x2,
        y: y2
      });
    }
    let coordinate;
    if (pickedViewport) {
      const point = [x2 - pickedViewport.x, y2 - pickedViewport.y];
      if (z !== void 0) {
        point[2] = z;
      }
      coordinate = pickedViewport.unproject(point);
    }
    return {
      color: null,
      layer: null,
      viewport: pickedViewport,
      index: -1,
      picked: false,
      x: x2,
      y: y2,
      pixel: [x2, y2],
      coordinate,
      devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
      pixelRatio
    };
  }
  function processPickInfo(opts) {
    const {
      pickInfo,
      lastPickedInfo,
      mode,
      layers
    } = opts;
    const {
      pickedColor,
      pickedLayer,
      pickedObjectIndex
    } = pickInfo;
    const affectedLayers = pickedLayer ? [pickedLayer] : [];
    if (mode === "hover") {
      const lastPickedPixelIndex = lastPickedInfo.index;
      const lastPickedLayerId = lastPickedInfo.layerId;
      const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
      if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
        if (pickedLayerId !== lastPickedLayerId) {
          const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
          if (lastPickedLayer) {
            affectedLayers.unshift(lastPickedLayer);
          }
        }
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
        lastPickedInfo.info = null;
      }
    }
    const baseInfo = getEmptyPickingInfo(opts);
    const infos = /* @__PURE__ */ new Map();
    infos.set(null, baseInfo);
    affectedLayers.forEach((layer) => {
      let info = {
        ...baseInfo
      };
      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }
      info = getLayerPickingInfo({
        layer,
        info,
        mode
      });
      const rootLayer = info.layer;
      if (layer === pickedLayer && mode === "hover") {
        lastPickedInfo.info = info;
      }
      infos.set(rootLayer.id, info);
      if (mode === "hover") {
        rootLayer.updateAutoHighlight(info);
      }
    });
    return infos;
  }
  function getLayerPickingInfo({
    layer,
    info,
    mode
  }) {
    while (layer && info) {
      const sourceLayer = info.layer || null;
      info.sourceLayer = sourceLayer;
      info.layer = layer;
      info = layer.getPickingInfo({
        info,
        mode,
        sourceLayer
      });
      layer = layer.parent;
    }
    return info;
  }
  function getViewportFromCoordinates(viewports, pixel) {
    for (let i2 = viewports.length - 1; i2 >= 0; i2--) {
      const viewport = viewports[i2];
      if (viewport.containsPixel(pixel)) {
        return viewport;
      }
    }
    return viewports[0];
  }

  // node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js
  var DeckPicker = class {
    constructor(gl) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "pickingFBO", void 0);
      _defineProperty(this, "depthFBO", void 0);
      _defineProperty(this, "pickLayersPass", void 0);
      _defineProperty(this, "layerFilter", void 0);
      _defineProperty(this, "lastPickedInfo", void 0);
      _defineProperty(this, "_pickable", true);
      this.gl = gl;
      this.pickLayersPass = new PickLayersPass(gl);
      this.lastPickedInfo = {
        index: -1,
        layerId: null,
        info: null
      };
    }
    setProps(props) {
      if ("layerFilter" in props) {
        this.layerFilter = props.layerFilter;
      }
      if ("_pickable" in props) {
        this._pickable = props._pickable;
      }
    }
    finalize() {
      if (this.pickingFBO) {
        this.pickingFBO.delete();
      }
      if (this.depthFBO) {
        this.depthFBO.color.delete();
        this.depthFBO.delete();
      }
    }
    pickObject(opts) {
      return this._pickClosestObject(opts);
    }
    pickObjects(opts) {
      return this._pickVisibleObjects(opts);
    }
    getLastPickedObject({
      x: x2,
      y: y2,
      layers,
      viewports
    }, lastPickedInfo = this.lastPickedInfo.info) {
      const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
      const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
      const layer = lastPickedLayerId ? layers.find((l2) => l2.id === lastPickedLayerId) : null;
      const viewport = lastPickedViewportId && viewports.find((v2) => v2.id === lastPickedViewportId) || viewports[0];
      const coordinate = viewport && viewport.unproject([x2 - viewport.x, y2 - viewport.y]);
      const info = {
        x: x2,
        y: y2,
        viewport,
        coordinate,
        layer
      };
      return {
        ...lastPickedInfo,
        ...info
      };
    }
    _resizeBuffer() {
      var _this$pickingFBO, _this$depthFBO;
      const {
        gl
      } = this;
      if (!this.pickingFBO) {
        this.pickingFBO = new Framebuffer(gl);
        if (Framebuffer.isSupported(gl, {
          colorBufferFloat: true
        })) {
          const depthFBO = new Framebuffer(gl);
          depthFBO.attach({
            [36064]: new Texture2D(gl, {
              format: isWebGL2(gl) ? 34836 : 6408,
              type: 5126
            })
          });
          this.depthFBO = depthFBO;
        }
      }
      (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
      (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
    }
    _getPickable(layers) {
      if (this._pickable === false) {
        return null;
      }
      const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
      return pickableLayers.length ? pickableLayers : null;
    }
    _pickClosestObject({
      layers,
      views,
      viewports,
      x: x2,
      y: y2,
      radius = 0,
      depth = 1,
      mode = "query",
      unproject3D,
      onViewportActive,
      effects
    }) {
      const pickableLayers = this._getPickable(layers);
      const pixelRatio = cssToDeviceRatio(this.gl);
      if (!pickableLayers) {
        return {
          result: [],
          emptyInfo: getEmptyPickingInfo({
            viewports,
            x: x2,
            y: y2,
            pixelRatio
          })
        };
      }
      this._resizeBuffer();
      const devicePixelRange = cssToDevicePixels(this.gl, [x2, y2], true);
      const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
      const deviceRadius = Math.round(radius * pixelRatio);
      const {
        width,
        height
      } = this.pickingFBO;
      const deviceRect = this._getPickingRect({
        deviceX: devicePixel[0],
        deviceY: devicePixel[1],
        deviceRadius,
        deviceWidth: width,
        deviceHeight: height
      });
      const cullRect = {
        x: x2 - radius,
        y: y2 - radius,
        width: radius * 2 + 1,
        height: radius * 2 + 1
      };
      let infos;
      const result = [];
      const affectedLayers = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < depth; i2++) {
        let pickInfo;
        if (deviceRect) {
          const pickedResult = this._drawAndSample({
            layers: pickableLayers,
            views,
            viewports,
            onViewportActive,
            deviceRect,
            cullRect,
            effects,
            pass: "picking:".concat(mode)
          });
          pickInfo = getClosestObject({
            ...pickedResult,
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius,
            deviceRect
          });
        } else {
          pickInfo = {
            pickedColor: null,
            pickedObjectIndex: -1
          };
        }
        let z;
        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
          const {
            pickedColors: pickedColors2
          } = this._drawAndSample({
            layers: [pickInfo.pickedLayer],
            views,
            viewports,
            onViewportActive,
            deviceRect: {
              x: pickInfo.pickedX,
              y: pickInfo.pickedY,
              width: 1,
              height: 1
            },
            cullRect,
            effects,
            pass: "picking:".concat(mode, ":z")
          }, true);
          if (pickedColors2[3]) {
            z = pickedColors2[0];
          }
        }
        if (pickInfo.pickedLayer && i2 + 1 < depth) {
          affectedLayers.add(pickInfo.pickedLayer);
          pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
        }
        infos = processPickInfo({
          pickInfo,
          lastPickedInfo: this.lastPickedInfo,
          mode,
          layers: pickableLayers,
          viewports,
          x: x2,
          y: y2,
          z,
          pixelRatio
        });
        for (const info of infos.values()) {
          if (info.layer) {
            result.push(info);
          }
        }
        if (!pickInfo.pickedColor) {
          break;
        }
      }
      for (const layer of affectedLayers) {
        layer.restorePickingColors();
      }
      return {
        result,
        emptyInfo: infos.get(null)
      };
    }
    _pickVisibleObjects({
      layers,
      views,
      viewports,
      x: x2,
      y: y2,
      width = 1,
      height = 1,
      mode = "query",
      maxObjects = null,
      onViewportActive,
      effects
    }) {
      const pickableLayers = this._getPickable(layers);
      if (!pickableLayers) {
        return [];
      }
      this._resizeBuffer();
      const pixelRatio = cssToDeviceRatio(this.gl);
      const leftTop = cssToDevicePixels(this.gl, [x2, y2], true);
      const deviceLeft = leftTop.x;
      const deviceTop = leftTop.y + leftTop.height;
      const rightBottom = cssToDevicePixels(this.gl, [x2 + width, y2 + height], true);
      const deviceRight = rightBottom.x + rightBottom.width;
      const deviceBottom = rightBottom.y;
      const deviceRect = {
        x: deviceLeft,
        y: deviceBottom,
        width: deviceRight - deviceLeft,
        height: deviceTop - deviceBottom
      };
      const pickedResult = this._drawAndSample({
        layers: pickableLayers,
        views,
        viewports,
        onViewportActive,
        deviceRect,
        cullRect: {
          x: x2,
          y: y2,
          width,
          height
        },
        effects,
        pass: "picking:".concat(mode)
      });
      const pickInfos = getUniqueObjects(pickedResult);
      const uniqueInfos = /* @__PURE__ */ new Map();
      const isMaxObjects = Number.isFinite(maxObjects);
      for (let i2 = 0; i2 < pickInfos.length; i2++) {
        var _info$object;
        if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {
          break;
        }
        const pickInfo = pickInfos[i2];
        let info = {
          color: pickInfo.pickedColor,
          layer: null,
          index: pickInfo.pickedObjectIndex,
          picked: true,
          x: x2,
          y: y2,
          pixelRatio
        };
        info = getLayerPickingInfo({
          layer: pickInfo.pickedLayer,
          info,
          mode
        });
        const pickedObjectKey = (_info$object = info.object) !== null && _info$object !== void 0 ? _info$object : "".concat(info.layer.id, "[").concat(info.index, "]");
        if (!uniqueInfos.has(pickedObjectKey)) {
          uniqueInfos.set(pickedObjectKey, info);
        }
      }
      return Array.from(uniqueInfos.values());
    }
    _drawAndSample({
      layers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect,
      effects,
      pass
    }, pickZ = false) {
      const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
      const opts = {
        layers,
        layerFilter: this.layerFilter,
        views,
        viewports,
        onViewportActive,
        pickingFBO,
        deviceRect,
        cullRect,
        effects,
        pass,
        pickZ,
        preRenderStats: {}
      };
      for (const effect of effects) {
        if (effect.useInPicking) {
          opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
        }
      }
      const {
        decodePickingColor
      } = this.pickLayersPass.render(opts);
      const {
        x: x2,
        y: y2,
        width,
        height
      } = deviceRect;
      const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
      readPixelsToArray(pickingFBO, {
        sourceX: x2,
        sourceY: y2,
        sourceWidth: width,
        sourceHeight: height,
        target: pickedColors
      });
      return {
        pickedColors,
        decodePickingColor
      };
    }
    _getPickingRect({
      deviceX,
      deviceY,
      deviceRadius,
      deviceWidth,
      deviceHeight
    }) {
      const x2 = Math.max(0, deviceX - deviceRadius);
      const y2 = Math.max(0, deviceY - deviceRadius);
      const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x2;
      const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y2;
      if (width <= 0 || height <= 0) {
        return null;
      }
      return {
        x: x2,
        y: y2,
        width,
        height
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/tooltip.js
  var defaultStyle = {
    zIndex: "1",
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: "0",
    left: "0",
    display: "none"
  };
  var Tooltip = class {
    constructor(canvas) {
      _defineProperty(this, "el", null);
      _defineProperty(this, "isVisible", false);
      const canvasParent = canvas.parentElement;
      if (canvasParent) {
        this.el = document.createElement("div");
        this.el.className = "deck-tooltip";
        Object.assign(this.el.style, defaultStyle);
        canvasParent.appendChild(this.el);
      }
    }
    setTooltip(displayInfo, x2, y2) {
      const el = this.el;
      if (!el) {
        return;
      }
      if (typeof displayInfo === "string") {
        el.innerText = displayInfo;
      } else if (!displayInfo) {
        this.isVisible = false;
        el.style.display = "none";
        return;
      } else {
        if (displayInfo.text) {
          el.innerText = displayInfo.text;
        }
        if (displayInfo.html) {
          el.innerHTML = displayInfo.html;
        }
        if (displayInfo.className) {
          el.className = displayInfo.className;
        }
      }
      this.isVisible = true;
      el.style.display = "block";
      el.style.transform = "translate(".concat(x2, "px, ").concat(y2, "px)");
      if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
        Object.assign(el.style, displayInfo.style);
      }
    }
    remove() {
      if (this.el) {
        this.el.remove();
        this.el = null;
      }
    }
  };

  // node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  var hammerjs = __toESM(require_hammer());

  // node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  function some(array, predict) {
    for (let i2 = 0; i2 < array.length; i2++) {
      if (predict(array[i2])) {
        return true;
      }
    }
    return false;
  }
  function enhancePointerEventInput(PointerEventInput2) {
    const oldHandler = PointerEventInput2.prototype.handler;
    PointerEventInput2.prototype.handler = function handler(ev) {
      const store = this.store;
      if (ev.button > 0 && ev.type === "pointerdown") {
        if (!some(store, (e2) => e2.pointerId === ev.pointerId)) {
          store.push(ev);
        }
      }
      oldHandler.call(this, ev);
    };
  }
  function enhanceMouseInput(MouseInput2) {
    MouseInput2.prototype.handler = function handler(ev) {
      let eventType = MOUSE_INPUT_MAP[ev.type];
      if (eventType & INPUT_START && ev.button >= 0) {
        this.pressed = true;
      }
      if (eventType & INPUT_MOVE && ev.which === 0) {
        eventType = INPUT_END;
      }
      if (!this.pressed) {
        return;
      }
      if (eventType & INPUT_END) {
        this.pressed = false;
      }
      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: "mouse",
        srcEvent: ev
      });
    };
  }

  // node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  enhancePointerEventInput(hammerjs.PointerEventInput);
  enhanceMouseInput(hammerjs.MouseInput);
  var Manager2 = hammerjs.Manager;
  var hammer_browser_default = hammerjs;

  // node_modules/mjolnir.js/dist/esm/inputs/input.js
  var Input = class {
    constructor(element, callback, options) {
      this.element = element;
      this.callback = callback;
      this.options = { enable: true, ...options };
    }
  };

  // node_modules/mjolnir.js/dist/esm/constants.js
  var RECOGNIZERS = hammer_browser_default ? [
    [hammer_browser_default.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
    [hammer_browser_default.Rotate, { enable: false }],
    [hammer_browser_default.Pinch, { enable: false }],
    [hammer_browser_default.Swipe, { enable: false }],
    [hammer_browser_default.Pan, { threshold: 0, enable: false }],
    [hammer_browser_default.Press, { enable: false }],
    [hammer_browser_default.Tap, { event: "doubletap", taps: 2, enable: false }],
    // TODO - rename to 'tap' and 'singletap' in the next major release
    [hammer_browser_default.Tap, { event: "anytap", enable: false }],
    [hammer_browser_default.Tap, { enable: false }]
  ] : null;
  var RECOGNIZER_COMPATIBLE_MAP = {
    tripan: ["rotate", "pinch", "pan"],
    rotate: ["pinch"],
    pinch: ["pan"],
    pan: ["press", "doubletap", "anytap", "tap"],
    doubletap: ["anytap"],
    anytap: ["tap"]
  };
  var RECOGNIZER_FALLBACK_MAP = {
    doubletap: ["tap"]
  };
  var BASIC_EVENT_ALIASES = {
    pointerdown: "pointerdown",
    pointermove: "pointermove",
    pointerup: "pointerup",
    touchstart: "pointerdown",
    touchmove: "pointermove",
    touchend: "pointerup",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup"
  };
  var INPUT_EVENT_TYPES = {
    KEY_EVENTS: ["keydown", "keyup"],
    MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
    WHEEL_EVENTS: [
      // Chrome, Safari
      "wheel",
      // IE
      "mousewheel"
    ]
  };
  var EVENT_RECOGNIZER_MAP = {
    tap: "tap",
    anytap: "anytap",
    doubletap: "doubletap",
    press: "press",
    pinch: "pinch",
    pinchin: "pinch",
    pinchout: "pinch",
    pinchstart: "pinch",
    pinchmove: "pinch",
    pinchend: "pinch",
    pinchcancel: "pinch",
    rotate: "rotate",
    rotatestart: "rotate",
    rotatemove: "rotate",
    rotateend: "rotate",
    rotatecancel: "rotate",
    tripan: "tripan",
    tripanstart: "tripan",
    tripanmove: "tripan",
    tripanup: "tripan",
    tripandown: "tripan",
    tripanleft: "tripan",
    tripanright: "tripan",
    tripanend: "tripan",
    tripancancel: "tripan",
    pan: "pan",
    panstart: "pan",
    panmove: "pan",
    panup: "pan",
    pandown: "pan",
    panleft: "pan",
    panright: "pan",
    panend: "pan",
    pancancel: "pan",
    swipe: "swipe",
    swipeleft: "swipe",
    swiperight: "swipe",
    swipeup: "swipe",
    swipedown: "swipe"
  };
  var GESTURE_EVENT_ALIASES = {
    click: "tap",
    anyclick: "anytap",
    dblclick: "doubletap",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup",
    mouseover: "pointerover",
    mouseout: "pointerout",
    mouseleave: "pointerleave"
  };

  // node_modules/mjolnir.js/dist/esm/utils/globals.js
  var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
  var window_5 = typeof window !== "undefined" ? window : global;
  var passiveSupported = false;
  try {
    const options = {
      // This function will be called when the browser
      // attempts to access the passive property.
      get passive() {
        passiveSupported = true;
        return true;
      }
    };
    window_5.addEventListener("test", null, options);
    window_5.removeEventListener("test", null);
  } catch (err) {
    passiveSupported = false;
  }

  // node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
  var firefox = userAgent.indexOf("firefox") !== -1;
  var { WHEEL_EVENTS } = INPUT_EVENT_TYPES;
  var EVENT_TYPE = "wheel";
  var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
  var WHEEL_DELTA_PER_LINE = 40;
  var SHIFT_MULTIPLIER = 0.25;
  var WheelInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        let value = event.deltaY;
        if (window_5.WheelEvent) {
          if (firefox && event.deltaMode === window_5.WheelEvent.DOM_DELTA_PIXEL) {
            value /= window_5.devicePixelRatio;
          }
          if (event.deltaMode === window_5.WheelEvent.DOM_DELTA_LINE) {
            value *= WHEEL_DELTA_PER_LINE;
          }
        }
        if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
          value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
        }
        if (event.shiftKey && value) {
          value = value * SHIFT_MULTIPLIER;
        }
        this.callback({
          type: EVENT_TYPE,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          delta: -value,
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      this.events = (this.options.events || []).concat(WHEEL_EVENTS);
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }
  };

  // node_modules/mjolnir.js/dist/esm/inputs/move-input.js
  var { MOUSE_EVENTS } = INPUT_EVENT_TYPES;
  var MOVE_EVENT_TYPE = "pointermove";
  var OVER_EVENT_TYPE = "pointerover";
  var OUT_EVENT_TYPE = "pointerout";
  var ENTER_EVENT_TYPE = "pointerenter";
  var LEAVE_EVENT_TYPE = "pointerleave";
  var MoveInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        this.handleOverEvent(event);
        this.handleOutEvent(event);
        this.handleEnterEvent(event);
        this.handleLeaveEvent(event);
        this.handleMoveEvent(event);
      };
      this.pressed = false;
      const { enable: enable2 } = this.options;
      this.enableMoveEvent = enable2;
      this.enableLeaveEvent = enable2;
      this.enableEnterEvent = enable2;
      this.enableOutEvent = enable2;
      this.enableOverEvent = enable2;
      this.events = (this.options.events || []).concat(MOUSE_EVENTS);
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
      if (eventType === MOVE_EVENT_TYPE) {
        this.enableMoveEvent = enabled;
      }
      if (eventType === OVER_EVENT_TYPE) {
        this.enableOverEvent = enabled;
      }
      if (eventType === OUT_EVENT_TYPE) {
        this.enableOutEvent = enabled;
      }
      if (eventType === ENTER_EVENT_TYPE) {
        this.enableEnterEvent = enabled;
      }
      if (eventType === LEAVE_EVENT_TYPE) {
        this.enableLeaveEvent = enabled;
      }
    }
    handleOverEvent(event) {
      if (this.enableOverEvent) {
        if (event.type === "mouseover") {
          this._emit(OVER_EVENT_TYPE, event);
        }
      }
    }
    handleOutEvent(event) {
      if (this.enableOutEvent) {
        if (event.type === "mouseout") {
          this._emit(OUT_EVENT_TYPE, event);
        }
      }
    }
    handleEnterEvent(event) {
      if (this.enableEnterEvent) {
        if (event.type === "mouseenter") {
          this._emit(ENTER_EVENT_TYPE, event);
        }
      }
    }
    handleLeaveEvent(event) {
      if (this.enableLeaveEvent) {
        if (event.type === "mouseleave") {
          this._emit(LEAVE_EVENT_TYPE, event);
        }
      }
    }
    handleMoveEvent(event) {
      if (this.enableMoveEvent) {
        switch (event.type) {
          case "mousedown":
            if (event.button >= 0) {
              this.pressed = true;
            }
            break;
          case "mousemove":
            if (event.which === 0) {
              this.pressed = false;
            }
            if (!this.pressed) {
              this._emit(MOVE_EVENT_TYPE, event);
            }
            break;
          case "mouseup":
            this.pressed = false;
            break;
          default:
        }
      }
    }
    _emit(type, event) {
      this.callback({
        type,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    }
  };

  // node_modules/mjolnir.js/dist/esm/inputs/key-input.js
  var { KEY_EVENTS } = INPUT_EVENT_TYPES;
  var DOWN_EVENT_TYPE = "keydown";
  var UP_EVENT_TYPE = "keyup";
  var KeyInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        const targetElement = event.target || event.srcElement;
        if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
          return;
        }
        if (this.enableDownEvent && event.type === "keydown") {
          this.callback({
            type: DOWN_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
        if (this.enableUpEvent && event.type === "keyup") {
          this.callback({
            type: UP_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
      };
      this.enableDownEvent = this.options.enable;
      this.enableUpEvent = this.options.enable;
      this.events = (this.options.events || []).concat(KEY_EVENTS);
      element.tabIndex = this.options.tabIndex || 0;
      element.style.outline = "none";
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
      if (eventType === DOWN_EVENT_TYPE) {
        this.enableDownEvent = enabled;
      }
      if (eventType === UP_EVENT_TYPE) {
        this.enableUpEvent = enabled;
      }
    }
  };

  // node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
  var EVENT_TYPE2 = "contextmenu";
  var ContextmenuInput = class extends Input {
    constructor(element, callback, options) {
      super(element, callback, options);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        this.callback({
          type: EVENT_TYPE2,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      element.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
      this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE2) {
        this.options.enable = enabled;
      }
    }
  };

  // node_modules/mjolnir.js/dist/esm/utils/event-utils.js
  var DOWN_EVENT = 1;
  var MOVE_EVENT = 2;
  var UP_EVENT = 4;
  var MOUSE_EVENTS2 = {
    pointerdown: DOWN_EVENT,
    pointermove: MOVE_EVENT,
    pointerup: UP_EVENT,
    mousedown: DOWN_EVENT,
    mousemove: MOVE_EVENT,
    mouseup: UP_EVENT
  };
  var MOUSE_EVENT_WHICH_LEFT = 1;
  var MOUSE_EVENT_WHICH_MIDDLE = 2;
  var MOUSE_EVENT_WHICH_RIGHT = 3;
  var MOUSE_EVENT_BUTTON_LEFT = 0;
  var MOUSE_EVENT_BUTTON_MIDDLE = 1;
  var MOUSE_EVENT_BUTTON_RIGHT = 2;
  var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
  var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
  var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
  function whichButtons(event) {
    const eventType = MOUSE_EVENTS2[event.srcEvent.type];
    if (!eventType) {
      return null;
    }
    const { buttons, button, which } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (
      // button is up, need to find out which one was pressed before
      eventType === UP_EVENT || // moving but does not support `buttons` API
      eventType === MOVE_EVENT && !Number.isFinite(buttons)
    ) {
      leftButton = which === MOUSE_EVENT_WHICH_LEFT;
      middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
      rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
    } else if (eventType === MOVE_EVENT) {
      leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
      middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
      rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    } else if (eventType === DOWN_EVENT) {
      leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
      middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
      rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
    }
    return { leftButton, middleButton, rightButton };
  }
  function getOffsetPosition(event, rootElement) {
    const center = event.center;
    if (!center) {
      return null;
    }
    const rect = rootElement.getBoundingClientRect();
    const scaleX2 = rect.width / rootElement.offsetWidth || 1;
    const scaleY2 = rect.height / rootElement.offsetHeight || 1;
    const offsetCenter = {
      x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
      y: (center.y - rect.top - rootElement.clientTop) / scaleY2
    };
    return { center, offsetCenter };
  }

  // node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
  var DEFAULT_OPTIONS = {
    srcElement: "root",
    priority: 0
  };
  var EventRegistrar = class {
    constructor(eventManager) {
      this.handleEvent = (event) => {
        if (this.isEmpty()) {
          return;
        }
        const mjolnirEvent = this._normalizeEvent(event);
        let target = event.srcEvent.target;
        while (target && target !== mjolnirEvent.rootElement) {
          this._emit(mjolnirEvent, target);
          if (mjolnirEvent.handled) {
            return;
          }
          target = target.parentNode;
        }
        this._emit(mjolnirEvent, "root");
      };
      this.eventManager = eventManager;
      this.handlers = [];
      this.handlersByElement = /* @__PURE__ */ new Map();
      this._active = false;
    }
    // Returns true if there are no non-passive handlers
    isEmpty() {
      return !this._active;
    }
    add(type, handler, options, once = false, passive = false) {
      const { handlers, handlersByElement } = this;
      let opts = DEFAULT_OPTIONS;
      if (typeof options === "string" || options && options.addEventListener) {
        opts = { ...DEFAULT_OPTIONS, srcElement: options };
      } else if (options) {
        opts = { ...DEFAULT_OPTIONS, ...options };
      }
      let entries = handlersByElement.get(opts.srcElement);
      if (!entries) {
        entries = [];
        handlersByElement.set(opts.srcElement, entries);
      }
      const entry = {
        type,
        handler,
        srcElement: opts.srcElement,
        priority: opts.priority
      };
      if (once) {
        entry.once = true;
      }
      if (passive) {
        entry.passive = true;
      }
      handlers.push(entry);
      this._active = this._active || !entry.passive;
      let insertPosition = entries.length - 1;
      while (insertPosition >= 0) {
        if (entries[insertPosition].priority >= entry.priority) {
          break;
        }
        insertPosition--;
      }
      entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
      const { handlers, handlersByElement } = this;
      for (let i2 = handlers.length - 1; i2 >= 0; i2--) {
        const entry = handlers[i2];
        if (entry.type === type && entry.handler === handler) {
          handlers.splice(i2, 1);
          const entries = handlersByElement.get(entry.srcElement);
          entries.splice(entries.indexOf(entry), 1);
          if (entries.length === 0) {
            handlersByElement.delete(entry.srcElement);
          }
        }
      }
      this._active = handlers.some((entry) => !entry.passive);
    }
    /**
     * Invoke handlers on a particular element
     */
    _emit(event, srcElement) {
      const entries = this.handlersByElement.get(srcElement);
      if (entries) {
        let immediatePropagationStopped = false;
        const stopPropagation = () => {
          event.handled = true;
        };
        const stopImmediatePropagation = () => {
          event.handled = true;
          immediatePropagationStopped = true;
        };
        const entriesToRemove = [];
        for (let i2 = 0; i2 < entries.length; i2++) {
          const { type, handler, once } = entries[i2];
          handler({
            ...event,
            // @ts-ignore
            type,
            stopPropagation,
            stopImmediatePropagation
          });
          if (once) {
            entriesToRemove.push(entries[i2]);
          }
          if (immediatePropagationStopped) {
            break;
          }
        }
        for (let i2 = 0; i2 < entriesToRemove.length; i2++) {
          const { type, handler } = entriesToRemove[i2];
          this.remove(type, handler);
        }
      }
    }
    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */
    _normalizeEvent(event) {
      const rootElement = this.eventManager.getElement();
      return {
        ...event,
        ...whichButtons(event),
        ...getOffsetPosition(event, rootElement),
        preventDefault: () => {
          event.srcEvent.preventDefault();
        },
        stopImmediatePropagation: null,
        stopPropagation: null,
        handled: false,
        rootElement
      };
    }
  };

  // node_modules/mjolnir.js/dist/esm/event-manager.js
  var DEFAULT_OPTIONS2 = {
    // event handlers
    events: null,
    // custom recognizers
    recognizers: null,
    recognizerOptions: {},
    // Manager class
    Manager: Manager2,
    // allow browser default touch action
    // https://github.com/uber/react-map-gl/issues/506
    touchAction: "none",
    tabIndex: 0
  };
  var EventManager = class {
    constructor(element = null, options) {
      this._onBasicInput = (event) => {
        const { srcEvent } = event;
        const alias = BASIC_EVENT_ALIASES[srcEvent.type];
        if (alias) {
          this.manager.emit(alias, event);
        }
      };
      this._onOtherEvent = (event) => {
        this.manager.emit(event.type, event);
      };
      this.options = { ...DEFAULT_OPTIONS2, ...options };
      this.events = /* @__PURE__ */ new Map();
      this.setElement(element);
      const { events } = this.options;
      if (events) {
        this.on(events);
      }
    }
    getElement() {
      return this.element;
    }
    setElement(element) {
      if (this.element) {
        this.destroy();
      }
      this.element = element;
      if (!element) {
        return;
      }
      const { options } = this;
      const ManagerClass = options.Manager;
      this.manager = new ManagerClass(element, {
        touchAction: options.touchAction,
        recognizers: options.recognizers || RECOGNIZERS
      }).on("hammer.input", this._onBasicInput);
      if (!options.recognizers) {
        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name) => {
          const recognizer = this.manager.get(name);
          if (recognizer) {
            RECOGNIZER_COMPATIBLE_MAP[name].forEach((otherName) => {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }
      for (const recognizerName in options.recognizerOptions) {
        const recognizer = this.manager.get(recognizerName);
        if (recognizer) {
          const recognizerOption = options.recognizerOptions[recognizerName];
          delete recognizerOption.enable;
          recognizer.set(recognizerOption);
        }
      }
      this.wheelInput = new WheelInput(element, this._onOtherEvent, {
        enable: false
      });
      this.moveInput = new MoveInput(element, this._onOtherEvent, {
        enable: false
      });
      this.keyInput = new KeyInput(element, this._onOtherEvent, {
        enable: false,
        tabIndex: options.tabIndex
      });
      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
        enable: false
      });
      for (const [eventAlias, eventRegistrar] of this.events) {
        if (!eventRegistrar.isEmpty()) {
          this._toggleRecognizer(eventRegistrar.recognizerName, true);
          this.manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }
    }
    // Tear down internal event management implementations.
    destroy() {
      if (this.element) {
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.contextmenuInput.destroy();
        this.manager.destroy();
        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.contextmenuInput = null;
        this.manager = null;
        this.element = null;
      }
    }
    /** Register an event handler function to be called on `event` */
    on(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
      this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
      this._removeEventHandler(event, handler);
    }
    /*
     * Enable/disable recognizer for the given event
     */
    _toggleRecognizer(name, enabled) {
      const { manager } = this;
      if (!manager) {
        return;
      }
      const recognizer = manager.get(name);
      if (recognizer && recognizer.options.enable !== enabled) {
        recognizer.set({ enable: enabled });
        const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
        if (fallbackRecognizers && !this.options.recognizers) {
          fallbackRecognizers.forEach((otherName) => {
            const otherRecognizer = manager.get(otherName);
            if (enabled) {
              otherRecognizer.requireFailure(name);
              recognizer.dropRequireFailure(otherName);
            } else {
              otherRecognizer.dropRequireFailure(name);
            }
          });
        }
      }
      this.wheelInput.enableEventType(name, enabled);
      this.moveInput.enableEventType(name, enabled);
      this.keyInput.enableEventType(name, enabled);
      this.contextmenuInput.enableEventType(name, enabled);
    }
    /**
     * Process the event registration for a single event + handler.
     */
    _addEventHandler(event, handler, opts, once, passive) {
      if (typeof event !== "string") {
        opts = handler;
        for (const eventName in event) {
          this._addEventHandler(eventName, event[eventName], opts, once, passive);
        }
        return;
      }
      const { manager, events } = this;
      const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      let eventRegistrar = events.get(eventAlias);
      if (!eventRegistrar) {
        eventRegistrar = new EventRegistrar(this);
        events.set(eventAlias, eventRegistrar);
        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        if (manager) {
          manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }
      eventRegistrar.add(event, handler, opts, once, passive);
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
      }
    }
    /**
     * Process the event deregistration for a single event + handler.
     */
    _removeEventHandler(event, handler) {
      if (typeof event !== "string") {
        for (const eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
        return;
      }
      const { events } = this;
      const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      const eventRegistrar = events.get(eventAlias);
      if (!eventRegistrar) {
        return;
      }
      eventRegistrar.remove(event, handler);
      if (eventRegistrar.isEmpty()) {
        const { recognizerName } = eventRegistrar;
        let isRecognizerUsed = false;
        for (const eh of events.values()) {
          if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
            isRecognizerUsed = true;
            break;
          }
        }
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/deck.js
  function noop4() {
  }
  var getCursor = ({
    isDragging
  }) => isDragging ? "grabbing" : "grab";
  var defaultProps = {
    id: "",
    width: "100%",
    height: "100%",
    style: null,
    viewState: null,
    initialViewState: null,
    pickingRadius: 0,
    layerFilter: null,
    glOptions: {},
    parameters: {},
    parent: null,
    gl: null,
    canvas: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    _customRender: null,
    onWebGLInitialized: noop4,
    onResize: noop4,
    onViewStateChange: noop4,
    onInteractionStateChange: noop4,
    onBeforeRender: noop4,
    onAfterRender: noop4,
    onLoad: noop4,
    onError: (error2) => log_default.error(error2.message, error2.cause)(),
    onHover: null,
    onClick: null,
    onDragStart: null,
    onDrag: null,
    onDragEnd: null,
    _onMetrics: null,
    getCursor,
    getTooltip: null,
    debug: false,
    drawPickingColors: false
  };
  var Deck = class {
    constructor(props) {
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "width", 0);
      _defineProperty(this, "height", 0);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "canvas", null);
      _defineProperty(this, "viewManager", null);
      _defineProperty(this, "layerManager", null);
      _defineProperty(this, "effectManager", null);
      _defineProperty(this, "deckRenderer", null);
      _defineProperty(this, "deckPicker", null);
      _defineProperty(this, "eventManager", null);
      _defineProperty(this, "tooltip", null);
      _defineProperty(this, "metrics", void 0);
      _defineProperty(this, "animationLoop", void 0);
      _defineProperty(this, "stats", void 0);
      _defineProperty(this, "viewState", void 0);
      _defineProperty(this, "cursorState", void 0);
      _defineProperty(this, "_needsRedraw", void 0);
      _defineProperty(this, "_pickRequest", void 0);
      _defineProperty(this, "_lastPointerDownInfo", null);
      _defineProperty(this, "_metricsCounter", void 0);
      _defineProperty(this, "_onPointerMove", (event) => {
        const {
          _pickRequest
        } = this;
        if (event.type === "pointerleave") {
          _pickRequest.x = -1;
          _pickRequest.y = -1;
          _pickRequest.radius = 0;
        } else if (event.leftButton || event.rightButton) {
          return;
        } else {
          const pos = event.offsetCenter;
          if (!pos) {
            return;
          }
          _pickRequest.x = pos.x;
          _pickRequest.y = pos.y;
          _pickRequest.radius = this.props.pickingRadius;
        }
        if (this.layerManager) {
          this.layerManager.context.mousePosition = {
            x: _pickRequest.x,
            y: _pickRequest.y
          };
        }
        _pickRequest.event = event;
      });
      _defineProperty(this, "_onEvent", (event) => {
        const eventOptions = EVENTS[event.type];
        const pos = event.offsetCenter;
        if (!eventOptions || !pos || !this.layerManager) {
          return;
        }
        const layers = this.layerManager.getLayers();
        const info = this.deckPicker.getLastPickedObject({
          x: pos.x,
          y: pos.y,
          layers,
          viewports: this.getViewports(pos)
        }, this._lastPointerDownInfo);
        const {
          layer
        } = info;
        const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
        const rootHandler = this.props[eventOptions.handler];
        let handled = false;
        if (layerHandler) {
          handled = layerHandler.call(layer, info, event);
        }
        if (!handled && rootHandler) {
          rootHandler(info, event);
        }
      });
      _defineProperty(this, "_onPointerDown", (event) => {
        const pos = event.offsetCenter;
        const pickedInfo = this._pick("pickObject", "pickObject Time", {
          x: pos.x,
          y: pos.y,
          radius: this.props.pickingRadius
        });
        this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
      });
      this.props = {
        ...defaultProps,
        ...props
      };
      props = this.props;
      this._needsRedraw = "Initial render";
      this._pickRequest = {
        mode: "hover",
        x: -1,
        y: -1,
        radius: 0,
        event: null
      };
      this.cursorState = {
        isHovering: false,
        isDragging: false
      };
      if (props.viewState && props.initialViewState) {
        log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
      }
      if (getBrowser() === "IE") {
        log_default.warn("IE 11 is not supported")();
      }
      this.viewState = props.initialViewState;
      if (!props.gl) {
        if (typeof document !== "undefined") {
          this.canvas = this._createCanvas(props);
        }
      }
      this.animationLoop = this._createAnimationLoop(props);
      this.stats = new Stats({
        id: "deck.gl"
      });
      this.metrics = {
        fps: 0,
        setPropsTime: 0,
        updateAttributesTime: 0,
        framesRedrawn: 0,
        pickTime: 0,
        pickCount: 0,
        gpuTime: 0,
        gpuTimePerFrame: 0,
        cpuTime: 0,
        cpuTimePerFrame: 0,
        bufferMemory: 0,
        textureMemory: 0,
        renderbufferMemory: 0,
        gpuMemory: 0
      };
      this._metricsCounter = 0;
      this.setProps(props);
      if (props._typedArrayManagerProps) {
        typed_array_manager_default.setOptions(props._typedArrayManagerProps);
      }
      this.animationLoop.start();
    }
    finalize() {
      var _this$animationLoop, _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;
      (_this$animationLoop = this.animationLoop) === null || _this$animationLoop === void 0 ? void 0 : _this$animationLoop.stop();
      this.animationLoop = null;
      this._lastPointerDownInfo = null;
      (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();
      this.layerManager = null;
      (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();
      this.viewManager = null;
      (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();
      this.effectManager = null;
      (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();
      this.deckRenderer = null;
      (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();
      this.deckPicker = null;
      (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();
      this.eventManager = null;
      (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();
      this.tooltip = null;
      if (!this.props.canvas && !this.props.gl && this.canvas) {
        var _this$canvas$parentEl;
        (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);
        this.canvas = null;
      }
    }
    setProps(props) {
      this.stats.get("setProps Time").timeStart();
      if ("onLayerHover" in props) {
        log_default.removed("onLayerHover", "onHover")();
      }
      if ("onLayerClick" in props) {
        log_default.removed("onLayerClick", "onClick")();
      }
      if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {
        this.viewState = props.initialViewState;
      }
      Object.assign(this.props, props);
      this._setCanvasSize(this.props);
      const resolvedProps = Object.create(this.props);
      Object.assign(resolvedProps, {
        views: this._getViews(),
        width: this.width,
        height: this.height,
        viewState: this._getViewState()
      });
      this.animationLoop.setProps(resolvedProps);
      if (this.layerManager) {
        this.viewManager.setProps(resolvedProps);
        this.layerManager.activateViewport(this.getViewports()[0]);
        this.layerManager.setProps(resolvedProps);
        this.effectManager.setProps(resolvedProps);
        this.deckRenderer.setProps(resolvedProps);
        this.deckPicker.setProps(resolvedProps);
      }
      this.stats.get("setProps Time").timeEnd();
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      if (!this.layerManager) {
        return false;
      }
      if (this.props._animate) {
        return "Deck._animate";
      }
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
      const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
      const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
      const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
      redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
      return redraw;
    }
    redraw(reason) {
      if (!this.layerManager) {
        return;
      }
      let redrawReason = this.needsRedraw({
        clearRedrawFlags: true
      });
      redrawReason = reason || redrawReason;
      if (!redrawReason) {
        return;
      }
      this.stats.get("Redraw Count").incrementCount();
      if (this.props._customRender) {
        this.props._customRender(redrawReason);
      } else {
        this._drawLayers(redrawReason);
      }
    }
    get isInitialized() {
      return this.viewManager !== null;
    }
    getViews() {
      assert10(this.viewManager);
      return this.viewManager.views;
    }
    getViewports(rect) {
      assert10(this.viewManager);
      return this.viewManager.getViewports(rect);
    }
    getCanvas() {
      return this.canvas;
    }
    pickObject(opts) {
      const infos = this._pick("pickObject", "pickObject Time", opts).result;
      return infos.length ? infos[0] : null;
    }
    pickMultipleObjects(opts) {
      opts.depth = opts.depth || 10;
      return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
    }
    pickObjects(opts) {
      return this._pick("pickObjects", "pickObjects Time", opts);
    }
    _addResources(resources, forceUpdate = false) {
      for (const id in resources) {
        this.layerManager.resourceManager.add({
          resourceId: id,
          data: resources[id],
          forceUpdate
        });
      }
    }
    _removeResources(resourceIds) {
      for (const id of resourceIds) {
        this.layerManager.resourceManager.remove(id);
      }
    }
    _addDefaultEffect(effect) {
      this.effectManager.addDefaultEffect(effect);
    }
    _pick(method, statKey, opts) {
      assert10(this.deckPicker);
      const {
        stats
      } = this;
      stats.get("Pick Count").incrementCount();
      stats.get(statKey).timeStart();
      const infos = this.deckPicker[method]({
        layers: this.layerManager.getLayers(opts),
        views: this.viewManager.getViews(),
        viewports: this.getViewports(opts),
        onViewportActive: this.layerManager.activateViewport,
        effects: this.effectManager.getEffects(),
        ...opts
      });
      stats.get(statKey).timeEnd();
      return infos;
    }
    _createCanvas(props) {
      let canvas = props.canvas;
      if (typeof canvas === "string") {
        canvas = document.getElementById(canvas);
        assert10(canvas);
      }
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.id = props.id || "deckgl-overlay";
        const parent = props.parent || document.body;
        parent.appendChild(canvas);
      }
      Object.assign(canvas.style, props.style);
      return canvas;
    }
    _setCanvasSize(props) {
      if (!this.canvas) {
        return;
      }
      const {
        width,
        height
      } = props;
      if (width || width === 0) {
        const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;
        this.canvas.style.width = cssWidth;
      }
      if (height || height === 0) {
        var _props$style;
        const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;
        this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || "absolute";
        this.canvas.style.height = cssHeight;
      }
    }
    _updateCanvasSize() {
      var _canvas$clientWidth, _canvas$clientHeight;
      const {
        canvas
      } = this;
      if (!canvas) {
        return;
      }
      const newWidth = (_canvas$clientWidth = canvas.clientWidth) !== null && _canvas$clientWidth !== void 0 ? _canvas$clientWidth : canvas.width;
      const newHeight = (_canvas$clientHeight = canvas.clientHeight) !== null && _canvas$clientHeight !== void 0 ? _canvas$clientHeight : canvas.height;
      if (newWidth !== this.width || newHeight !== this.height) {
        var _this$viewManager2, _this$layerManager2;
        this.width = newWidth;
        this.height = newHeight;
        (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({
          width: newWidth,
          height: newHeight
        });
        (_this$layerManager2 = this.layerManager) === null || _this$layerManager2 === void 0 ? void 0 : _this$layerManager2.activateViewport(this.getViewports()[0]);
        this.props.onResize({
          width: newWidth,
          height: newHeight
        });
      }
    }
    _createAnimationLoop(props) {
      const {
        width,
        height,
        gl,
        glOptions,
        debug: debug2,
        onError,
        onBeforeRender,
        onAfterRender,
        useDevicePixels
      } = props;
      return new AnimationLoop({
        width,
        height,
        useDevicePixels,
        autoResizeDrawingBuffer: !gl,
        autoResizeViewport: false,
        gl,
        onCreateContext: (opts) => createGLContext({
          ...glOptions,
          ...opts,
          canvas: this.canvas,
          debug: debug2,
          onContextLost: () => this._onContextLost()
        }),
        onInitialize: (context) => this._setGLContext(context.gl),
        onRender: this._onRenderFrame.bind(this),
        onBeforeRender,
        onAfterRender,
        onError
      });
    }
    _getViewState() {
      return this.props.viewState || this.viewState;
    }
    _getViews() {
      let views = this.props.views || [new MapView({
        id: "default-view"
      })];
      views = Array.isArray(views) ? views : [views];
      if (views.length && this.props.controller) {
        views[0].props.controller = this.props.controller;
      }
      return views;
    }
    _onContextLost() {
      const {
        onError
      } = this.props;
      if (this.animationLoop && onError) {
        onError(new Error("WebGL context is lost"));
      }
    }
    _pickAndCallback() {
      const {
        _pickRequest
      } = this;
      if (_pickRequest.event) {
        const {
          result,
          emptyInfo
        } = this._pick("pickObject", "pickObject Time", _pickRequest);
        this.cursorState.isHovering = result.length > 0;
        let pickedInfo = emptyInfo;
        let handled = false;
        for (const info of result) {
          var _info$layer;
          pickedInfo = info;
          handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
        }
        if (!handled && this.props.onHover) {
          this.props.onHover(pickedInfo, _pickRequest.event);
        }
        if (this.props.getTooltip && this.tooltip) {
          const displayInfo = this.props.getTooltip(pickedInfo);
          this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
        }
        _pickRequest.event = null;
      }
    }
    _updateCursor() {
      const container = this.props.parent || this.canvas;
      if (container) {
        container.style.cursor = this.props.getCursor(this.cursorState);
      }
    }
    _setGLContext(gl) {
      if (this.layerManager) {
        return;
      }
      if (!this.canvas) {
        this.canvas = gl.canvas;
        instrumentGLContext(gl, {
          enable: true,
          copyState: true
        });
      }
      this.tooltip = new Tooltip(this.canvas);
      setParameters(gl, {
        blend: true,
        blendFunc: [770, 771, 1, 771],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: 515
      });
      this.props.onWebGLInitialized(gl);
      const timeline = new Timeline();
      timeline.play();
      this.animationLoop.attachTimeline(timeline);
      this.eventManager = new EventManager(this.props.parent || gl.canvas, {
        touchAction: this.props.touchAction,
        recognizerOptions: this.props.eventRecognizerOptions,
        events: {
          pointerdown: this._onPointerDown,
          pointermove: this._onPointerMove,
          pointerleave: this._onPointerMove
        }
      });
      for (const eventType in EVENTS) {
        this.eventManager.on(eventType, this._onEvent);
      }
      this.viewManager = new ViewManager({
        timeline,
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange.bind(this),
        onInteractionStateChange: this._onInteractionStateChange.bind(this),
        views: this._getViews(),
        viewState: this._getViewState(),
        width: this.width,
        height: this.height
      });
      const viewport = this.viewManager.getViewports()[0];
      this.layerManager = new LayerManager(gl, {
        deck: this,
        stats: this.stats,
        viewport,
        timeline
      });
      this.effectManager = new EffectManager();
      this.deckRenderer = new DeckRenderer(gl);
      this.deckPicker = new DeckPicker(gl);
      this.setProps(this.props);
      this._updateCanvasSize();
      this.props.onLoad();
    }
    _drawLayers(redrawReason, renderOptions) {
      const {
        gl
      } = this.layerManager.context;
      setParameters(gl, this.props.parameters);
      this.props.onBeforeRender({
        gl
      });
      this.deckRenderer.renderLayers({
        target: this.props._framebuffer,
        layers: this.layerManager.getLayers(),
        viewports: this.viewManager.getViewports(),
        onViewportActive: this.layerManager.activateViewport,
        views: this.viewManager.getViews(),
        pass: "screen",
        effects: this.effectManager.getEffects(),
        ...renderOptions
      });
      this.props.onAfterRender({
        gl
      });
    }
    _onRenderFrame(animationProps) {
      this._getFrameStats();
      if (this._metricsCounter++ % 60 === 0) {
        this._getMetrics();
        this.stats.reset();
        log_default.table(4, this.metrics)();
        if (this.props._onMetrics) {
          this.props._onMetrics(this.metrics);
        }
      }
      this._updateCanvasSize();
      this._updateCursor();
      if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
        this.tooltip.setTooltip(null);
      }
      this.layerManager.updateLayers();
      this._pickAndCallback();
      this.redraw();
      if (this.viewManager) {
        this.viewManager.updateViewStates();
      }
    }
    _onViewStateChange(params) {
      const viewState = this.props.onViewStateChange(params) || params.viewState;
      if (this.viewState) {
        this.viewState = {
          ...this.viewState,
          [params.viewId]: viewState
        };
        if (!this.props.viewState) {
          if (this.viewManager) {
            this.viewManager.setProps({
              viewState: this.viewState
            });
          }
        }
      }
    }
    _onInteractionStateChange(interactionState) {
      this.cursorState.isDragging = interactionState.isDragging || false;
      this.props.onInteractionStateChange(interactionState);
    }
    _getFrameStats() {
      const {
        stats
      } = this;
      stats.get("frameRate").timeEnd();
      stats.get("frameRate").timeStart();
      const animationLoopStats = this.animationLoop.stats;
      stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
      stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
    }
    _getMetrics() {
      const {
        metrics,
        stats
      } = this;
      metrics.fps = stats.get("frameRate").getHz();
      metrics.setPropsTime = stats.get("setProps Time").time;
      metrics.updateAttributesTime = stats.get("Update Attributes").time;
      metrics.framesRedrawn = stats.get("Redraw Count").count;
      metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
      metrics.pickCount = stats.get("Pick Count").count;
      metrics.gpuTime = stats.get("GPU Time").time;
      metrics.cpuTime = stats.get("CPU Time").time;
      metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
      metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
      const memoryStats = lumaStats.get("Memory Usage");
      metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
      metrics.textureMemory = memoryStats.get("Texture Memory").count;
      metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
      metrics.gpuMemory = memoryStats.get("GPU Memory").count;
    }
  };
  _defineProperty(Deck, "defaultProps", defaultProps);
  _defineProperty(Deck, "VERSION", VERSION5);

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js
  var ShaderAttribute = class {
    constructor(dataColumn, opts) {
      _defineProperty(this, "opts", void 0);
      _defineProperty(this, "source", void 0);
      this.opts = opts;
      this.source = dataColumn;
    }
    get value() {
      return this.source.value;
    }
    getValue() {
      const buffer = this.source.getBuffer();
      const accessor = this.getAccessor();
      if (buffer) {
        return [buffer, accessor];
      }
      const {
        value
      } = this.source;
      const {
        size
      } = accessor;
      let constantValue = value;
      if (value && value.length !== size) {
        constantValue = new Float32Array(size);
        const index = accessor.elementOffset || 0;
        for (let i2 = 0; i2 < size; ++i2) {
          constantValue[i2] = value[index + i2];
        }
      }
      return constantValue;
    }
    getAccessor() {
      return {
        ...this.source.getAccessor(),
        ...this.opts
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js
  function glArrayFromType(glType) {
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5130:
        return Float64Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return Uint8ClampedArray;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Unknown GL type");
    }
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js
  function getStride(accessor) {
    return accessor.stride || accessor.size * accessor.bytesPerElement;
  }
  function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
    if (shaderAttributeOptions.offset) {
      log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    }
    const stride = getStride(baseAccessor);
    const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
    const elementOffset = shaderAttributeOptions.elementOffset || 0;
    const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
    return {
      ...shaderAttributeOptions,
      offset,
      stride
    };
  }
  function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
    const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
    return {
      high: resolvedOptions,
      low: {
        ...resolvedOptions,
        offset: resolvedOptions.offset + baseAccessor.size * 4
      }
    };
  }
  var DataColumn = class {
    constructor(gl, opts, state) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "size", void 0);
      _defineProperty(this, "settings", void 0);
      _defineProperty(this, "value", void 0);
      _defineProperty(this, "doublePrecision", void 0);
      _defineProperty(this, "_buffer", void 0);
      _defineProperty(this, "state", void 0);
      this.gl = gl;
      this.id = opts.id || "";
      this.size = opts.size || 1;
      const logicalType = opts.logicalType || opts.type;
      const doublePrecision = logicalType === 5130;
      let {
        defaultValue
      } = opts;
      defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
      let bufferType;
      if (doublePrecision) {
        bufferType = 5126;
      } else if (!logicalType && opts.isIndexed) {
        bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
      } else {
        bufferType = logicalType || 5126;
      }
      let defaultType = glArrayFromType(logicalType || bufferType || 5126);
      this.doublePrecision = doublePrecision;
      if (doublePrecision && opts.fp64 === false) {
        defaultType = Float32Array;
      }
      this.value = null;
      this.settings = {
        ...opts,
        defaultType,
        defaultValue,
        logicalType,
        type: bufferType,
        size: this.size,
        bytesPerElement: defaultType.BYTES_PER_ELEMENT
      };
      this.state = {
        ...state,
        externalBuffer: null,
        bufferAccessor: this.settings,
        allocatedValue: null,
        numInstances: 0,
        bounds: null,
        constant: false
      };
      this._buffer = null;
    }
    get isConstant() {
      return this.state.constant;
    }
    get buffer() {
      if (!this._buffer) {
        const {
          isIndexed,
          type
        } = this.settings;
        this._buffer = new Buffer2(this.gl, {
          id: this.id,
          target: isIndexed ? 34963 : 34962,
          accessor: {
            type
          }
        });
      }
      return this._buffer;
    }
    get byteOffset() {
      const accessor = this.getAccessor();
      if (accessor.vertexOffset) {
        return accessor.vertexOffset * getStride(accessor);
      }
      return 0;
    }
    get numInstances() {
      return this.state.numInstances;
    }
    set numInstances(n2) {
      this.state.numInstances = n2;
    }
    delete() {
      if (this._buffer) {
        this._buffer.delete();
        this._buffer = null;
      }
      typed_array_manager_default.release(this.state.allocatedValue);
    }
    getShaderAttributes(id, options) {
      if (this.doublePrecision) {
        const shaderAttributes = {};
        const isBuffer64Bit = this.value instanceof Float64Array;
        const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
        shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);
        shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
        return shaderAttributes;
      }
      if (options) {
        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
        return {
          [id]: new ShaderAttribute(this, shaderAttributeDef)
        };
      }
      return {
        [id]: this
      };
    }
    getBuffer() {
      if (this.state.constant) {
        return null;
      }
      return this.state.externalBuffer || this._buffer;
    }
    getValue() {
      if (this.state.constant) {
        return this.value;
      }
      return [this.getBuffer(), this.getAccessor()];
    }
    getAccessor() {
      return this.state.bufferAccessor;
    }
    getBounds() {
      if (this.state.bounds) {
        return this.state.bounds;
      }
      let result = null;
      if (this.state.constant && this.value) {
        const min = Array.from(this.value);
        result = [min, min];
      } else {
        const {
          value,
          numInstances,
          size
        } = this;
        const len = numInstances * size;
        if (value && len && value.length >= len) {
          const min = new Array(size).fill(Infinity);
          const max = new Array(size).fill(-Infinity);
          for (let i2 = 0; i2 < len; ) {
            for (let j = 0; j < size; j++) {
              const v2 = value[i2++];
              if (v2 < min[j])
                min[j] = v2;
              if (v2 > max[j])
                max[j] = v2;
            }
          }
          result = [min, max];
        }
      }
      this.state.bounds = result;
      return result;
    }
    setData(data) {
      const {
        state
      } = this;
      let opts;
      if (ArrayBuffer.isView(data)) {
        opts = {
          value: data
        };
      } else if (data instanceof Buffer2) {
        opts = {
          buffer: data
        };
      } else {
        opts = data;
      }
      const accessor = {
        ...this.settings,
        ...opts
      };
      state.bufferAccessor = accessor;
      state.bounds = null;
      if (opts.constant) {
        let value = opts.value;
        value = this._normalizeValue(value, [], 0);
        if (this.settings.normalized) {
          value = this.normalizeConstant(value);
        }
        const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);
        if (!hasChanged) {
          return false;
        }
        state.externalBuffer = null;
        state.constant = true;
        this.value = value;
      } else if (opts.buffer) {
        const buffer = opts.buffer;
        state.externalBuffer = buffer;
        state.constant = false;
        this.value = opts.value || null;
        const isBuffer64Bit = opts.value instanceof Float64Array;
        accessor.type = opts.type || buffer.accessor.type;
        accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
        accessor.stride = getStride(accessor);
      } else if (opts.value) {
        this._checkExternalBuffer(opts);
        let value = opts.value;
        state.externalBuffer = null;
        state.constant = false;
        this.value = value;
        accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
        accessor.stride = getStride(accessor);
        const {
          buffer,
          byteOffset
        } = this;
        if (this.doublePrecision && value instanceof Float64Array) {
          value = toDoublePrecisionArray(value, accessor);
        }
        const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;
        if (buffer.byteLength < requiredBufferSize) {
          buffer.reallocate(requiredBufferSize);
        }
        buffer.setAccessor(null);
        buffer.subData({
          data: value,
          offset: byteOffset
        });
        accessor.type = opts.type || buffer.accessor.type;
      }
      return true;
    }
    updateSubBuffer(opts = {}) {
      this.state.bounds = null;
      const value = this.value;
      const {
        startOffset = 0,
        endOffset
      } = opts;
      this.buffer.subData({
        data: this.doublePrecision && value instanceof Float64Array ? toDoublePrecisionArray(value, {
          size: this.size,
          startIndex: startOffset,
          endIndex: endOffset
        }) : value.subarray(startOffset, endOffset),
        offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
      });
    }
    allocate(numInstances, copy = false) {
      const {
        state
      } = this;
      const oldValue = state.allocatedValue;
      const value = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
        size: this.size,
        type: this.settings.defaultType,
        copy
      });
      this.value = value;
      const {
        buffer,
        byteOffset
      } = this;
      if (buffer.byteLength < value.byteLength + byteOffset) {
        buffer.reallocate(value.byteLength + byteOffset);
        if (copy && oldValue) {
          buffer.subData({
            data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
            offset: byteOffset
          });
        }
      }
      state.allocatedValue = value;
      state.constant = false;
      state.externalBuffer = null;
      state.bufferAccessor = this.settings;
      return true;
    }
    _checkExternalBuffer(opts) {
      const {
        value
      } = opts;
      if (!ArrayBuffer.isView(value)) {
        throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
      }
      const ArrayType = this.settings.defaultType;
      let illegalArrayType = false;
      if (this.doublePrecision) {
        illegalArrayType = value.BYTES_PER_ELEMENT < 4;
      }
      if (illegalArrayType) {
        throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
      }
      if (!(value instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
        log_default.warn("Attribute ".concat(this.id, " is normalized"))();
      }
    }
    normalizeConstant(value) {
      switch (this.settings.type) {
        case 5120:
          return new Float32Array(value).map((x2) => (x2 + 128) / 255 * 2 - 1);
        case 5122:
          return new Float32Array(value).map((x2) => (x2 + 32768) / 65535 * 2 - 1);
        case 5121:
          return new Float32Array(value).map((x2) => x2 / 255);
        case 5123:
          return new Float32Array(value).map((x2) => x2 / 65535);
        default:
          return value;
      }
    }
    _normalizeValue(value, out, start) {
      const {
        defaultValue,
        size
      } = this.settings;
      if (Number.isFinite(value)) {
        out[start] = value;
        return out;
      }
      if (!value) {
        let i2 = size;
        while (--i2 >= 0) {
          out[start + i2] = defaultValue[i2];
        }
        return out;
      }
      switch (size) {
        case 4:
          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];
        case 3:
          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];
        case 2:
          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];
        case 1:
          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
          break;
        default:
          let i2 = size;
          while (--i2 >= 0) {
            out[start + i2] = Number.isFinite(value[i2]) ? value[i2] : defaultValue[i2];
          }
      }
      return out;
    }
    _areValuesEqual(value1, value2) {
      if (!value1 || !value2) {
        return false;
      }
      const {
        size
      } = this;
      for (let i2 = 0; i2 < size; i2++) {
        if (value1[i2] !== value2[i2]) {
          return false;
        }
      }
      return true;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js
  var EMPTY_ARRAY = [];
  var placeholderArray = [];
  function createIterable(data, startRow = 0, endRow = Infinity) {
    let iterable = EMPTY_ARRAY;
    const objectInfo = {
      index: -1,
      data,
      target: []
    };
    if (!data) {
      iterable = EMPTY_ARRAY;
    } else if (typeof data[Symbol.iterator] === "function") {
      iterable = data;
    } else if (data.length > 0) {
      placeholderArray.length = data.length;
      iterable = placeholderArray;
    }
    if (startRow > 0 || Number.isFinite(endRow)) {
      iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
      objectInfo.index = startRow - 1;
    }
    return {
      iterable,
      objectInfo
    };
  }
  function isAsyncIterable2(data) {
    return data && data[Symbol.asyncIterator];
  }
  function getAccessorFromBuffer(typedArray, options) {
    const {
      size,
      stride,
      offset,
      startIndices,
      nested
    } = options;
    const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : size;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
    return (_2, {
      index,
      target
    }) => {
      if (!startIndices) {
        const sourceIndex = index * elementStride + elementOffset;
        for (let j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }
        return target;
      }
      const startIndex = startIndices[index];
      const endIndex = startIndices[index + 1] || vertexCount;
      let result;
      if (nested) {
        result = new Array(endIndex - startIndex);
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          const sourceIndex = i2 * elementStride + elementOffset;
          target = new Array(size);
          for (let j = 0; j < size; j++) {
            target[j] = typedArray[sourceIndex + j];
          }
          result[i2 - startIndex] = target;
        }
      } else if (elementStride === size) {
        result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
      } else {
        result = new typedArray.constructor((endIndex - startIndex) * size);
        let targetIndex = 0;
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          const sourceIndex = i2 * elementStride + elementOffset;
          for (let j = 0; j < size; j++) {
            result[targetIndex++] = typedArray[sourceIndex + j];
          }
        }
      }
      return result;
    };
  }

  // node_modules/@deck.gl/core/dist/esm/utils/range.js
  var EMPTY = [];
  var FULL = [[0, Infinity]];
  function add2(rangeList, range) {
    if (rangeList === FULL) {
      return rangeList;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    if (range[0] >= range[1]) {
      return rangeList;
    }
    const newRangeList = [];
    const len = rangeList.length;
    let insertPosition = 0;
    for (let i2 = 0; i2 < len; i2++) {
      const range0 = rangeList[i2];
      if (range0[1] < range[0]) {
        newRangeList.push(range0);
        insertPosition = i2 + 1;
      } else if (range0[0] > range[1]) {
        newRangeList.push(range0);
      } else {
        range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
      }
    }
    newRangeList.splice(insertPosition, 0, range);
    return newRangeList;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/array-utils.js
  function padArrayChunk(options) {
    const {
      source,
      target,
      start = 0,
      size,
      getData
    } = options;
    const end = options.end || target.length;
    const sourceLength = source.length;
    const targetLength = end - start;
    if (sourceLength > targetLength) {
      target.set(source.subarray(0, targetLength), start);
      return;
    }
    target.set(source, start);
    if (!getData) {
      return;
    }
    let i2 = sourceLength;
    while (i2 < targetLength) {
      const datum = getData(i2, source);
      for (let j = 0; j < size; j++) {
        target[start + i2] = datum[j] || 0;
        i2++;
      }
    }
  }
  function padArray({
    source,
    target,
    size,
    getData,
    sourceStartIndices,
    targetStartIndices
  }) {
    if (!Array.isArray(targetStartIndices)) {
      padArrayChunk({
        source,
        target,
        size,
        getData
      });
      return target;
    }
    let sourceIndex = 0;
    let targetIndex = 0;
    const getChunkData = getData && ((i2, chunk) => getData(i2 + targetIndex, chunk));
    const n2 = Math.min(sourceStartIndices.length, targetStartIndices.length);
    for (let i2 = 1; i2 < n2; i2++) {
      const nextSourceIndex = sourceStartIndices[i2] * size;
      const nextTargetIndex = targetStartIndices[i2] * size;
      padArrayChunk({
        source: source.subarray(sourceIndex, nextSourceIndex),
        target,
        start: targetIndex,
        end: nextTargetIndex,
        size,
        getData: getChunkData
      });
      sourceIndex = nextSourceIndex;
      targetIndex = nextTargetIndex;
    }
    if (targetIndex < target.length) {
      padArrayChunk({
        source: [],
        target,
        start: targetIndex,
        size,
        getData: getChunkData
      });
    }
    return target;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js
  var DEFAULT_TRANSITION_SETTINGS = {
    interpolation: {
      duration: 0,
      easing: (t2) => t2
    },
    spring: {
      stiffness: 0.05,
      damping: 0.5
    }
  };
  function normalizeTransitionSettings(userSettings, layerSettings) {
    if (!userSettings) {
      return null;
    }
    if (Number.isFinite(userSettings)) {
      userSettings = {
        type: "interpolation",
        duration: userSettings
      };
    }
    const type = userSettings.type || "interpolation";
    return {
      ...DEFAULT_TRANSITION_SETTINGS[type],
      ...layerSettings,
      ...userSettings,
      type
    };
  }
  function getSourceBufferAttribute(gl, attribute) {
    const buffer = attribute.getBuffer();
    if (buffer) {
      return [buffer, {
        divisor: 0,
        size: attribute.size,
        normalized: attribute.settings.normalized
      }];
    }
    return attribute.value;
  }
  function getAttributeTypeFromSize(size) {
    switch (size) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error('No defined attribute type for size "'.concat(size, '"'));
    }
  }
  function cycleBuffers(buffers) {
    buffers.push(buffers.shift());
  }
  function getAttributeBufferLength(attribute, numInstances) {
    const {
      doublePrecision,
      settings,
      value,
      size
    } = attribute;
    const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
    return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
  }
  function padBuffer({
    buffer,
    numInstances,
    attribute,
    fromLength,
    fromStartIndices,
    getData = (x2) => x2
  }) {
    const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
    const size = attribute.size * precisionMultiplier;
    const byteOffset = attribute.byteOffset;
    const toStartIndices = attribute.startIndices;
    const hasStartIndices = fromStartIndices && toStartIndices;
    const toLength = getAttributeBufferLength(attribute, numInstances);
    const isConstant = attribute.isConstant;
    if (!hasStartIndices && fromLength >= toLength) {
      return;
    }
    const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
      srcByteOffset: byteOffset
    });
    if (attribute.settings.normalized && !isConstant) {
      const getter = getData;
      getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
    }
    const getMissingData = isConstant ? (i2, chunk) => getData(toData, chunk) : (i2, chunk) => getData(toData.subarray(i2, i2 + size), chunk);
    const source = buffer.getData({
      length: fromLength
    });
    const data = new Float32Array(toLength);
    padArray({
      source,
      target: data,
      sourceStartIndices: fromStartIndices,
      targetStartIndices: toStartIndices,
      size,
      getData: getMissingData
    });
    if (buffer.byteLength < data.byteLength + byteOffset) {
      buffer.reallocate(data.byteLength + byteOffset);
    }
    buffer.subData({
      data,
      offset: byteOffset
    });
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js
  var Attribute = class extends DataColumn {
    constructor(gl, opts) {
      super(gl, opts, {
        startIndices: null,
        lastExternalBuffer: null,
        binaryValue: null,
        binaryAccessor: null,
        needsUpdate: true,
        needsRedraw: false,
        updateRanges: FULL
      });
      _defineProperty(this, "constant", false);
      this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
      Object.seal(this.settings);
      Object.seal(this.state);
      this._validateAttributeUpdaters();
    }
    get startIndices() {
      return this.state.startIndices;
    }
    set startIndices(layout) {
      this.state.startIndices = layout;
    }
    needsUpdate() {
      return this.state.needsUpdate;
    }
    needsRedraw({
      clearChangedFlags = false
    } = {}) {
      const needsRedraw = this.state.needsRedraw;
      this.state.needsRedraw = needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
    getUpdateTriggers() {
      const {
        accessor
      } = this.settings;
      return [this.id].concat(typeof accessor !== "function" && accessor || []);
    }
    supportsTransition() {
      return Boolean(this.settings.transition);
    }
    getTransitionSetting(opts) {
      if (!opts || !this.supportsTransition()) {
        return null;
      }
      const {
        accessor
      } = this.settings;
      const layerSettings = this.settings.transition;
      const userSettings = Array.isArray(accessor) ? opts[accessor.find((a2) => opts[a2])] : opts[accessor];
      return normalizeTransitionSettings(userSettings, layerSettings);
    }
    setNeedsUpdate(reason = this.id, dataRange) {
      this.state.needsUpdate = this.state.needsUpdate || reason;
      this.setNeedsRedraw(reason);
      if (dataRange) {
        const {
          startRow = 0,
          endRow = Infinity
        } = dataRange;
        this.state.updateRanges = add2(this.state.updateRanges, [startRow, endRow]);
      } else {
        this.state.updateRanges = FULL;
      }
    }
    clearNeedsUpdate() {
      this.state.needsUpdate = false;
      this.state.updateRanges = EMPTY;
    }
    setNeedsRedraw(reason = this.id) {
      this.state.needsRedraw = this.state.needsRedraw || reason;
    }
    allocate(numInstances) {
      const {
        state,
        settings
      } = this;
      if (settings.noAlloc) {
        return false;
      }
      if (settings.update) {
        super.allocate(numInstances, state.updateRanges !== FULL);
        return true;
      }
      return false;
    }
    updateBuffer({
      numInstances,
      data,
      props,
      context
    }) {
      if (!this.needsUpdate()) {
        return false;
      }
      const {
        state: {
          updateRanges
        },
        settings: {
          update,
          noAlloc
        }
      } = this;
      let updated = true;
      if (update) {
        for (const [startRow, endRow] of updateRanges) {
          update.call(context, this, {
            data,
            startRow,
            endRow,
            props,
            numInstances
          });
        }
        if (!this.value) {
        } else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
          this.setData({
            value: this.value,
            constant: this.constant
          });
          this.constant = false;
        } else {
          for (const [startRow, endRow] of updateRanges) {
            const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
            const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
            super.updateSubBuffer({
              startOffset,
              endOffset
            });
          }
        }
        this._checkAttributeArray();
      } else {
        updated = false;
      }
      this.clearNeedsUpdate();
      this.setNeedsRedraw();
      return updated;
    }
    setConstantValue(value) {
      if (value === void 0 || typeof value === "function") {
        return false;
      }
      const hasChanged = this.setData({
        constant: true,
        value
      });
      if (hasChanged) {
        this.setNeedsRedraw();
      }
      this.clearNeedsUpdate();
      return true;
    }
    setExternalBuffer(buffer) {
      const {
        state
      } = this;
      if (!buffer) {
        state.lastExternalBuffer = null;
        return false;
      }
      this.clearNeedsUpdate();
      if (state.lastExternalBuffer === buffer) {
        return true;
      }
      state.lastExternalBuffer = buffer;
      this.setNeedsRedraw();
      this.setData(buffer);
      return true;
    }
    setBinaryValue(buffer, startIndices = null) {
      const {
        state,
        settings
      } = this;
      if (!buffer) {
        state.binaryValue = null;
        state.binaryAccessor = null;
        return false;
      }
      if (settings.noAlloc) {
        return false;
      }
      if (state.binaryValue === buffer) {
        this.clearNeedsUpdate();
        return true;
      }
      state.binaryValue = buffer;
      this.setNeedsRedraw();
      const needsUpdate = settings.transform || startIndices !== this.startIndices;
      if (needsUpdate) {
        if (ArrayBuffer.isView(buffer)) {
          buffer = {
            value: buffer
          };
        }
        const binaryValue = buffer;
        assert10(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
        const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
        state.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
          size: binaryValue.size || this.size,
          stride: binaryValue.stride,
          offset: binaryValue.offset,
          startIndices,
          nested: needsNormalize
        });
        return false;
      }
      this.clearNeedsUpdate();
      this.setData(buffer);
      return true;
    }
    getVertexOffset(row) {
      const {
        startIndices
      } = this;
      const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
      return vertexIndex * this.size;
    }
    getShaderAttributes() {
      const shaderAttributeDefs = this.settings.shaderAttributes || {
        [this.id]: null
      };
      const shaderAttributes = {};
      for (const shaderAttributeName in shaderAttributeDefs) {
        Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
      }
      return shaderAttributes;
    }
    _autoUpdater(attribute, {
      data,
      startRow,
      endRow,
      props,
      numInstances
    }) {
      if (attribute.constant) {
        return;
      }
      const {
        settings,
        state,
        value,
        size,
        startIndices
      } = attribute;
      const {
        accessor,
        transform: transform2
      } = settings;
      const accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
      assert10(typeof accessorFunc === "function", 'accessor "'.concat(accessor, '" is not a function'));
      let i2 = attribute.getVertexOffset(startRow);
      const {
        iterable,
        objectInfo
      } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let objectValue = accessorFunc(object, objectInfo);
        if (transform2) {
          objectValue = transform2.call(this, objectValue);
        }
        if (startIndices) {
          const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
          if (objectValue && Array.isArray(objectValue[0])) {
            let startIndex = i2;
            for (const item of objectValue) {
              attribute._normalizeValue(item, value, startIndex);
              startIndex += size;
            }
          } else if (objectValue && objectValue.length > size) {
            value.set(objectValue, i2);
          } else {
            attribute._normalizeValue(objectValue, objectInfo.target, 0);
            fillArray2({
              target: value,
              source: objectInfo.target,
              start: i2,
              count: numVertices
            });
          }
          i2 += numVertices * size;
        } else {
          attribute._normalizeValue(objectValue, value, i2);
          i2 += size;
        }
      }
    }
    _validateAttributeUpdaters() {
      const {
        settings
      } = this;
      const hasUpdater = settings.noAlloc || typeof settings.update === "function";
      if (!hasUpdater) {
        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
      }
    }
    _checkAttributeArray() {
      const {
        value
      } = this;
      const limit = Math.min(4, this.size);
      if (value && value.length >= limit) {
        let valid = true;
        switch (limit) {
          case 4:
            valid = valid && Number.isFinite(value[3]);
          case 3:
            valid = valid && Number.isFinite(value[2]);
          case 2:
            valid = valid && Number.isFinite(value[1]);
          case 1:
            valid = valid && Number.isFinite(value[0]);
            break;
          default:
            valid = false;
        }
        if (!valid) {
          throw new Error("Illegal attribute generated for ".concat(this.id));
        }
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js
  var GPUInterpolationTransition = class {
    constructor({
      gl,
      attribute,
      timeline
    }) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "type", "interpolation");
      _defineProperty(this, "attributeInTransition", void 0);
      _defineProperty(this, "settings", void 0);
      _defineProperty(this, "attribute", void 0);
      _defineProperty(this, "transition", void 0);
      _defineProperty(this, "currentStartIndices", void 0);
      _defineProperty(this, "currentLength", void 0);
      _defineProperty(this, "transform", void 0);
      _defineProperty(this, "buffers", void 0);
      this.gl = gl;
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = new Attribute(gl, attribute.settings);
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = 0;
      this.transform = getTransform(gl, attribute);
      const bufferOpts = {
        byteLength: 0,
        usage: 35050
      };
      this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
      if (transitionSettings.duration <= 0) {
        this.transition.cancel();
        return;
      }
      this.settings = transitionSettings;
      const {
        gl,
        buffers,
        attribute
      } = this;
      cycleBuffers(buffers);
      const padBufferOpts = {
        numInstances,
        attribute,
        fromLength: this.currentLength,
        fromStartIndices: this.currentStartIndices,
        getData: transitionSettings.enter
      };
      for (const buffer of buffers) {
        padBuffer({
          buffer,
          ...padBufferOpts
        });
      }
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = getAttributeBufferLength(attribute, numInstances);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: attribute.value
      });
      this.transition.start(transitionSettings);
      this.transform.update({
        elementCount: Math.floor(this.currentLength / attribute.size),
        sourceBuffers: {
          aFrom: buffers[0],
          aTo: getSourceBufferAttribute(gl, attribute)
        },
        feedbackBuffers: {
          vCurrent: buffers[1]
        }
      });
    }
    update() {
      const updated = this.transition.update();
      if (updated) {
        const {
          duration,
          easing
        } = this.settings;
        const {
          time
        } = this.transition;
        let t2 = time / duration;
        if (easing) {
          t2 = easing(t2);
        }
        this.transform.run({
          uniforms: {
            time: t2
          }
        });
      }
      return updated;
    }
    cancel() {
      this.transition.cancel();
      this.transform.delete();
      for (const buffer of this.buffers) {
        buffer.delete();
      }
      this.buffers.length = 0;
    }
  };
  var vs6 = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
  function getTransform(gl, attribute) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    return new Transform(gl, {
      vs: vs6,
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vCurrent"]
    });
  }

  // node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js
  var GPUSpringTransition = class {
    constructor({
      gl,
      attribute,
      timeline
    }) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "type", "spring");
      _defineProperty(this, "attributeInTransition", void 0);
      _defineProperty(this, "settings", void 0);
      _defineProperty(this, "attribute", void 0);
      _defineProperty(this, "transition", void 0);
      _defineProperty(this, "currentStartIndices", void 0);
      _defineProperty(this, "currentLength", void 0);
      _defineProperty(this, "texture", void 0);
      _defineProperty(this, "framebuffer", void 0);
      _defineProperty(this, "transform", void 0);
      _defineProperty(this, "buffers", void 0);
      this.gl = gl;
      this.type = "spring";
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = new Attribute(gl, {
        ...attribute.settings,
        normalized: false
      });
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = 0;
      this.texture = getTexture(gl);
      this.framebuffer = getFramebuffer2(gl, this.texture);
      this.transform = getTransform2(gl, attribute, this.framebuffer);
      const bufferOpts = {
        byteLength: 0,
        usage: 35050
      };
      this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
      const {
        gl,
        buffers,
        attribute
      } = this;
      const padBufferOpts = {
        numInstances,
        attribute,
        fromLength: this.currentLength,
        fromStartIndices: this.currentStartIndices,
        getData: transitionSettings.enter
      };
      for (const buffer of buffers) {
        padBuffer({
          buffer,
          ...padBufferOpts
        });
      }
      this.settings = transitionSettings;
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = getAttributeBufferLength(attribute, numInstances);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: attribute.value
      });
      this.transition.start({
        ...transitionSettings,
        duration: Infinity
      });
      this.transform.update({
        elementCount: Math.floor(this.currentLength / attribute.size),
        sourceBuffers: {
          aTo: getSourceBufferAttribute(gl, attribute)
        }
      });
    }
    update() {
      const {
        buffers,
        transform: transform2,
        framebuffer,
        transition
      } = this;
      const updated = transition.update();
      if (!updated) {
        return false;
      }
      const settings = this.settings;
      transform2.update({
        sourceBuffers: {
          aPrev: buffers[0],
          aCur: buffers[1]
        },
        feedbackBuffers: {
          vNext: buffers[2]
        }
      });
      transform2.run({
        framebuffer,
        discard: false,
        clearRenderTarget: true,
        uniforms: {
          stiffness: settings.stiffness,
          damping: settings.damping
        },
        parameters: {
          depthTest: false,
          blend: true,
          viewport: [0, 0, 1, 1],
          blendFunc: [1, 1],
          blendEquation: [32776, 32776]
        }
      });
      cycleBuffers(buffers);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: this.attribute.value
      });
      const isTransitioning = readPixelsToArray(framebuffer)[0] > 0;
      if (!isTransitioning) {
        transition.end();
      }
      return true;
    }
    cancel() {
      this.transition.cancel();
      this.transform.delete();
      for (const buffer of this.buffers) {
        buffer.delete();
      }
      this.buffers.length = 0;
      this.texture.delete();
      this.framebuffer.delete();
    }
  };
  function getTransform2(gl, attribute, framebuffer) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    return new Transform(gl, {
      framebuffer,
      vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
      fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vNext"]
    });
  }
  function getTexture(gl) {
    return new Texture2D(gl, {
      data: new Uint8Array(4),
      format: 6408,
      type: 5121,
      border: 0,
      mipmaps: false,
      dataFormat: 6408,
      width: 1,
      height: 1
    });
  }
  function getFramebuffer2(gl, texture) {
    return new Framebuffer(gl, {
      id: "spring-transition-is-transitioning-framebuffer",
      width: 1,
      height: 1,
      attachments: {
        [36064]: texture
      }
    });
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js
  var TRANSITION_TYPES = {
    interpolation: GPUInterpolationTransition,
    spring: GPUSpringTransition
  };
  var AttributeTransitionManager = class {
    constructor(gl, {
      id,
      timeline
    }) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "isSupported", void 0);
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "timeline", void 0);
      _defineProperty(this, "transitions", void 0);
      _defineProperty(this, "needsRedraw", void 0);
      _defineProperty(this, "numInstances", void 0);
      this.id = id;
      this.gl = gl;
      this.timeline = timeline;
      this.transitions = {};
      this.needsRedraw = false;
      this.numInstances = 1;
      this.isSupported = Transform.isSupported(gl);
    }
    finalize() {
      for (const attributeName in this.transitions) {
        this._removeTransition(attributeName);
      }
    }
    update({
      attributes,
      transitions,
      numInstances
    }) {
      this.numInstances = numInstances || 1;
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const settings = attribute.getTransitionSetting(transitions);
        if (!settings)
          continue;
        this._updateAttribute(attributeName, attribute, settings);
      }
      for (const attributeName in this.transitions) {
        const attribute = attributes[attributeName];
        if (!attribute || !attribute.getTransitionSetting(transitions)) {
          this._removeTransition(attributeName);
        }
      }
    }
    hasAttribute(attributeName) {
      const transition = this.transitions[attributeName];
      return transition && transition.inProgress;
    }
    getAttributes() {
      const animatedAttributes = {};
      for (const attributeName in this.transitions) {
        const transition = this.transitions[attributeName];
        if (transition.inProgress) {
          animatedAttributes[attributeName] = transition.attributeInTransition;
        }
      }
      return animatedAttributes;
    }
    run() {
      if (!this.isSupported || this.numInstances === 0) {
        return false;
      }
      for (const attributeName in this.transitions) {
        const updated = this.transitions[attributeName].update();
        if (updated) {
          this.needsRedraw = true;
        }
      }
      const needsRedraw = this.needsRedraw;
      this.needsRedraw = false;
      return needsRedraw;
    }
    _removeTransition(attributeName) {
      this.transitions[attributeName].cancel();
      delete this.transitions[attributeName];
    }
    _updateAttribute(attributeName, attribute, settings) {
      const transition = this.transitions[attributeName];
      let isNew = !transition || transition.type !== settings.type;
      if (isNew) {
        if (!this.isSupported) {
          log_default.warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
          return;
        }
        if (transition) {
          this._removeTransition(attributeName);
        }
        const TransitionType = TRANSITION_TYPES[settings.type];
        if (TransitionType) {
          this.transitions[attributeName] = new TransitionType({
            attribute,
            timeline: this.timeline,
            gl: this.gl
          });
        } else {
          log_default.error("unsupported transition type '".concat(settings.type, "'"))();
          isNew = false;
        }
      }
      if (isNew || attribute.needsRedraw()) {
        this.needsRedraw = true;
        this.transitions[attributeName].start(settings, this.numInstances);
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js
  var TRACE_INVALIDATE = "attributeManager.invalidate";
  var TRACE_UPDATE_START = "attributeManager.updateStart";
  var TRACE_UPDATE_END = "attributeManager.updateEnd";
  var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
  var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
  var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
  var AttributeManager = class {
    constructor(gl, {
      id = "attribute-manager",
      stats,
      timeline
    } = {}) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "attributes", void 0);
      _defineProperty(this, "updateTriggers", void 0);
      _defineProperty(this, "needsRedraw", void 0);
      _defineProperty(this, "userData", void 0);
      _defineProperty(this, "stats", void 0);
      _defineProperty(this, "attributeTransitionManager", void 0);
      _defineProperty(this, "mergeBoundsMemoized", memoize(mergeBounds));
      this.id = id;
      this.gl = gl;
      this.attributes = {};
      this.updateTriggers = {};
      this.needsRedraw = true;
      this.userData = {};
      this.stats = stats;
      this.attributeTransitionManager = new AttributeTransitionManager(gl, {
        id: "".concat(id, "-transitions"),
        timeline
      });
      Object.seal(this);
    }
    finalize() {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }
      this.attributeTransitionManager.finalize();
    }
    getNeedsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
      return redraw && this.id;
    }
    setNeedsRedraw() {
      this.needsRedraw = true;
    }
    add(attributes) {
      this._add(attributes);
    }
    addInstanced(attributes) {
      this._add(attributes, {
        instanced: 1
      });
    }
    remove(attributeNameArray) {
      for (const name of attributeNameArray) {
        if (this.attributes[name] !== void 0) {
          this.attributes[name].delete();
          delete this.attributes[name];
        }
      }
    }
    invalidate(triggerName, dataRange) {
      const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
      debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
    }
    invalidateAll(dataRange) {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
      }
      debug(TRACE_INVALIDATE, this, "all");
    }
    update({
      data,
      numInstances,
      startIndices = null,
      transitions,
      props = {},
      buffers = {},
      context = {}
    }) {
      let updated = false;
      debug(TRACE_UPDATE_START, this);
      if (this.stats) {
        this.stats.get("Update Attributes").timeStart();
      }
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        const accessorName = attribute.settings.accessor;
        attribute.startIndices = startIndices;
        attribute.numInstances = numInstances;
        if (props[attributeName]) {
          log_default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
        }
        if (attribute.setExternalBuffer(buffers[attributeName])) {
        } else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) {
        } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
        } else if (attribute.needsUpdate()) {
          updated = true;
          this._updateAttribute({
            attribute,
            numInstances,
            data,
            props,
            context
          });
        }
        this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
      }
      if (updated) {
        debug(TRACE_UPDATE_END, this, numInstances);
      }
      if (this.stats) {
        this.stats.get("Update Attributes").timeEnd();
      }
      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances,
        transitions
      });
    }
    updateTransition() {
      const {
        attributeTransitionManager
      } = this;
      const transitionUpdated = attributeTransitionManager.run();
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
    getAttributes() {
      return this.attributes;
    }
    getBounds(attributeNames) {
      const bounds = attributeNames.map((attributeName) => {
        var _this$attributes$attr;
        return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();
      });
      return this.mergeBoundsMemoized(bounds);
    }
    getChangedAttributes(opts = {
      clearChangedFlags: false
    }) {
      const {
        attributes,
        attributeTransitionManager
      } = this;
      const changedAttributes = {
        ...attributeTransitionManager.getAttributes()
      };
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }
    getShaderAttributes(attributes, excludeAttributes = {}) {
      if (!attributes) {
        attributes = this.getAttributes();
      }
      const shaderAttributes = {};
      for (const attributeName in attributes) {
        if (!excludeAttributes[attributeName]) {
          Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
        }
      }
      return shaderAttributes;
    }
    _add(attributes, extraProps = {}) {
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
      }
      this._mapUpdateTriggersToAttributes();
    }
    _createAttribute(name, attribute, extraProps) {
      const props = {
        ...attribute,
        id: name,
        size: attribute.isIndexed && 1 || attribute.size || 1,
        divisor: extraProps.instanced ? 1 : attribute.divisor || 0
      };
      return new Attribute(this.gl, props);
    }
    _mapUpdateTriggersToAttributes() {
      const triggers = {};
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach((triggerName) => {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }
          triggers[triggerName].push(attributeName);
        });
      }
      this.updateTriggers = triggers;
    }
    _invalidateTrigger(triggerName, dataRange) {
      const {
        attributes,
        updateTriggers
      } = this;
      const invalidatedAttributes = updateTriggers[triggerName];
      if (invalidatedAttributes) {
        invalidatedAttributes.forEach((name) => {
          const attribute = attributes[name];
          if (attribute) {
            attribute.setNeedsUpdate(attribute.id, dataRange);
          }
        });
      }
      return invalidatedAttributes;
    }
    _updateAttribute(opts) {
      const {
        attribute,
        numInstances
      } = opts;
      debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
      if (attribute.constant) {
        attribute.setConstantValue(attribute.value);
        return;
      }
      if (attribute.allocate(numInstances)) {
        debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
      }
      const updated = attribute.updateBuffer(opts);
      if (updated) {
        this.needsRedraw = true;
        debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js
  var CPUInterpolationTransition = class extends Transition {
    get value() {
      return this._value;
    }
    _onUpdate() {
      const {
        time,
        settings: {
          fromValue,
          toValue,
          duration,
          easing
        }
      } = this;
      const t2 = easing(time / duration);
      this._value = lerp(fromValue, toValue, t2);
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js
  var EPSILON2 = 1e-5;
  function updateSpringElement(prev, cur, dest, damping, stiffness) {
    const velocity = cur - prev;
    const delta = dest - cur;
    const spring = delta * stiffness;
    const damper = -velocity * damping;
    return spring + damper + velocity + cur;
  }
  function updateSpring(prev, cur, dest, damping, stiffness) {
    if (Array.isArray(dest)) {
      const next = [];
      for (let i2 = 0; i2 < dest.length; i2++) {
        next[i2] = updateSpringElement(prev[i2], cur[i2], dest[i2], damping, stiffness);
      }
      return next;
    }
    return updateSpringElement(prev, cur, dest, damping, stiffness);
  }
  function distance(value1, value2) {
    if (Array.isArray(value1)) {
      let distanceSquare = 0;
      for (let i2 = 0; i2 < value1.length; i2++) {
        const d2 = value1[i2] - value2[i2];
        distanceSquare += d2 * d2;
      }
      return Math.sqrt(distanceSquare);
    }
    return Math.abs(value1 - value2);
  }
  var CPUSpringTransition = class extends Transition {
    get value() {
      return this._currValue;
    }
    _onUpdate() {
      const {
        fromValue,
        toValue,
        damping,
        stiffness
      } = this.settings;
      const {
        _prevValue = fromValue,
        _currValue = fromValue
      } = this;
      let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
      const delta = distance(nextValue, toValue);
      const velocity = distance(nextValue, _currValue);
      if (delta < EPSILON2 && velocity < EPSILON2) {
        nextValue = toValue;
        this.end();
      }
      this._prevValue = _currValue;
      this._currValue = nextValue;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js
  var TRANSITION_TYPES2 = {
    interpolation: CPUInterpolationTransition,
    spring: CPUSpringTransition
  };
  var UniformTransitionManager = class {
    constructor(timeline) {
      this.transitions = /* @__PURE__ */ new Map();
      this.timeline = timeline;
    }
    get active() {
      return this.transitions.size > 0;
    }
    add(key, fromValue, toValue, settings) {
      const {
        transitions
      } = this;
      if (transitions.has(key)) {
        const transition2 = transitions.get(key);
        const {
          value = transition2.settings.fromValue
        } = transition2;
        fromValue = value;
        this.remove(key);
      }
      settings = normalizeTransitionSettings(settings);
      if (!settings) {
        return;
      }
      const TransitionType = TRANSITION_TYPES2[settings.type];
      if (!TransitionType) {
        log_default.error("unsupported transition type '".concat(settings.type, "'"))();
        return;
      }
      const transition = new TransitionType(this.timeline);
      transition.start({
        ...settings,
        fromValue,
        toValue
      });
      transitions.set(key, transition);
    }
    remove(key) {
      const {
        transitions
      } = this;
      if (transitions.has(key)) {
        transitions.get(key).cancel();
        transitions.delete(key);
      }
    }
    update() {
      const propsInTransition = {};
      for (const [key, transition] of this.transitions) {
        transition.update();
        propsInTransition[key] = transition.value;
        if (!transition.inProgress) {
          this.remove(key);
        }
      }
      return propsInTransition;
    }
    clear() {
      for (const key of this.transitions.keys()) {
        this.remove(key);
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lifecycle/props.js
  function validateProps(props) {
    const propTypes = props[PROP_TYPES_SYMBOL];
    for (const propName in propTypes) {
      const propType = propTypes[propName];
      const {
        validate
      } = propType;
      if (validate && !validate(props[propName], propType)) {
        throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
      }
    }
  }
  function diffProps(props, oldProps) {
    const propsChangedReason = compareProps({
      newProps: props,
      oldProps,
      propTypes: props[PROP_TYPES_SYMBOL],
      ignoreProps: {
        data: null,
        updateTriggers: null,
        extensions: null,
        transitions: null
      }
    });
    const dataChangedReason = diffDataProps(props, oldProps);
    let updateTriggersChangedReason = false;
    if (!dataChangedReason) {
      updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
    }
    return {
      dataChanged: dataChangedReason,
      propsChanged: propsChangedReason,
      updateTriggersChanged: updateTriggersChangedReason,
      extensionsChanged: diffExtensions(props, oldProps),
      transitionsChanged: diffTransitions(props, oldProps)
    };
  }
  function diffTransitions(props, oldProps) {
    if (!props.transitions) {
      return false;
    }
    const result = {};
    const propTypes = props[PROP_TYPES_SYMBOL];
    let changed = false;
    for (const key in props.transitions) {
      const propType = propTypes[key];
      const type = propType && propType.type;
      const isTransitionable = type === "number" || type === "color" || type === "array";
      if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
        result[key] = true;
        changed = true;
      }
    }
    return changed ? result : false;
  }
  function compareProps({
    newProps,
    oldProps,
    ignoreProps = {},
    propTypes = {},
    triggerName = "props"
  }) {
    if (oldProps === newProps) {
      return false;
    }
    if (typeof newProps !== "object" || newProps === null) {
      return "".concat(triggerName, " changed shallowly");
    }
    if (typeof oldProps !== "object" || oldProps === null) {
      return "".concat(triggerName, " changed shallowly");
    }
    for (const key of Object.keys(newProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in oldProps)) {
          return "".concat(triggerName, ".").concat(key, " added");
        }
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
    for (const key of Object.keys(oldProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in newProps)) {
          return "".concat(triggerName, ".").concat(key, " dropped");
        }
        if (!Object.hasOwnProperty.call(newProps, key)) {
          const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
          if (changed) {
            return "".concat(triggerName, ".").concat(key, " ").concat(changed);
          }
        }
      }
    }
    return false;
  }
  function comparePropValues(newProp, oldProp, propType) {
    let equal = propType && propType.equal;
    if (equal && !equal(newProp, oldProp, propType)) {
      return "changed deeply";
    }
    if (!equal) {
      equal = newProp && oldProp && newProp.equals;
      if (equal && !equal.call(newProp, oldProp)) {
        return "changed deeply";
      }
    }
    if (!equal && oldProp !== newProp) {
      return "changed shallowly";
    }
    return null;
  }
  function diffDataProps(props, oldProps) {
    if (oldProps === null) {
      return "oldProps is null, initial diff";
    }
    let dataChanged = false;
    const {
      dataComparator,
      _dataDiff
    } = props;
    if (dataComparator) {
      if (!dataComparator(props.data, oldProps.data)) {
        dataChanged = "Data comparator detected a change";
      }
    } else if (props.data !== oldProps.data) {
      dataChanged = "A new data container was supplied";
    }
    if (dataChanged && _dataDiff) {
      dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
    }
    return dataChanged;
  }
  function diffUpdateTriggers(props, oldProps) {
    if (oldProps === null) {
      return {
        all: true
      };
    }
    if ("all" in props.updateTriggers) {
      const diffReason = diffUpdateTrigger(props, oldProps, "all");
      if (diffReason) {
        return {
          all: true
        };
      }
    }
    const reason = {};
    let changed = false;
    for (const triggerName in props.updateTriggers) {
      if (triggerName !== "all") {
        const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
        if (diffReason) {
          reason[triggerName] = true;
          changed = true;
        }
      }
    }
    return changed ? reason : false;
  }
  function diffExtensions(props, oldProps) {
    if (oldProps === null) {
      return true;
    }
    const oldExtensions = oldProps.extensions;
    const {
      extensions
    } = props;
    if (extensions === oldExtensions) {
      return false;
    }
    if (!oldExtensions || !extensions) {
      return true;
    }
    if (extensions.length !== oldExtensions.length) {
      return true;
    }
    for (let i2 = 0; i2 < extensions.length; i2++) {
      if (!extensions[i2].equals(oldExtensions[i2])) {
        return true;
      }
    }
    return false;
  }
  function diffUpdateTrigger(props, oldProps, triggerName) {
    let newTriggers = props.updateTriggers[triggerName];
    newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
    let oldTriggers = oldProps.updateTriggers[triggerName];
    oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
    const diffReason = compareProps({
      oldProps: oldTriggers,
      newProps: newTriggers,
      triggerName
    });
    return diffReason;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/count.js
  var ERR_NOT_OBJECT = "count(): argument not an object";
  var ERR_NOT_CONTAINER = "count(): argument not a container";
  function count(container) {
    if (!isObject2(container)) {
      throw new Error(ERR_NOT_OBJECT);
    }
    if (typeof container.count === "function") {
      return container.count();
    }
    if (Number.isFinite(container.size)) {
      return container.size;
    }
    if (Number.isFinite(container.length)) {
      return container.length;
    }
    if (isPlainObject(container)) {
      return Object.keys(container).length;
    }
    throw new Error(ERR_NOT_CONTAINER);
  }
  function isPlainObject(value) {
    return value !== null && typeof value === "object" && value.constructor === Object;
  }
  function isObject2(value) {
    return value !== null && typeof value === "object";
  }

  // node_modules/@deck.gl/core/dist/esm/utils/shader.js
  function mergeShaders(target, source) {
    if (!source) {
      return target;
    }
    const result = {
      ...target,
      ...source
    };
    if ("defines" in source) {
      result.defines = {
        ...target.defines,
        ...source.defines
      };
    }
    if ("modules" in source) {
      result.modules = (target.modules || []).concat(source.modules);
      if (source.modules.some((module) => module.name === "project64")) {
        const index = result.modules.findIndex((module) => module.name === "project32");
        if (index >= 0) {
          result.modules.splice(index, 1);
        }
      }
    }
    if ("inject" in source) {
      if (!target.inject) {
        result.inject = source.inject;
      } else {
        const mergedInjection = {
          ...target.inject
        };
        for (const key in source.inject) {
          mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
        }
        result.inject = mergedInjection;
      }
    }
    return result;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/texture.js
  var DEFAULT_TEXTURE_PARAMETERS = {
    [10241]: 9987,
    [10240]: 9729,
    [10242]: 33071,
    [10243]: 33071
  };
  var internalTextures = {};
  function createTexture(owner, gl, image, parameters) {
    if (image instanceof Texture2D) {
      return image;
    } else if (image.constructor && image.constructor.name !== "Object") {
      image = {
        data: image
      };
    }
    let specialTextureParameters = null;
    if (image.compressed) {
      specialTextureParameters = {
        [10241]: image.data.length > 1 ? 9985 : 9729
      };
    }
    const texture = new Texture2D(gl, {
      ...image,
      parameters: {
        ...DEFAULT_TEXTURE_PARAMETERS,
        ...specialTextureParameters,
        ...parameters
      }
    });
    internalTextures[texture.id] = owner;
    return texture;
  }
  function destroyTexture(owner, texture) {
    if (!texture || !(texture instanceof Texture2D)) {
      return;
    }
    if (internalTextures[texture.id] === owner) {
      texture.delete();
      delete internalTextures[texture.id];
    }
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js
  var TYPE_DEFINITIONS2 = {
    boolean: {
      validate(value, propType) {
        return true;
      },
      equal(value1, value2, propType) {
        return Boolean(value1) === Boolean(value2);
      }
    },
    number: {
      validate(value, propType) {
        return Number.isFinite(value) && (!("max" in propType) || value <= propType.max) && (!("min" in propType) || value >= propType.min);
      }
    },
    color: {
      validate(value, propType) {
        return propType.optional && !value || isArray3(value) && (value.length === 3 || value.length === 4);
      },
      equal(value1, value2, propType) {
        return deepEqual(value1, value2, 1);
      }
    },
    accessor: {
      validate(value, propType) {
        const valueType = getTypeOf2(value);
        return valueType === "function" || valueType === getTypeOf2(propType.value);
      },
      equal(value1, value2, propType) {
        if (typeof value2 === "function") {
          return true;
        }
        return deepEqual(value1, value2, 1);
      }
    },
    array: {
      validate(value, propType) {
        return propType.optional && !value || isArray3(value);
      },
      equal(value1, value2, propType) {
        const {
          compare
        } = propType;
        const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
        return compare ? deepEqual(value1, value2, depth) : value1 === value2;
      }
    },
    object: {
      equal(value1, value2, propType) {
        if (propType.ignore) {
          return true;
        }
        const {
          compare
        } = propType;
        const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
        return compare ? deepEqual(value1, value2, depth) : value1 === value2;
      }
    },
    function: {
      validate(value, propType) {
        return propType.optional && !value || typeof value === "function";
      },
      equal(value1, value2, propType) {
        const shouldIgnore = !propType.compare && propType.ignore !== false;
        return shouldIgnore || value1 === value2;
      }
    },
    data: {
      transform: (value, propType, component) => {
        const {
          dataTransform
        } = component.props;
        return dataTransform && value ? dataTransform(value) : value;
      }
    },
    image: {
      transform: (value, propType, component) => {
        const context = component.context;
        if (!context || !context.gl) {
          return null;
        }
        return createTexture(component.id, context.gl, value, {
          ...propType.parameters,
          ...component.props.textureParameters
        });
      },
      release: (value, propType, component) => {
        destroyTexture(component.id, value);
      }
    }
  };
  function parsePropTypes2(propDefs) {
    const propTypes = {};
    const defaultProps5 = {};
    const deprecatedProps = {};
    for (const [propName, propDef] of Object.entries(propDefs)) {
      const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;
      if (deprecated) {
        deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
      } else {
        const propType = parsePropType2(propName, propDef);
        propTypes[propName] = propType;
        defaultProps5[propName] = propType.value;
      }
    }
    return {
      propTypes,
      defaultProps: defaultProps5,
      deprecatedProps
    };
  }
  function parsePropType2(name, propDef) {
    switch (getTypeOf2(propDef)) {
      case "object":
        return normalizePropDefinition(name, propDef);
      case "array":
        return normalizePropDefinition(name, {
          type: "array",
          value: propDef,
          compare: false
        });
      case "boolean":
        return normalizePropDefinition(name, {
          type: "boolean",
          value: propDef
        });
      case "number":
        return normalizePropDefinition(name, {
          type: "number",
          value: propDef
        });
      case "function":
        return normalizePropDefinition(name, {
          type: "function",
          value: propDef,
          compare: true
        });
      default:
        return {
          name,
          type: "unknown",
          value: propDef
        };
    }
  }
  function normalizePropDefinition(name, propDef) {
    if (!("type" in propDef)) {
      if (!("value" in propDef)) {
        return {
          name,
          type: "object",
          value: propDef
        };
      }
      return {
        name,
        type: getTypeOf2(propDef.value),
        ...propDef
      };
    }
    return {
      name,
      ...TYPE_DEFINITIONS2[propDef.type],
      ...propDef
    };
  }
  function isArray3(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value);
  }
  function getTypeOf2(value) {
    if (isArray3(value)) {
      return "array";
    }
    if (value === null) {
      return "null";
    }
    return typeof value;
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js
  function createProps(component, propObjects) {
    let extensions;
    for (let i2 = propObjects.length - 1; i2 >= 0; i2--) {
      const props = propObjects[i2];
      if ("extensions" in props) {
        extensions = props.extensions;
      }
    }
    const propsPrototype = getPropsPrototype(component.constructor, extensions);
    const propsInstance = Object.create(propsPrototype);
    propsInstance[COMPONENT_SYMBOL] = component;
    propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
    propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
    for (let i2 = 0; i2 < propObjects.length; ++i2) {
      const props = propObjects[i2];
      for (const key in props) {
        propsInstance[key] = props[key];
      }
    }
    Object.freeze(propsInstance);
    return propsInstance;
  }
  var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
  function getPropsPrototype(componentClass, extensions) {
    let cacheKey = MergedDefaultPropsCacheKey;
    if (extensions) {
      for (const extension of extensions) {
        const ExtensionClass = extension.constructor;
        if (ExtensionClass) {
          cacheKey += ":".concat(ExtensionClass.extensionName || ExtensionClass.name);
        }
      }
    }
    const defaultProps5 = getOwnProperty(componentClass, cacheKey);
    if (!defaultProps5) {
      return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
    }
    return defaultProps5;
  }
  function createPropsPrototypeAndTypes(componentClass, extensions) {
    const parent = componentClass.prototype;
    if (!parent) {
      return null;
    }
    const parentClass = Object.getPrototypeOf(componentClass);
    const parentDefaultProps = getPropsPrototype(parentClass);
    const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
    const componentPropDefs = parsePropTypes2(componentDefaultProps);
    const defaultProps5 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
    const propTypes = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
    const deprecatedProps = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
    for (const extension of extensions) {
      const extensionDefaultProps = getPropsPrototype(extension.constructor);
      if (extensionDefaultProps) {
        Object.assign(defaultProps5, extensionDefaultProps);
        Object.assign(propTypes, extensionDefaultProps[PROP_TYPES_SYMBOL]);
        Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
      }
    }
    createPropsPrototype(defaultProps5, componentClass);
    addAsyncPropsToPropPrototype(defaultProps5, propTypes);
    addDeprecatedPropsToPropPrototype(defaultProps5, deprecatedProps);
    defaultProps5[PROP_TYPES_SYMBOL] = propTypes;
    defaultProps5[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
    if (extensions.length === 0 && !hasOwnProperty(componentClass, "_propTypes")) {
      componentClass._propTypes = propTypes;
    }
    return defaultProps5;
  }
  function createPropsPrototype(defaultProps5, componentClass) {
    const id = getComponentName(componentClass);
    Object.defineProperties(defaultProps5, {
      id: {
        writable: true,
        value: id
      }
    });
  }
  function addDeprecatedPropsToPropPrototype(defaultProps5, deprecatedProps) {
    for (const propName in deprecatedProps) {
      Object.defineProperty(defaultProps5, propName, {
        enumerable: false,
        set(newValue) {
          const nameStr = "".concat(this.id, ": ").concat(propName);
          for (const newPropName of deprecatedProps[propName]) {
            if (!hasOwnProperty(this, newPropName)) {
              this[newPropName] = newValue;
            }
          }
          log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
        }
      });
    }
  }
  function addAsyncPropsToPropPrototype(defaultProps5, propTypes) {
    const defaultValues = {};
    const descriptors = {};
    for (const propName in propTypes) {
      const propType = propTypes[propName];
      const {
        name,
        value
      } = propType;
      if (propType.async) {
        defaultValues[name] = value;
        descriptors[name] = getDescriptorForAsyncProp(name);
      }
    }
    defaultProps5[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
    defaultProps5[ASYNC_ORIGINAL_SYMBOL] = {};
    Object.defineProperties(defaultProps5, descriptors);
  }
  function getDescriptorForAsyncProp(name) {
    return {
      enumerable: true,
      set(newValue) {
        if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
          this[ASYNC_ORIGINAL_SYMBOL][name] = newValue;
        } else {
          this[ASYNC_RESOLVED_SYMBOL][name] = newValue;
        }
      },
      get() {
        if (this[ASYNC_RESOLVED_SYMBOL]) {
          if (name in this[ASYNC_RESOLVED_SYMBOL]) {
            const value = this[ASYNC_RESOLVED_SYMBOL][name];
            return value || this[ASYNC_DEFAULTS_SYMBOL][name];
          }
          if (name in this[ASYNC_ORIGINAL_SYMBOL]) {
            const state = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
            if (state && state.hasAsyncProp(name)) {
              return state.getAsyncProp(name) || this[ASYNC_DEFAULTS_SYMBOL][name];
            }
          }
        }
        return this[ASYNC_DEFAULTS_SYMBOL][name];
      }
    };
  }
  function hasOwnProperty(object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
  }
  function getOwnProperty(object, prop) {
    return hasOwnProperty(object, prop) && object[prop];
  }
  function getComponentName(componentClass) {
    const componentName = componentClass.componentName;
    if (!componentName) {
      log_default.warn("".concat(componentClass.name, ".componentName not specified"))();
    }
    return componentName || componentClass.name;
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/component.js
  var counter = 0;
  var Component = class {
    constructor(...propObjects) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "count", void 0);
      this.props = createProps(this, propObjects);
      this.id = this.props.id;
      this.count = counter++;
    }
    clone(newProps) {
      const {
        props
      } = this;
      const asyncProps = {};
      for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
        if (key in props[ASYNC_RESOLVED_SYMBOL]) {
          asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
        } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
          asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
        }
      }
      return new this.constructor({
        ...props,
        ...asyncProps,
        ...newProps
      });
    }
  };
  _defineProperty(Component, "componentName", "Component");
  _defineProperty(Component, "defaultProps", {});

  // node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js
  var EMPTY_PROPS = Object.freeze({});
  var ComponentState = class {
    constructor(component) {
      _defineProperty(this, "component", void 0);
      _defineProperty(this, "onAsyncPropUpdated", void 0);
      _defineProperty(this, "asyncProps", void 0);
      _defineProperty(this, "oldProps", void 0);
      _defineProperty(this, "oldAsyncProps", void 0);
      this.component = component;
      this.asyncProps = {};
      this.onAsyncPropUpdated = () => {
      };
      this.oldProps = null;
      this.oldAsyncProps = null;
    }
    finalize() {
      for (const propName in this.asyncProps) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp && asyncProp.type && asyncProp.type.release) {
          asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
        }
      }
      this.asyncProps = {};
      this.component = null;
      this.resetOldProps();
    }
    getOldProps() {
      return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
    }
    resetOldProps() {
      this.oldAsyncProps = null;
      this.oldProps = this.component ? this.component.props : null;
    }
    hasAsyncProp(propName) {
      return propName in this.asyncProps;
    }
    getAsyncProp(propName) {
      const asyncProp = this.asyncProps[propName];
      return asyncProp && asyncProp.resolvedValue;
    }
    isAsyncPropLoading(propName) {
      if (propName) {
        const asyncProp = this.asyncProps[propName];
        return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
      }
      for (const key in this.asyncProps) {
        if (this.isAsyncPropLoading(key)) {
          return true;
        }
      }
      return false;
    }
    reloadAsyncProp(propName, value) {
      this._watchPromise(propName, Promise.resolve(value));
    }
    setAsyncProps(props) {
      this.component = props[COMPONENT_SYMBOL] || this.component;
      const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
      const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
      const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
      for (const propName in resolvedValues) {
        const value = resolvedValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value);
        resolvedValues[propName] = this.getAsyncProp(propName);
      }
      for (const propName in originalValues) {
        const value = originalValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value);
      }
    }
    _fetch(propName, url) {
      return null;
    }
    _onResolve(propName, value) {
    }
    _onError(propName, error2) {
    }
    _updateAsyncProp(propName, value) {
      if (!this._didAsyncInputValueChange(propName, value)) {
        return;
      }
      if (typeof value === "string") {
        value = this._fetch(propName, value);
      }
      if (value instanceof Promise) {
        this._watchPromise(propName, value);
        return;
      }
      if (isAsyncIterable2(value)) {
        this._resolveAsyncIterable(propName, value);
        return;
      }
      this._setPropValue(propName, value);
    }
    _freezeAsyncOldProps() {
      if (!this.oldAsyncProps && this.oldProps) {
        this.oldAsyncProps = Object.create(this.oldProps);
        for (const propName in this.asyncProps) {
          Object.defineProperty(this.oldAsyncProps, propName, {
            enumerable: true,
            value: this.oldProps[propName]
          });
        }
      }
    }
    _didAsyncInputValueChange(propName, value) {
      const asyncProp = this.asyncProps[propName];
      if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
        return false;
      }
      asyncProp.lastValue = value;
      return true;
    }
    _setPropValue(propName, value) {
      this._freezeAsyncOldProps();
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        value = this._postProcessValue(asyncProp, value);
        asyncProp.resolvedValue = value;
        asyncProp.pendingLoadCount++;
        asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
      }
    }
    _setAsyncPropValue(propName, value, loadCount) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== void 0) {
        this._freezeAsyncOldProps();
        asyncProp.resolvedValue = value;
        asyncProp.resolvedLoadCount = loadCount;
        this.onAsyncPropUpdated(propName, value);
      }
    }
    _watchPromise(propName, promise) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        asyncProp.pendingLoadCount++;
        const loadCount = asyncProp.pendingLoadCount;
        promise.then((data) => {
          if (!this.component) {
            return;
          }
          data = this._postProcessValue(asyncProp, data);
          this._setAsyncPropValue(propName, data, loadCount);
          this._onResolve(propName, data);
        }).catch((error2) => {
          this._onError(propName, error2);
        });
      }
    }
    async _resolveAsyncIterable(propName, iterable) {
      if (propName !== "data") {
        this._setPropValue(propName, iterable);
        return;
      }
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        return;
      }
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      let data = [];
      let count2 = 0;
      for await (const chunk of iterable) {
        if (!this.component) {
          return;
        }
        const {
          dataTransform
        } = this.component.props;
        if (dataTransform) {
          data = dataTransform(chunk, data);
        } else {
          data = data.concat(chunk);
        }
        Object.defineProperty(data, "__diff", {
          enumerable: false,
          value: [{
            startRow: count2,
            endRow: data.length
          }]
        });
        count2 = data.length;
        this._setAsyncPropValue(propName, data, loadCount);
      }
      this._onResolve(propName, data);
    }
    _postProcessValue(asyncProp, value) {
      const propType = asyncProp.type;
      if (propType && this.component) {
        if (propType.release) {
          propType.release(asyncProp.resolvedValue, propType, this.component);
        }
        if (propType.transform) {
          return propType.transform(value, propType, this.component);
        }
      }
      return value;
    }
    _createAsyncPropData(propName, defaultValue) {
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        const propTypes = this.component && this.component.props[PROP_TYPES_SYMBOL];
        this.asyncProps[propName] = {
          type: propTypes && propTypes[propName],
          lastValue: null,
          resolvedValue: defaultValue,
          pendingLoadCount: 0,
          resolvedLoadCount: 0
        };
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/layer-state.js
  var LayerState = class extends ComponentState {
    constructor({
      attributeManager,
      layer
    }) {
      super(layer);
      _defineProperty(this, "attributeManager", void 0);
      _defineProperty(this, "needsRedraw", void 0);
      _defineProperty(this, "needsUpdate", void 0);
      _defineProperty(this, "subLayers", void 0);
      _defineProperty(this, "usesPickingColorCache", void 0);
      _defineProperty(this, "hasPickingBuffer", void 0);
      _defineProperty(this, "changeFlags", void 0);
      _defineProperty(this, "viewport", void 0);
      _defineProperty(this, "uniformTransitions", void 0);
      _defineProperty(this, "propsInTransition", void 0);
      this.attributeManager = attributeManager;
      this.needsRedraw = true;
      this.needsUpdate = true;
      this.subLayers = null;
      this.usesPickingColorCache = false;
    }
    get layer() {
      return this.component;
    }
    _fetch(propName, url) {
      const layer = this.layer;
      const fetch2 = layer === null || layer === void 0 ? void 0 : layer.props.fetch;
      if (fetch2) {
        return fetch2(url, {
          propName,
          layer
        });
      }
      return super._fetch(propName, url);
    }
    _onResolve(propName, value) {
      const layer = this.layer;
      if (layer) {
        const onDataLoad = layer.props.onDataLoad;
        if (propName === "data" && onDataLoad) {
          onDataLoad(value, {
            propName,
            layer
          });
        }
      }
    }
    _onError(propName, error2) {
      const layer = this.layer;
      if (layer) {
        layer.raiseError(error2, "loading ".concat(propName, " of ").concat(this.layer));
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/layer.js
  var TRACE_CHANGE_FLAG = "layer.changeFlag";
  var TRACE_INITIALIZE = "layer.initialize";
  var TRACE_UPDATE = "layer.update";
  var TRACE_FINALIZE = "layer.finalize";
  var TRACE_MATCHED = "layer.matched";
  var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
  var EMPTY_ARRAY2 = Object.freeze([]);
  var areViewportsEqual = memoize(({
    oldViewport,
    viewport
  }) => {
    return oldViewport.equals(viewport);
  });
  var pickingColorCache = new Uint8ClampedArray(0);
  var defaultProps2 = {
    data: {
      type: "data",
      value: EMPTY_ARRAY2,
      async: true
    },
    dataComparator: {
      type: "function",
      value: null,
      optional: true
    },
    _dataDiff: {
      type: "function",
      value: (data) => data && data.__diff,
      optional: true
    },
    dataTransform: {
      type: "function",
      value: null,
      optional: true
    },
    onDataLoad: {
      type: "function",
      value: null,
      optional: true
    },
    onError: {
      type: "function",
      value: null,
      optional: true
    },
    fetch: {
      type: "function",
      value: (url, {
        propName,
        layer,
        loaders,
        loadOptions,
        signal
      }) => {
        const {
          resourceManager
        } = layer.context;
        loadOptions = loadOptions || layer.getLoadOptions();
        loaders = loaders || layer.props.loaders;
        if (signal) {
          var _loadOptions;
          loadOptions = {
            ...loadOptions,
            fetch: {
              ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch,
              signal
            }
          };
        }
        let inResourceManager = resourceManager.contains(url);
        if (!inResourceManager && !loadOptions) {
          resourceManager.add({
            resourceId: url,
            data: load(url, loaders),
            persistent: false
          });
          inResourceManager = true;
        }
        if (inResourceManager) {
          return resourceManager.subscribe({
            resourceId: url,
            onChange: (data) => {
              var _layer$internalState;
              return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);
            },
            consumerId: layer.id,
            requestId: propName
          });
        }
        return load(url, loaders, loadOptions);
      }
    },
    updateTriggers: {},
    visible: true,
    pickable: false,
    opacity: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    operation: "draw",
    onHover: {
      type: "function",
      value: null,
      optional: true
    },
    onClick: {
      type: "function",
      value: null,
      optional: true
    },
    onDragStart: {
      type: "function",
      value: null,
      optional: true
    },
    onDrag: {
      type: "function",
      value: null,
      optional: true
    },
    onDragEnd: {
      type: "function",
      value: null,
      optional: true
    },
    coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin: {
      type: "array",
      value: [0, 0, 0],
      compare: true
    },
    modelMatrix: {
      type: "array",
      value: null,
      compare: true,
      optional: true
    },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: {
      type: "object",
      value: {},
      optional: true,
      compare: 2
    },
    loadOptions: {
      type: "object",
      value: null,
      optional: true,
      ignore: true
    },
    transitions: null,
    extensions: [],
    loaders: {
      type: "array",
      value: [],
      optional: true,
      ignore: true
    },
    getPolygonOffset: {
      type: "function",
      value: ({
        layerIndex
      }) => [0, -layerIndex * 100]
    },
    highlightedObjectIndex: null,
    autoHighlight: false,
    highlightColor: {
      type: "accessor",
      value: [0, 0, 128, 128]
    }
  };
  var Layer = class extends Component {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "internalState", null);
      _defineProperty(this, "lifecycle", LIFECYCLE.NO_STATE);
      _defineProperty(this, "context", void 0);
      _defineProperty(this, "state", void 0);
      _defineProperty(this, "parent", null);
    }
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
    }
    get root() {
      let layer = this;
      while (layer.parent) {
        layer = layer.parent;
      }
      return layer;
    }
    toString() {
      const className = this.constructor.layerName || this.constructor.name;
      return "".concat(className, "({id: '").concat(this.props.id, "'})");
    }
    project(xyz) {
      assert10(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      const worldPosition = getWorldPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });
      const [x2, y2, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
      return xyz.length === 2 ? [x2, y2] : [x2, y2, z];
    }
    unproject(xy) {
      assert10(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return viewport.unproject(xy);
    }
    projectPosition(xyz, params) {
      assert10(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return projectPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem,
        ...params
      });
    }
    get isComposite() {
      return false;
    }
    setState(partialState) {
      this.setChangeFlags({
        stateChanged: true
      });
      Object.assign(this.state, partialState);
      this.setNeedsRedraw();
    }
    setNeedsRedraw() {
      if (this.internalState) {
        this.internalState.needsRedraw = true;
      }
    }
    setNeedsUpdate() {
      if (this.internalState) {
        this.context.layerManager.setNeedsUpdate(String(this));
        this.internalState.needsUpdate = true;
      }
    }
    get isLoaded() {
      return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
    }
    get wrapLongitude() {
      return this.props.wrapLongitude;
    }
    isPickable() {
      return this.props.pickable && this.props.visible;
    }
    getModels() {
      return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
    }
    setModuleParameters(moduleParameters) {
      for (const model of this.getModels()) {
        model.updateModuleSettings(moduleParameters);
      }
    }
    getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
    getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
    getLoadOptions() {
      return this.props.loadOptions;
    }
    use64bitPositions() {
      const {
        coordinateSystem
      } = this.props;
      return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
    }
    onHover(info, pickingEvent) {
      if (this.props.onHover) {
        return this.props.onHover(info, pickingEvent) || false;
      }
      return false;
    }
    onClick(info, pickingEvent) {
      if (this.props.onClick) {
        return this.props.onClick(info, pickingEvent) || false;
      }
      return false;
    }
    nullPickingColor() {
      return [0, 0, 0];
    }
    encodePickingColor(i2, target = []) {
      target[0] = i2 + 1 & 255;
      target[1] = i2 + 1 >> 8 & 255;
      target[2] = i2 + 1 >> 8 >> 8 & 255;
      return target;
    }
    decodePickingColor(color) {
      assert10(color instanceof Uint8Array);
      const [i1, i2, i3] = color;
      const index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
    getNumInstances() {
      if (Number.isFinite(this.props.numInstances)) {
        return this.props.numInstances;
      }
      if (this.state && this.state.numInstances !== void 0) {
        return this.state.numInstances;
      }
      return count(this.props.data);
    }
    getStartIndices() {
      if (this.props.startIndices) {
        return this.props.startIndices;
      }
      if (this.state && this.state.startIndices) {
        return this.state.startIndices;
      }
      return null;
    }
    getBounds() {
      var _this$getAttributeMan;
      return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(["positions", "instancePositions"]);
    }
    getShaders(shaders) {
      for (const extension of this.props.extensions) {
        shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
      }
      return shaders;
    }
    shouldUpdateState(params) {
      return params.changeFlags.propsOrDataChanged;
    }
    updateState(params) {
      const attributeManager = this.getAttributeManager();
      const {
        dataChanged
      } = params.changeFlags;
      if (dataChanged && attributeManager) {
        if (Array.isArray(dataChanged)) {
          for (const dataRange of dataChanged) {
            attributeManager.invalidateAll(dataRange);
          }
        } else {
          attributeManager.invalidateAll();
        }
      }
      if (attributeManager) {
        const {
          props
        } = params;
        const hasPickingBuffer = this.internalState.hasPickingBuffer;
        const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
        if (hasPickingBuffer !== needsPickingBuffer) {
          this.internalState.hasPickingBuffer = needsPickingBuffer;
          const {
            pickingColors,
            instancePickingColors
          } = attributeManager.attributes;
          const pickingColorsAttribute = pickingColors || instancePickingColors;
          if (pickingColorsAttribute) {
            if (needsPickingBuffer && pickingColorsAttribute.constant) {
              pickingColorsAttribute.constant = false;
              attributeManager.invalidate(pickingColorsAttribute.id);
            }
            if (!pickingColorsAttribute.value && !needsPickingBuffer) {
              pickingColorsAttribute.constant = true;
              pickingColorsAttribute.value = [0, 0, 0];
            }
          }
        }
      }
    }
    finalizeState(context) {
      for (const model of this.getModels()) {
        model.delete();
      }
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.finalize();
      }
      if (this.context) {
        this.context.resourceManager.unsubscribe({
          consumerId: this.id
        });
      }
      if (this.internalState) {
        this.internalState.uniformTransitions.clear();
        this.internalState.finalize();
      }
    }
    draw(opts) {
      for (const model of this.getModels()) {
        model.draw(opts);
      }
    }
    getPickingInfo({
      info,
      mode,
      sourceLayer
    }) {
      const {
        index
      } = info;
      if (index >= 0) {
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }
      return info;
    }
    raiseError(error2, message) {
      var _this$props$onError, _this$props;
      if (message) {
        error2 = new Error("".concat(message, ": ").concat(error2.message), {
          cause: error2
        });
      }
      if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error2))) {
        var _this$context, _this$context$onError;
        (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error2, this);
      }
    }
    getNeedsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      return this._getNeedsRedraw(opts);
    }
    needsUpdate() {
      if (!this.internalState) {
        return false;
      }
      return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
    }
    hasUniformTransition() {
      var _this$internalState;
      return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
    }
    activateViewport(viewport) {
      if (!this.internalState) {
        return;
      }
      const oldViewport = this.internalState.viewport;
      this.internalState.viewport = viewport;
      if (!oldViewport || !areViewportsEqual({
        oldViewport,
        viewport
      })) {
        this.setChangeFlags({
          viewportChanged: true
        });
        if (this.isComposite) {
          if (this.needsUpdate()) {
            this.setNeedsUpdate();
          }
        } else {
          this._update();
        }
      }
    }
    invalidateAttribute(name = "all") {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      if (name === "all") {
        attributeManager.invalidateAll();
      } else {
        attributeManager.invalidate(name);
      }
    }
    updateAttributes(changedAttributes) {
      for (const model of this.getModels()) {
        this._setModelAttributes(model, changedAttributes);
      }
    }
    _updateAttributes() {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      const props = this.props;
      const numInstances = this.getNumInstances();
      const startIndices = this.getStartIndices();
      attributeManager.update({
        data: props.data,
        numInstances,
        startIndices,
        props,
        transitions: props.transitions,
        buffers: props.data.attributes,
        context: this
      });
      const changedAttributes = attributeManager.getChangedAttributes({
        clearChangedFlags: true
      });
      this.updateAttributes(changedAttributes);
    }
    _updateAttributeTransition() {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.updateTransition();
      }
    }
    _updateUniformTransition() {
      const {
        uniformTransitions
      } = this.internalState;
      if (uniformTransitions.active) {
        const propsInTransition = uniformTransitions.update();
        const props = Object.create(this.props);
        for (const key in propsInTransition) {
          Object.defineProperty(props, key, {
            value: propsInTransition[key]
          });
        }
        return props;
      }
      return this.props;
    }
    calculateInstancePickingColors(attribute, {
      numInstances
    }) {
      if (attribute.constant) {
        return;
      }
      const cacheSize = Math.floor(pickingColorCache.length / 3);
      this.internalState.usesPickingColorCache = true;
      if (cacheSize < numInstances) {
        if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
          log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
        }
        pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
          size: 3,
          copy: true,
          maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
        });
        const newCacheSize = Math.floor(pickingColorCache.length / 3);
        const pickingColor = [];
        for (let i2 = cacheSize; i2 < newCacheSize; i2++) {
          this.encodePickingColor(i2, pickingColor);
          pickingColorCache[i2 * 3 + 0] = pickingColor[0];
          pickingColorCache[i2 * 3 + 1] = pickingColor[1];
          pickingColorCache[i2 * 3 + 2] = pickingColor[2];
        }
      }
      attribute.value = pickingColorCache.subarray(0, numInstances * 3);
    }
    _setModelAttributes(model, changedAttributes) {
      const attributeManager = this.getAttributeManager();
      const excludeAttributes = model.userData.excludeAttributes || {};
      const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
      model.setAttributes(shaderAttributes);
    }
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (!("attributes" in data)) {
        this._disablePickingIndex(objectIndex);
        return;
      }
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
      if (externalColorAttribute && externalColorAttribute.value) {
        const values = externalColorAttribute.value;
        const objectColor = this.encodePickingColor(objectIndex);
        for (let index = 0; index < data.length; index++) {
          const i2 = colors.getVertexOffset(index);
          if (values[i2] === objectColor[0] && values[i2 + 1] === objectColor[1] && values[i2 + 2] === objectColor[2]) {
            this._disablePickingIndex(index);
          }
        }
      } else {
        this._disablePickingIndex(objectIndex);
      }
    }
    _disablePickingIndex(objectIndex) {
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      const start = colors.getVertexOffset(objectIndex);
      const end = colors.getVertexOffset(objectIndex + 1);
      colors.buffer.subData({
        data: new Uint8Array(end - start),
        offset: start
      });
    }
    restorePickingColors() {
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
        colors.value = pickingColorCache.subarray(0, colors.value.length);
      }
      colors.updateSubBuffer({
        startOffset: 0
      });
    }
    _initialize() {
      assert10(!this.internalState);
      assert10(Number.isFinite(this.props.coordinateSystem));
      debug(TRACE_INITIALIZE, this);
      const attributeManager = this._getAttributeManager();
      if (attributeManager) {
        attributeManager.addInstanced({
          instancePickingColors: {
            type: 5121,
            size: 3,
            noAlloc: true,
            update: this.calculateInstancePickingColors
          }
        });
      }
      this.internalState = new LayerState({
        attributeManager,
        layer: this
      });
      this._clearChangeFlags();
      this.state = {};
      Object.defineProperty(this.state, "attributeManager", {
        get: () => {
          log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
          return attributeManager;
        }
      });
      this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
      this.internalState.setAsyncProps(this.props);
      this.initializeState(this.context);
      for (const extension of this.props.extensions) {
        extension.initializeState.call(this, this.context, extension);
      }
      this.setChangeFlags({
        dataChanged: "init",
        propsChanged: "init",
        viewportChanged: true,
        extensionsChanged: true
      });
      this._update();
    }
    _transferState(oldLayer) {
      debug(TRACE_MATCHED, this, this === oldLayer);
      const {
        state,
        internalState
      } = oldLayer;
      if (this === oldLayer) {
        return;
      }
      this.internalState = internalState;
      this.state = state;
      this.internalState.setAsyncProps(this.props);
      this._diffProps(this.props, this.internalState.getOldProps());
    }
    _update() {
      const stateNeedsUpdate = this.needsUpdate();
      debug(TRACE_UPDATE, this, stateNeedsUpdate);
      if (!stateNeedsUpdate) {
        return;
      }
      const currentProps = this.props;
      const context = this.context;
      const internalState = this.internalState;
      const currentViewport = context.viewport;
      const propsInTransition = this._updateUniformTransition();
      internalState.propsInTransition = propsInTransition;
      context.viewport = internalState.viewport || currentViewport;
      this.props = propsInTransition;
      try {
        const updateParams = this._getUpdateParams();
        const oldModels = this.getModels();
        if (context.gl) {
          this.updateState(updateParams);
        } else {
          try {
            this.updateState(updateParams);
          } catch (error2) {
          }
        }
        for (const extension of this.props.extensions) {
          extension.updateState.call(this, updateParams, extension);
        }
        const modelChanged = this.getModels()[0] !== oldModels[0];
        this._postUpdate(updateParams, modelChanged);
      } finally {
        context.viewport = currentViewport;
        this.props = currentProps;
        this._clearChangeFlags();
        internalState.needsUpdate = false;
        internalState.resetOldProps();
      }
    }
    _finalize() {
      debug(TRACE_FINALIZE, this);
      this.finalizeState(this.context);
      for (const extension of this.props.extensions) {
        extension.finalizeState.call(this, this.context, extension);
      }
    }
    _drawLayer({
      moduleParameters = null,
      uniforms = {},
      parameters = {}
    }) {
      this._updateAttributeTransition();
      const currentProps = this.props;
      const context = this.context;
      this.props = this.internalState.propsInTransition || currentProps;
      const opacity = this.props.opacity;
      uniforms.opacity = Math.pow(opacity, 1 / 2.2);
      try {
        if (moduleParameters) {
          this.setModuleParameters(moduleParameters);
        }
        const {
          getPolygonOffset
        } = this.props;
        const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
        setParameters(context.gl, {
          polygonOffset: offsets
        });
        withParameters(context.gl, parameters, () => {
          const opts = {
            moduleParameters,
            uniforms,
            parameters,
            context
          };
          for (const extension of this.props.extensions) {
            extension.draw.call(this, opts, extension);
          }
          this.draw(opts);
        });
      } finally {
        this.props = currentProps;
      }
    }
    getChangeFlags() {
      var _this$internalState2;
      return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
    }
    setChangeFlags(flags) {
      if (!this.internalState) {
        return;
      }
      const {
        changeFlags
      } = this.internalState;
      for (const key in flags) {
        if (flags[key]) {
          let flagChanged = false;
          switch (key) {
            case "dataChanged":
              const dataChangedReason = flags[key];
              const prevDataChangedReason = changeFlags[key];
              if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
                changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
                flagChanged = true;
              }
            default:
              if (!changeFlags[key]) {
                changeFlags[key] = flags[key];
                flagChanged = true;
              }
          }
          if (flagChanged) {
            debug(TRACE_CHANGE_FLAG, this, key, flags);
          }
        }
      }
      const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
      changeFlags.propsOrDataChanged = propsOrDataChanged;
      changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
    }
    _clearChangeFlags() {
      this.internalState.changeFlags = {
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        extensionsChanged: false,
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
    _diffProps(newProps, oldProps) {
      const changeFlags = diffProps(newProps, oldProps);
      if (changeFlags.updateTriggersChanged) {
        for (const key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this.invalidateAttribute(key);
          }
        }
      }
      if (changeFlags.transitionsChanged) {
        for (const key in changeFlags.transitionsChanged) {
          var _newProps$transitions;
          this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
        }
      }
      return this.setChangeFlags(changeFlags);
    }
    validateProps() {
      validateProps(this.props);
    }
    updateAutoHighlight(info) {
      if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
        this._updateAutoHighlight(info);
      }
    }
    _updateAutoHighlight(info) {
      const pickingModuleParameters = {
        pickingSelectedColor: info.picked ? info.color : null
      };
      const {
        highlightColor
      } = this.props;
      if (info.picked && typeof highlightColor === "function") {
        pickingModuleParameters.pickingHighlightColor = highlightColor(info);
      }
      this.setModuleParameters(pickingModuleParameters);
      this.setNeedsRedraw();
    }
    _getAttributeManager() {
      const context = this.context;
      return new AttributeManager(context.gl, {
        id: this.props.id,
        stats: context.stats,
        timeline: context.timeline
      });
    }
    _postUpdate(updateParams, forceUpdate) {
      const {
        props,
        oldProps
      } = updateParams;
      this.setNeedsRedraw();
      this._updateAttributes();
      const {
        model
      } = this.state;
      model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());
      const {
        autoHighlight,
        highlightedObjectIndex,
        highlightColor
      } = props;
      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
        const parameters = {};
        if (!autoHighlight) {
          parameters.pickingSelectedColor = null;
        }
        if (Array.isArray(highlightColor)) {
          parameters.pickingHighlightColor = highlightColor;
        }
        if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
          parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
        }
        this.setModuleParameters(parameters);
      }
    }
    _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        changeFlags: this.internalState.changeFlags
      };
    }
    _getNeedsRedraw(opts) {
      if (!this.internalState) {
        return false;
      }
      let redraw = false;
      redraw = redraw || this.internalState.needsRedraw && this.id;
      const attributeManager = this.getAttributeManager();
      const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
      redraw = redraw || attributeManagerNeedsRedraw;
      if (redraw) {
        for (const extension of this.props.extensions) {
          extension.onNeedsRedraw.call(this, extension);
        }
      }
      this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
      return redraw;
    }
    _onAsyncPropUpdated() {
      this._diffProps(this.props, this.internalState.getOldProps());
      this.setNeedsUpdate();
    }
  };
  _defineProperty(Layer, "defaultProps", defaultProps2);
  _defineProperty(Layer, "layerName", "Layer");

  // node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js
  var DEGREES_TO_RADIANS5 = Math.PI / 180;
  function getViewMatrix2({
    height,
    focalDistance,
    orbitAxis,
    rotationX,
    rotationOrbit,
    zoom
  }) {
    const up = orbitAxis === "Z" ? [0, 0, 1] : [0, 1, 0];
    const eye = orbitAxis === "Z" ? [0, -focalDistance, 0] : [0, 0, focalDistance];
    const viewMatrix = new Matrix4().lookAt({
      eye,
      up
    });
    viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS5);
    if (orbitAxis === "Z") {
      viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS5);
    } else {
      viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS5);
    }
    const projectionScale = Math.pow(2, zoom) / height;
    viewMatrix.scale(projectionScale);
    return viewMatrix;
  }
  var OrbitViewport = class extends Viewport {
    constructor(props) {
      const {
        height,
        projectionMatrix,
        fovy = 50,
        orbitAxis = "Z",
        target = [0, 0, 0],
        rotationX = 0,
        rotationOrbit = 0,
        zoom = 0
      } = props;
      const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : fovyToAltitude(fovy);
      super({
        ...props,
        longitude: void 0,
        viewMatrix: getViewMatrix2({
          height: height || 1,
          focalDistance,
          orbitAxis,
          rotationX,
          rotationOrbit,
          zoom
        }),
        fovy,
        focalDistance,
        position: target,
        zoom
      });
      _defineProperty(this, "projectedCenter", void 0);
      this.projectedCenter = this.project(this.center);
    }
    unproject(xyz, {
      topLeft = true
    } = {}) {
      const [x2, y2, z = this.projectedCenter[2]] = xyz;
      const y22 = topLeft ? y2 : this.height - y2;
      const [X, Y, Z] = pixelsToWorld([x2, y22, z], this.pixelUnprojectionMatrix);
      return [X, Y, Z];
    }
    panByPosition(coords, pixel) {
      const p0 = this.project(coords);
      const nextCenter = [this.width / 2 + p0[0] - pixel[0], this.height / 2 + p0[1] - pixel[1], this.projectedCenter[2]];
      return {
        target: this.unproject(nextCenter)
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js
  var OrbitState = class extends ViewState {
    constructor(options) {
      const {
        width,
        height,
        rotationX = 0,
        rotationOrbit = 0,
        target = [0, 0, 0],
        zoom = 0,
        minRotationX = -90,
        maxRotationX = 90,
        minZoom = -Infinity,
        maxZoom = Infinity,
        startPanPosition,
        startRotatePos,
        startRotationX,
        startRotationOrbit,
        startZoomPosition,
        startZoom
      } = options;
      super({
        width,
        height,
        rotationX,
        rotationOrbit,
        target,
        zoom,
        minRotationX,
        maxRotationX,
        minZoom,
        maxZoom
      }, {
        startPanPosition,
        startRotatePos,
        startRotationX,
        startRotationOrbit,
        startZoomPosition,
        startZoom
      });
      _defineProperty(this, "makeViewport", void 0);
      this.makeViewport = options.makeViewport;
    }
    panStart({
      pos
    }) {
      return this._getUpdatedState({
        startPanPosition: this._unproject(pos)
      });
    }
    pan({
      pos,
      startPosition
    }) {
      const startPanPosition = this.getState().startPanPosition || startPosition;
      if (!startPanPosition) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanPosition, pos);
      return this._getUpdatedState(newProps);
    }
    panEnd() {
      return this._getUpdatedState({
        startPanPosition: null
      });
    }
    rotateStart({
      pos
    }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startRotationX: this.getViewportProps().rotationX,
        startRotationOrbit: this.getViewportProps().rotationOrbit
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const {
        startRotatePos,
        startRotationX,
        startRotationOrbit
      } = this.getState();
      const {
        width,
        height
      } = this.getViewportProps();
      if (!startRotatePos || startRotationX === void 0 || startRotationOrbit === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
        const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
        if (startRotationX < -90 || startRotationX > 90) {
          deltaScaleX *= -1;
        }
        newRotation = {
          rotationX: startRotationX + deltaScaleY * 180,
          rotationOrbit: startRotationOrbit + deltaScaleX * 180
        };
      } else {
        newRotation = {
          rotationX: startRotationX + deltaAngleY,
          rotationOrbit: startRotationOrbit + deltaAngleX
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startRotationX: null,
        startRotationOrbit: null
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = {
        ...this.getViewportProps()
      };
      const {
        rotationOrbit
      } = props;
      if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
        props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
      }
      return props;
    }
    zoomStart({
      pos
    }) {
      return this._getUpdatedState({
        startZoomPosition: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    zoom({
      pos,
      startPos,
      scale: scale3
    }) {
      let {
        startZoom,
        startZoomPosition
      } = this.getState();
      if (!startZoomPosition) {
        startZoom = this.getViewportProps().zoom;
        startZoomPosition = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomPosition) {
        return this;
      }
      const newZoom = this._calculateNewZoom({
        scale: scale3,
        startZoom
      });
      const zoomedViewport = this.makeViewport({
        ...this.getViewportProps(),
        zoom: newZoom
      });
      return this._getUpdatedState({
        zoom: newZoom,
        ...zoomedViewport.panByPosition(startZoomPosition, pos)
      });
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomPosition: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({
          scale: speed
        })
      });
    }
    zoomOut(speed = 2) {
      return this._getUpdatedState({
        zoom: this._calculateNewZoom({
          scale: 1 / speed
        })
      });
    }
    moveLeft(speed = 50) {
      return this._panFromCenter([-speed, 0]);
    }
    moveRight(speed = 50) {
      return this._panFromCenter([speed, 0]);
    }
    moveUp(speed = 50) {
      return this._panFromCenter([0, -speed]);
    }
    moveDown(speed = 50) {
      return this._panFromCenter([0, speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        rotationOrbit: this.getViewportProps().rotationOrbit - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        rotationOrbit: this.getViewportProps().rotationOrbit + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        rotationX: this.getViewportProps().rotationX - speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        rotationX: this.getViewportProps().rotationX + speed
      });
    }
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    _calculateNewZoom({
      scale: scale3,
      startZoom
    }) {
      const {
        maxZoom,
        minZoom
      } = this.getViewportProps();
      if (startZoom === void 0) {
        startZoom = this.getViewportProps().zoom;
      }
      const zoom = startZoom + Math.log2(scale3);
      return clamp(zoom, minZoom, maxZoom);
    }
    _panFromCenter(offset) {
      const {
        width,
        height,
        target
      } = this.getViewportProps();
      return this.pan({
        startPosition: target,
        pos: [width / 2 + offset[0], height / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    applyConstraints(props) {
      const {
        maxZoom,
        minZoom,
        zoom,
        maxRotationX,
        minRotationX,
        rotationOrbit
      } = props;
      props.zoom = Array.isArray(zoom) ? [clamp(zoom[0], minZoom, maxZoom), clamp(zoom[1], minZoom, maxZoom)] : clamp(zoom, minZoom, maxZoom);
      props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
      if (rotationOrbit < -180 || rotationOrbit > 180) {
        props.rotationOrbit = mod2(rotationOrbit + 180, 360) - 180;
      }
      return props;
    }
  };
  var OrbitController = class extends Controller {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ControllerState", OrbitState);
      _defineProperty(this, "transition", {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator({
          transitionProps: {
            compare: ["target", "zoom", "rotationX", "rotationOrbit"],
            required: ["target", "zoom"]
          }
        })
      });
    }
  };

  // node_modules/@deck.gl/core/dist/esm/views/orbit-view.js
  var OrbitView = class extends View {
    constructor(props = {}) {
      super(props);
      this.props.orbitAxis = props.orbitAxis || "Z";
    }
    get ViewportType() {
      return OrbitViewport;
    }
    get ControllerType() {
      return OrbitController;
    }
  };
  _defineProperty(OrbitView, "displayName", "OrbitView");

  // node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js
  var line_layer_vertex_glsl_default = "#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t = (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  vec3 source_world = instanceSourcePositions;\n  vec3 target_world = instanceTargetPositions;\n  vec3 source_world_64low = instanceSourcePositions64Low;\n  vec3 target_world_64low = instanceTargetPositions64Low;\n\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng = target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath > 180.) {\n      source_world.x += 360. * useShortestPath;\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low = vec3(0.0);\n    } else if (deltaLng * useShortestPath < -180.) {\n      target_world.x += 360. * useShortestPath;\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low = vec3(0.0);\n    } else if (useShortestPath < 0.) {\n      gl_Position = vec4(0.);\n      return;\n    }\n  }\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(p, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js
  var line_layer_fragment_glsl_default = "#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js
  var DEFAULT_COLOR = [0, 0, 0, 255];
  var defaultProps3 = {
    getSourcePosition: {
      type: "accessor",
      value: (x2) => x2.sourcePosition
    },
    getTargetPosition: {
      type: "accessor",
      value: (x2) => x2.targetPosition
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR
    },
    getWidth: {
      type: "accessor",
      value: 1
    },
    widthUnits: "pixels",
    widthScale: {
      type: "number",
      value: 1,
      min: 0
    },
    widthMinPixels: {
      type: "number",
      value: 0,
      min: 0
    },
    widthMaxPixels: {
      type: "number",
      value: Number.MAX_SAFE_INTEGER,
      min: 0
    }
  };
  var LineLayer = class extends Layer {
    getBounds() {
      var _this$getAttributeMan;
      return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(["instanceSourcePositions", "instanceTargetPositions"]);
    }
    getShaders() {
      return super.getShaders({
        vs: line_layer_vertex_glsl_default,
        fs: line_layer_fragment_glsl_default,
        modules: [project32_default, picking_default]
      });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceSourcePositions: {
          size: 3,
          type: 5130,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getSourcePosition"
        },
        instanceTargetPositions: {
          size: 3,
          type: 5130,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getTargetPosition"
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: 5121,
          normalized: true,
          transition: true,
          accessor: "getColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceWidths: {
          size: 1,
          transition: true,
          accessor: "getWidth",
          defaultValue: 1
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      if (params.changeFlags.extensionsChanged) {
        var _this$state$model;
        const {
          gl
        } = this.context;
        (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
        this.state.model = this._getModel(gl);
        this.getAttributeManager().invalidateAll();
      }
    }
    draw({
      uniforms
    }) {
      const {
        widthUnits,
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        wrapLongitude
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        widthUnits: UNIT[widthUnits],
        widthScale,
        widthMinPixels,
        widthMaxPixels,
        useShortestPath: wrapLongitude ? 1 : 0
      }).draw();
      if (wrapLongitude) {
        this.state.model.setUniforms({
          useShortestPath: -1
        }).draw();
      }
    }
    _getModel(gl) {
      const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: 5,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true
      });
    }
  };
  _defineProperty(LineLayer, "layerName", "LineLayer");
  _defineProperty(LineLayer, "defaultProps", defaultProps3);

  // node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js
  var point_cloud_layer_vertex_glsl_default = "#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js
  var point_cloud_layer_fragment_glsl_default = "#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js
  var DEFAULT_COLOR2 = [0, 0, 0, 255];
  var DEFAULT_NORMAL = [0, 0, 1];
  var defaultProps4 = {
    sizeUnits: "pixels",
    pointSize: {
      type: "number",
      min: 0,
      value: 10
    },
    getPosition: {
      type: "accessor",
      value: (x2) => x2.position
    },
    getNormal: {
      type: "accessor",
      value: DEFAULT_NORMAL
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR2
    },
    material: true,
    radiusPixels: {
      deprecatedFor: "pointSize"
    }
  };
  function normalizeData(data) {
    const {
      header,
      attributes
    } = data;
    if (!header || !attributes) {
      return;
    }
    data.length = header.vertexCount;
    if (attributes.POSITION) {
      attributes.instancePositions = attributes.POSITION;
    }
    if (attributes.NORMAL) {
      attributes.instanceNormals = attributes.NORMAL;
    }
    if (attributes.COLOR_0) {
      attributes.instanceColors = attributes.COLOR_0;
    }
  }
  var PointCloudLayer = class extends Layer {
    getShaders() {
      return super.getShaders({
        vs: point_cloud_layer_vertex_glsl_default,
        fs: point_cloud_layer_fragment_glsl_default,
        modules: [project32_default, gouraudLighting, picking_default]
      });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: 5130,
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceNormals: {
          size: 3,
          transition: true,
          accessor: "getNormal",
          defaultValue: DEFAULT_NORMAL
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: 5121,
          normalized: true,
          transition: true,
          accessor: "getColor",
          defaultValue: DEFAULT_COLOR2
        }
      });
    }
    updateState(params) {
      const {
        changeFlags,
        props
      } = params;
      super.updateState(params);
      if (changeFlags.extensionsChanged) {
        var _this$state$model;
        const {
          gl
        } = this.context;
        (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
        this.state.model = this._getModel(gl);
        this.getAttributeManager().invalidateAll();
      }
      if (changeFlags.dataChanged) {
        normalizeData(props.data);
      }
    }
    draw({
      uniforms
    }) {
      const {
        pointSize,
        sizeUnits
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        sizeUnits: UNIT[sizeUnits],
        radiusPixels: pointSize
      }).draw();
    }
    _getModel(gl) {
      const positions = [];
      for (let i2 = 0; i2 < 3; i2++) {
        const angle2 = i2 / 3 * Math.PI * 2;
        positions.push(Math.cos(angle2) * 2, Math.sin(angle2) * 2, 0);
      }
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: 4,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true
      });
    }
  };
  _defineProperty(PointCloudLayer, "layerName", "PointCloudLayer");
  _defineProperty(PointCloudLayer, "defaultProps", defaultProps4);

  // node_modules/@deck.gl/carto/dist/esm/style/palette.js
  var cartoColors = __toESM(require_cartocolor2());

  // node_modules/@deck.gl/carto/dist/esm/style/utils.js
  var ALLOWED_ATTR_TYPES = Object.freeze(["function", "string"]);
  function getAttrValue(attr, d2) {
    var _properties;
    assert11(typeof d2 === "object", 'Expected "data" to be an object');
    assert11(ALLOWED_ATTR_TYPES.includes(typeof attr), 'Expected "attr" to be a function or string');
    if (typeof attr === "function") {
      return attr(d2);
    }
    return d2 === null || d2 === void 0 ? void 0 : (_properties = d2.properties) === null || _properties === void 0 ? void 0 : _properties[attr];
  }
  function assert11(condition, message = "") {
    if (!condition) {
      throw new Error("CARTO style error: ".concat(message));
    }
  }

  // node_modules/@deck.gl/carto/dist/esm/style/palette.js
  var DEFAULT_PALETTE = "PurpOr";
  var NULL_COLOR = [204, 204, 204];
  var OTHERS_COLOR = [119, 119, 119];
  function getPalette(name, numCategories) {
    const palette = cartoColors[name];
    let paletteIndex = numCategories;
    assert11(palette, 'Palette "'.concat(name, '" not found. Expected a CARTOColors string'));
    const palettesColorVariants = Object.keys(palette).filter((p2) => p2 !== "tags").map(Number);
    const longestPaletteIndex = Math.max(...palettesColorVariants);
    const smallestPaletteIndex = Math.min(...palettesColorVariants);
    if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {
      paletteIndex = longestPaletteIndex;
    } else if (numCategories < smallestPaletteIndex) {
      paletteIndex = smallestPaletteIndex;
    }
    let colors = palette[paletteIndex];
    if (palette.tags && palette.tags.includes("qualitative")) {
      colors = colors.slice(0, -1);
    }
    return colors.map((c2) => hexToRgb(c2));
  }
  function hexToRgb(hex) {
    let result = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex);
    if (result) {
      return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16), 255];
    }
    result = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex);
    if (result) {
      return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16), parseInt(result[4] + result[4], 16)];
    }
    result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
      return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];
    }
    result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    assert11(result, 'Hexadecimal color "'.concat(hex, '" was not parsed correctly'));
    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), parseInt(result[4], 16)];
  }

  // node_modules/@deck.gl/carto/dist/esm/style/color-categories-style.js
  function colorCategories({
    attr,
    domain,
    colors = DEFAULT_PALETTE,
    nullColor = NULL_COLOR,
    othersColor = OTHERS_COLOR
  }) {
    assert11(Array.isArray(domain), 'Expected "domain" to be an array of numbers or strings');
    const colorsByCategory = {};
    const palette = typeof colors === "string" ? getPalette(colors, domain.length) : colors;
    for (const [i2, c2] of domain.entries()) {
      colorsByCategory[c2] = palette[i2];
    }
    return (d2) => {
      const value = getAttrValue(attr, d2);
      return typeof value === "number" && Number.isFinite(value) || typeof value === "string" ? colorsByCategory[value] || othersColor : nullColor;
    };
  }

  // node_modules/@preact/signals-core/dist/signals-core.module.js
  function i() {
    throw new Error("Cycle detected");
  }
  var t = Symbol.for("preact-signals");
  function r() {
    if (!(v > 1)) {
      var i2, t2 = false;
      while (void 0 !== f) {
        var r2 = f;
        f = void 0;
        e++;
        while (void 0 !== r2) {
          var n2 = r2.o;
          r2.o = void 0;
          r2.f &= -3;
          if (!(8 & r2.f) && l(r2))
            try {
              r2.c();
            } catch (r3) {
              if (!t2) {
                i2 = r3;
                t2 = true;
              }
            }
          r2 = n2;
        }
      }
      e = 0;
      v--;
      if (t2)
        throw i2;
    } else
      v--;
  }
  function n(i2) {
    if (v > 0)
      return i2();
    v++;
    try {
      return i2();
    } finally {
      r();
    }
  }
  var o = void 0;
  var f = void 0;
  var v = 0;
  var e = 0;
  var u = 0;
  function c(i2) {
    if (void 0 !== o) {
      var t2 = i2.n;
      if (void 0 === t2 || t2.t !== o) {
        t2 = { i: 0, S: i2, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t2 };
        if (void 0 !== o.s)
          o.s.n = t2;
        o.s = t2;
        i2.n = t2;
        if (32 & o.f)
          i2.S(t2);
        return t2;
      } else if (-1 === t2.i) {
        t2.i = 0;
        if (void 0 !== t2.n) {
          t2.n.p = t2.p;
          if (void 0 !== t2.p)
            t2.p.n = t2.n;
          t2.p = o.s;
          t2.n = void 0;
          o.s.n = t2;
          o.s = t2;
        }
        return t2;
      }
    }
  }
  function d(i2) {
    this.v = i2;
    this.i = 0;
    this.n = void 0;
    this.t = void 0;
  }
  d.prototype.brand = t;
  d.prototype.h = function() {
    return true;
  };
  d.prototype.S = function(i2) {
    if (this.t !== i2 && void 0 === i2.e) {
      i2.x = this.t;
      if (void 0 !== this.t)
        this.t.e = i2;
      this.t = i2;
    }
  };
  d.prototype.U = function(i2) {
    if (void 0 !== this.t) {
      var t2 = i2.e, r2 = i2.x;
      if (void 0 !== t2) {
        t2.x = r2;
        i2.e = void 0;
      }
      if (void 0 !== r2) {
        r2.e = t2;
        i2.x = void 0;
      }
      if (i2 === this.t)
        this.t = r2;
    }
  };
  d.prototype.subscribe = function(i2) {
    var t2 = this;
    return O(function() {
      var r2 = t2.value, n2 = 32 & this.f;
      this.f &= -33;
      try {
        i2(r2);
      } finally {
        this.f |= n2;
      }
    });
  };
  d.prototype.valueOf = function() {
    return this.value;
  };
  d.prototype.toString = function() {
    return this.value + "";
  };
  d.prototype.toJSON = function() {
    return this.value;
  };
  d.prototype.peek = function() {
    return this.v;
  };
  Object.defineProperty(d.prototype, "value", { get: function() {
    var i2 = c(this);
    if (void 0 !== i2)
      i2.i = this.i;
    return this.v;
  }, set: function(t2) {
    if (o instanceof _)
      !function() {
        throw new Error("Computed cannot have side-effects");
      }();
    if (t2 !== this.v) {
      if (e > 100)
        i();
      this.v = t2;
      this.i++;
      u++;
      v++;
      try {
        for (var n2 = this.t; void 0 !== n2; n2 = n2.x)
          n2.t.N();
      } finally {
        r();
      }
    }
  } });
  function a(i2) {
    return new d(i2);
  }
  function l(i2) {
    for (var t2 = i2.s; void 0 !== t2; t2 = t2.n)
      if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i)
        return true;
    return false;
  }
  function y(i2) {
    for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) {
      var r2 = t2.S.n;
      if (void 0 !== r2)
        t2.r = r2;
      t2.S.n = t2;
      t2.i = -1;
      if (void 0 === t2.n) {
        i2.s = t2;
        break;
      }
    }
  }
  function w(i2) {
    var t2 = i2.s, r2 = void 0;
    while (void 0 !== t2) {
      var n2 = t2.p;
      if (-1 === t2.i) {
        t2.S.U(t2);
        if (void 0 !== n2)
          n2.n = t2.n;
        if (void 0 !== t2.n)
          t2.n.p = n2;
      } else
        r2 = t2;
      t2.S.n = t2.r;
      if (void 0 !== t2.r)
        t2.r = void 0;
      t2 = n2;
    }
    i2.s = r2;
  }
  function _(i2) {
    d.call(this, void 0);
    this.x = i2;
    this.s = void 0;
    this.g = u - 1;
    this.f = 4;
  }
  (_.prototype = new d()).h = function() {
    this.f &= -3;
    if (1 & this.f)
      return false;
    if (32 == (36 & this.f))
      return true;
    this.f &= -5;
    if (this.g === u)
      return true;
    this.g = u;
    this.f |= 1;
    if (this.i > 0 && !l(this)) {
      this.f &= -2;
      return true;
    }
    var i2 = o;
    try {
      y(this);
      o = this;
      var t2 = this.x();
      if (16 & this.f || this.v !== t2 || 0 === this.i) {
        this.v = t2;
        this.f &= -17;
        this.i++;
      }
    } catch (i3) {
      this.v = i3;
      this.f |= 16;
      this.i++;
    }
    o = i2;
    w(this);
    this.f &= -2;
    return true;
  };
  _.prototype.S = function(i2) {
    if (void 0 === this.t) {
      this.f |= 36;
      for (var t2 = this.s; void 0 !== t2; t2 = t2.n)
        t2.S.S(t2);
    }
    d.prototype.S.call(this, i2);
  };
  _.prototype.U = function(i2) {
    if (void 0 !== this.t) {
      d.prototype.U.call(this, i2);
      if (void 0 === this.t) {
        this.f &= -33;
        for (var t2 = this.s; void 0 !== t2; t2 = t2.n)
          t2.S.U(t2);
      }
    }
  };
  _.prototype.N = function() {
    if (!(2 & this.f)) {
      this.f |= 6;
      for (var i2 = this.t; void 0 !== i2; i2 = i2.x)
        i2.t.N();
    }
  };
  _.prototype.peek = function() {
    if (!this.h())
      i();
    if (16 & this.f)
      throw this.v;
    return this.v;
  };
  Object.defineProperty(_.prototype, "value", { get: function() {
    if (1 & this.f)
      i();
    var t2 = c(this);
    this.h();
    if (void 0 !== t2)
      t2.i = this.i;
    if (16 & this.f)
      throw this.v;
    return this.v;
  } });
  function p(i2) {
    return new _(i2);
  }
  function g(i2) {
    var t2 = i2.u;
    i2.u = void 0;
    if ("function" == typeof t2) {
      v++;
      var n2 = o;
      o = void 0;
      try {
        t2();
      } catch (t3) {
        i2.f &= -2;
        i2.f |= 8;
        b(i2);
        throw t3;
      } finally {
        o = n2;
        r();
      }
    }
  }
  function b(i2) {
    for (var t2 = i2.s; void 0 !== t2; t2 = t2.n)
      t2.S.U(t2);
    i2.x = void 0;
    i2.s = void 0;
    g(i2);
  }
  function x(i2) {
    if (o !== this)
      throw new Error("Out-of-order effect");
    w(this);
    o = i2;
    this.f &= -2;
    if (8 & this.f)
      b(this);
    r();
  }
  function E(i2) {
    this.x = i2;
    this.u = void 0;
    this.s = void 0;
    this.o = void 0;
    this.f = 32;
  }
  E.prototype.c = function() {
    var i2 = this.S();
    try {
      if (8 & this.f)
        return;
      if (void 0 === this.x)
        return;
      var t2 = this.x();
      if ("function" == typeof t2)
        this.u = t2;
    } finally {
      i2();
    }
  };
  E.prototype.S = function() {
    if (1 & this.f)
      i();
    this.f |= 1;
    this.f &= -9;
    g(this);
    y(this);
    v++;
    var t2 = o;
    o = this;
    return x.bind(this, t2);
  };
  E.prototype.N = function() {
    if (!(2 & this.f)) {
      this.f |= 2;
      this.o = f;
      f = this;
    }
  };
  E.prototype.d = function() {
    this.f |= 8;
    if (!(1 & this.f))
      b(this);
  };
  function O(i2) {
    var t2 = new E(i2);
    try {
      t2.c();
    } catch (i3) {
      t2.d();
      throw i3;
    }
    return t2.d.bind(t2);
  }

  // src/hra-node-dist-vis.js
  var import_cartocolor = __toESM(require_cartocolor2(), 1);
  var import_papaparse = __toESM(require_papaparse_min(), 1);

  // inline-worker:__inline-worker
  function inlineWorker(scriptText) {
    let blob = new Blob([scriptText], { type: "text/javascript" });
    let url = URL.createObjectURL(blob);
    let worker = new Worker(url);
    URL.revokeObjectURL(url);
    return worker;
  }

  // src/distance-edges.worker.js
  function Worker3() {
    return inlineWorker('var g=(t,e)=>(e=Symbol[t])?e:Symbol.for("Symbol."+t);var q=function(t,e){this[0]=t,this[1]=e};var x=t=>{var e=t[g("asyncIterator")],i=!1,s,o={};return e==null?(e=t[g("iterator")](),s=n=>o[n]=c=>e[n](c)):(e=e.call(t),s=n=>o[n]=c=>{if(i){if(i=!1,n==="throw")throw c;return c}return i=!0,{done:!1,value:new q(new Promise(f=>{var r=e[n](c);if(!(r instanceof Object))throw TypeError("Object expected");f(r)}),1)}}),o[g("iterator")]=()=>o,s("next"),"throw"in e?s("throw"):o.throw=n=>{throw n},"return"in e&&s("return"),o};function T(t,e){let i=t[0]-e[0],s=t[1]-e[1],o=t[2]-e[2];return i*i+s*s+o*o}var X=[[-1,-1],[-1,0],[-1,1],[1,-1],[1,0],[1,1],[0,-1],[0,0],[0,1]];function*Y(t,e,i,s){for(let[o,n]of t.entries()){let c=s,f;for(let r of i){let d=T(n,r);d<c&&(c=d,f=r)}f&&(yield[e[o],...n,...f])}}function y(t,e){let i=e[t.cell[0]]=e[t.cell[0]]||{},s=i[t.cell[1]]=i[t.cell[1]]||{nodes:[],positions:[]};s.nodes.push(t.__index__),s.positions.push(t.position)}function*M(t,e,i,s){var f,r,d,u;let o={},n={};for(let[a,l]of t.entries())l.__index__=a,l.position=[(f=l.x)!=null?f:0,(r=l.y)!=null?r:0,(d=l.z)!=null?d:0],l.cell=[Math.floor(l.x/s),Math.floor(l.y/s)],l[e]===i?y(l,n):y(l,o);let c=s*s;for(let a in o)for(let l in o[a]){let _=o[a][l],p=[];for(let[C,S]of X){let m=parseInt(a)+C,E=parseInt(l)+S,h=(u=n[m])==null?void 0:u[E];h&&(p=p.concat(h.positions))}p.length>0&&(yield*x(Y(_.positions,_.nodes,p,c)))}}onmessage=function(t){let{nodes:e,type_field:i,target_type:s,maxDist:o}=t.data,n=new Array(e.length),c=0,f=Math.floor(e.length/10);for(let r of M(e,i,s,o)){if(n[c]=r,c%f===0){let d=Math.round(c/e.length*100);postMessage({status:"processing",percentage:d,node_index:r[0]})}c++}postMessage({status:"complete",edges:n.slice(0,c)})};\n');
  }

  // src/hra-node-dist-vis.js
  async function fetchCsv(url, papaOptions = {}) {
    return new Promise((resolve2) => {
      import_papaparse.default.parse(url, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: true,
        ...papaOptions,
        worker: true,
        download: true,
        complete: (results) => {
          resolve2(results.data);
        }
      });
    });
  }
  function delay(t2, val) {
    return new Promise((resolve2) => setTimeout(resolve2, t2, val));
  }
  async function distanceEdges(nodes, type_field, target_type, maxDist) {
    const worker = new Worker3();
    return new Promise((resolve2) => {
      worker.onmessage = (e2) => {
        if (e2.data.status === "processing") {
          console.log(`Computing edges; ${e2.data.percentage}% complete.`);
        } else if (e2.data.status === "complete") {
          resolve2(e2.data.edges);
          worker.terminate();
        }
      };
      worker.postMessage({ nodes, type_field, target_type, maxDist });
    });
  }
  var template = document.createElement("template");
  template.innerHTML = `<style>
#vis {
  width: 100%;
  height: 100%;
  position: relative !important;
}
</style>
<canvas id="vis"></canvas>
`;
  var HraNodeDistanceVisualization = class extends HTMLElement {
    static observedAttributes = [
      "nodes",
      "edges",
      "color-map",
      "color-map-key",
      "color-map-value",
      "node-target-key",
      "node-target-value",
      "max-edge-distance"
    ];
    nodesUrl = a();
    edgesUrl = a();
    colorMapUrl = a();
    colorMapKey = a();
    colorMapValue = a();
    nodeTargetKey = a();
    nodeTargetValue = a();
    maxEdgeDistance = a();
    toDispose = [];
    initialized = false;
    nodes = a([]);
    nodes$ = p(async () => {
      if (this.nodesUrl.value) {
        const nodes = await fetchCsv(this.nodesUrl.value);
        for (const node of nodes) {
          node.position = [node.x ?? 0, node.y ?? 0, node.z ?? 0];
        }
        return nodes;
      } else {
        return [];
      }
    });
    edges = a([]);
    edges$ = p(async () => {
      const nodes = this.nodes.value;
      if (this.edgesUrl.value && nodes.length > 0) {
        await delay(100);
        const edges = await fetchCsv(this.edgesUrl.value, { header: false });
        return edges;
      } else if (nodes.length > 0) {
        const nodeKey = this.nodeTargetKey.value;
        const nodeValue = this.nodeTargetValue.value;
        const maxDist = this.maxEdgeDistance.value;
        console.log("start", /* @__PURE__ */ new Date());
        const edges = await distanceEdges(nodes, nodeKey, nodeValue, maxDist);
        console.log("end", /* @__PURE__ */ new Date());
        return edges;
      } else {
        return [];
      }
    });
    colorCoding = a();
    colorCoding$ = p(async () => {
      const nodes = this.nodes.value;
      let colorDomain;
      let colorRange;
      if (this.colorMapUrl.value) {
        const colorMapData = await fetchCsv(this.colorMapUrl.value);
        colorDomain = [];
        colorRange = [];
        for (const row of colorMapData) {
          colorDomain.push(row[this.colorMapKey.value]);
          const color = row[this.colorMapValue.value];
          if (color?.startsWith("[")) {
            colorRange.push(JSON.parse(color));
          } else {
            colorRange.push([255, 255, 255]);
          }
        }
      } else if (nodes.length > 0) {
        const nodeKey = this.nodeTargetKey.value;
        const nodeValues = /* @__PURE__ */ new Set();
        for (const node of nodes) {
          nodeValues.add(node[nodeKey]);
        }
        colorDomain = Array.from(nodeValues).sort();
        const maxColors = Math.max(2, Math.min(11, colorDomain.length)) + "";
        const colorSchemes = Object.keys(import_cartocolor.default).filter((c2) => import_cartocolor.default[c2][maxColors]);
        colorRange = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];
      } else {
        return void 0;
      }
      return (attr) => colorCategories({
        attr,
        domain: colorDomain,
        colors: colorRange,
        othersColor: [255, 255, 255],
        nullColor: [255, 255, 255]
      });
    });
    positionScaling = p(() => {
      let maxDimSize = 1;
      for (const node of this.nodes.value) {
        maxDimSize = Math.max(maxDimSize, ...node.position);
      }
      const scale3 = ([x2, y2, z]) => [x2 / maxDimSize, 1 - y2 / maxDimSize, z / maxDimSize];
      return (attr) => {
        return (d2) => scale3(attr(d2));
      };
    });
    nodesLayer = p(() => {
      if (this.colorCoding.value && this.nodes.value.length > 0) {
        const nodeKey = this.nodeTargetKey.value;
        return new PointCloudLayer({
          id: "nodes",
          data: this.nodes.value,
          getPosition: this.positionScaling.value((d2) => d2.position),
          getColor: this.colorCoding.value((d2) => d2[nodeKey]),
          pickable: true,
          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
          pointSize: 1.5
        });
      } else {
        return void 0;
      }
    });
    edgesLayer = p(() => {
      if (this.colorCoding.value && this.edges.value.length > 0) {
        const nodeKey = this.nodeTargetKey.value;
        const nodes = this.nodes.value;
        return new LineLayer({
          id: "edges",
          data: this.edges.value,
          getSourcePosition: this.positionScaling.value(([node_index, sx, sy, sz, tx, ty, tz]) => [sx, sy, sz]),
          getTargetPosition: this.positionScaling.value(([node_index, sx, sy, sz, tx, ty, tz]) => [tx, ty, tz]),
          getColor: this.colorCoding.value(([node_index]) => nodes[node_index][nodeKey]),
          pickable: false,
          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
          getWidth: 1
        });
      } else {
        return void 0;
      }
    });
    constructor() {
      super();
      const root = this.attachShadow({ mode: "open" });
      root.appendChild(template.content.cloneNode(true));
      this.$canvas = root.getElementById("vis");
      this.$canvas.addEventListener("contextmenu", (e2) => e2.preventDefault());
    }
    async connectedCallback() {
      this.deck = new Deck({
        canvas: this.$canvas,
        controller: true,
        views: [new OrbitView({ id: "orbit", orbitAxis: "Y" })],
        initialViewState: {
          orbitAxis: "Y",
          camera: "orbit",
          zoom: 9,
          minRotationX: -90,
          maxRotationX: 90,
          rotationX: 0,
          rotationOrbit: 0,
          dragMode: "rotate",
          target: [0.5, 0.5]
        },
        onClick: (e2) => e2.picked && console.log("Node Clicked", e2),
        layers: []
      });
      this.trackDisposal(
        O(() => {
          this.deck.setProps({ layers: [this.nodesLayer.value, this.edgesLayer.value].filter((l2) => !!l2) });
        })
      );
      this.trackDisposal(
        O(async () => {
          this.nodes.value = [];
          this.nodes.value = await this.nodes$.value;
        })
      );
      this.trackDisposal(
        O(async () => {
          this.edges.value = [];
          this.edges.value = await this.edges$.value;
        })
      );
      this.trackDisposal(
        O(async () => {
          const colorCoding = await this.colorCoding$.value;
          if (colorCoding) {
            this.colorCoding.value = colorCoding;
          }
        })
      );
      n(() => {
        this.nodesUrl.value = this.getAttribute("nodes");
        this.edgesUrl.value = this.getAttribute("edges");
        this.colorMapUrl.value = this.getAttribute("color-map");
        this.colorMapKey.value = this.getAttribute("color-map-key") || "cell_type";
        this.colorMapValue.value = this.getAttribute("color-map-value") || "cell_color";
        this.nodeTargetKey.value = this.getAttribute("node-target-key");
        this.nodeTargetValue.value = this.getAttribute("node-target-value");
        this.maxEdgeDistance.value = parseFloat(this.getAttribute("max-edge-distance"));
        this.initialized = true;
      });
    }
    attributesLookup = {
      nodes: this.nodesUrl,
      edges: this.edgesUrl,
      "color-map": this.colorMapUrl,
      "color-map-key": this.colorMapKey,
      "color-map-value": this.colorMapValue,
      "node-target-key": this.nodeTargetKey,
      "node-target-value": this.nodeTargetValue,
      "max-edge-distance": this.maxEdgeDistance
    };
    attributeChangedCallback(name, _oldValue, newValue) {
      if (this.initialized) {
        if (name === "max-edge-distance" && typeof newValue === "string") {
          newValue = parseFloat(newValue);
        }
        this.attributesLookup[name].value = newValue;
      }
    }
    trackDisposal(disposable) {
      this.toDispose.push(disposable);
    }
    disconnectedCallback() {
      this.toDispose.forEach((dispose) => dispose());
      this.toDispose = [];
    }
  };
  window.customElements.define("hra-node-dist-vis", HraNodeDistanceVisualization);
})();
/*! Bundled license information:

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)

papaparse/papaparse.min.js:
  (* @license
  Papa Parse
  v5.4.1
  https://github.com/mholt/PapaParse
  License: MIT
  *)
*/
